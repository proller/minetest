



!!!!!!!!!!!!!!!!!
 Merge proller/sqlite to next failed:

# On branch next
# You have unmerged paths.
#   (fix conflicts and run "git commit")
#
# Changes to be committed:
#
#	modified:   minetest.conf.example
#	modified:   src/defaultsettings.cpp
#
# Unmerged paths:
#   (use "git add <file>..." to mark resolution)
#
#	both modified:      src/map.cpp
#
diff --cc src/map.cpp
index 70fcaf0,16d0cc3..0000000
--- a/src/map.cpp
+++ b/src/map.cpp
@@@ -3218,8 -3167,78 +3218,81 @@@ plan_b
  	//return (s16)level;
  }
  
++<<<<<<< HEAD
++=======
+ void ServerMap::createDatabase() {
+ 	int e;
+ 	assert(m_database);
+ 	e = sqlite3_exec(m_database,
+ 		"CREATE TABLE IF NOT EXISTS `blocks` ("
+ 			"`pos` INT NOT NULL PRIMARY KEY,"
+ 			"`data` BLOB"
+ 		");"
+ 	, NULL, NULL, NULL);
+ 	if(e == SQLITE_ABORT)
+ 		throw FileNotGoodException("Could not create database structure");
+ 	else
+ 		infostream<<"ServerMap: Database structure was created";
+ }
+ 
+ void ServerMap::verifyDatabase() {
+ 	if(m_database)
+ 		return;
+ 
+ 	{
+ 		std::string dbp = m_savedir + DIR_DELIM + "map.sqlite";
+ 		bool needs_create = false;
+ 		int d;
+ 
+ 		/*
+ 			Open the database connection
+ 		*/
+ 
+ 		createDirs(m_savedir);
+ 
+ 		if(!fs::PathExists(dbp))
+ 			needs_create = true;
+ 
+ 		d = sqlite3_open_v2(dbp.c_str(), &m_database, SQLITE_OPEN_READWRITE | SQLITE_OPEN_CREATE, NULL);
+ 		if(d != SQLITE_OK) {
+ 			infostream<<"WARNING: Database failed to open: "<<sqlite3_errmsg(m_database)<<std::endl;
+ 			throw FileNotGoodException("Cannot open database file");
+ 		}
+ 
+ 		if(needs_create)
+ 			createDatabase();
+ 
+ 		d = sqlite3_exec(m_database, (std::string("PRAGMA synchronous = ") + g_settings->get("sqlite_synchronous")).c_str(), NULL, NULL, NULL);
+ 		if(d != SQLITE_OK) {
+ 			infostream<<"WARNING: Database pragma set failed: "<<sqlite3_errmsg(m_database)<<std::endl;
+ 			throw FileNotGoodException("Cannot set pragma");
+ 		}
+ 
+ 		d = sqlite3_prepare(m_database, "SELECT `data` FROM `blocks` WHERE `pos`=? LIMIT 1", -1, &m_database_read, NULL);
+ 		if(d != SQLITE_OK) {
+ 			infostream<<"WARNING: Database read statment failed to prepare: "<<sqlite3_errmsg(m_database)<<std::endl;
+ 			throw FileNotGoodException("Cannot prepare read statement");
+ 		}
+ 
+ 		d = sqlite3_prepare(m_database, "REPLACE INTO `blocks` VALUES(?, ?)", -1, &m_database_write, NULL);
+ 		if(d != SQLITE_OK) {
+ 			infostream<<"WARNING: Database write statment failed to prepare: "<<sqlite3_errmsg(m_database)<<std::endl;
+ 			throw FileNotGoodException("Cannot prepare write statement");
+ 		}
+ 
+ 		d = sqlite3_prepare(m_database, "SELECT `pos` FROM `blocks`", -1, &m_database_list, NULL);
+ 		if(d != SQLITE_OK) {
+ 			infostream<<"WARNING: Database list statment failed to prepare: "<<sqlite3_errmsg(m_database)<<std::endl;
+ 			throw FileNotGoodException("Cannot prepare read statement");
+ 		}
+ 
+ 		infostream<<"ServerMap: Database opened"<<std::endl;
+ 	}
+ }
+ 
++>>>>>>> proller/sqlite
  bool ServerMap::loadFromFolders() {
 -	if(!m_database && !fs::PathExists(m_savedir + DIR_DELIM + "map.sqlite"))
 +	if(!dbase->Initialized() && !fs::PathExists(m_savedir + DIR_DELIM + "map.sqlite")) // ?
  		return true;
  	return false;
  }




!!!!!!!!!!!!!!!!!
 Merge sapier/add_surface_detection_function to next failed:

# On branch next
# You have unmerged paths.
#   (fix conflicts and run "git commit")
#
# Changes to be committed:
#
#	modified:   doc/lua_api.txt
#	modified:   src/environment.h
#	modified:   src/map.cpp
#	modified:   src/map.h
#
# Unmerged paths:
#   (use "git add <file>..." to mark resolution)
#
#	both modified:      src/script/lua_api/l_env.cpp
#	both modified:      src/script/lua_api/l_env.h
#
diff --cc src/script/lua_api/l_env.cpp
index 731e730,47e9963..0000000
--- a/src/script/lua_api/l_env.cpp
+++ b/src/script/lua_api/l_env.cpp
@@@ -781,40 -937,49 +805,84 @@@ int ModApiEnvMod::l_get_humidity(lua_St
  }
  
  
 -bool ModApiEnvMod::Initialize(lua_State *L,int top)
 -{
 +void ModApiEnvMod::Initialize(lua_State *L, int top)
 +{
++<<<<<<< HEAD
 +	API_FCT(set_node);
 +	API_FCT(add_node);
 +	API_FCT(add_item);
 +	API_FCT(remove_node);
 +	API_FCT(get_node);
 +	API_FCT(get_node_or_nil);
 +	API_FCT(get_node_light);
 +	API_FCT(place_node);
 +	API_FCT(dig_node);
 +	API_FCT(punch_node);
 +	API_FCT(get_node_max_level);
 +	API_FCT(get_node_level);
 +	API_FCT(set_node_level);
 +	API_FCT(add_node_level);
 +	API_FCT(add_entity);
 +	API_FCT(get_meta);
 +	API_FCT(get_node_timer);
 +	API_FCT(get_player_by_name);
 +	API_FCT(get_objects_inside_radius);
 +	API_FCT(set_timeofday);
 +	API_FCT(get_timeofday);
 +	API_FCT(get_gametime);
 +	API_FCT(find_node_near);
 +	API_FCT(find_nodes_in_area);
 +	API_FCT(get_perlin);
 +	API_FCT(get_perlin_map);
 +	API_FCT(get_voxel_manip);
 +	API_FCT(clear_objects);
 +	API_FCT(spawn_tree);
 +	API_FCT(find_path);
 +	API_FCT(line_of_sight);
 +	API_FCT(transforming_liquid_add);
 +	API_FCT(get_heat);
 +	API_FCT(get_humidity);
++=======
+ 
+ 	bool retval = true;
+ 
+ 	retval &= API_FCT(set_node);
+ 	retval &= API_FCT(add_node);
+ 	retval &= API_FCT(add_item);
+ 	retval &= API_FCT(remove_node);
+ 	retval &= API_FCT(get_node);
+ 	retval &= API_FCT(get_node_or_nil);
+ 	retval &= API_FCT(get_node_light);
+ 	retval &= API_FCT(place_node);
+ 	retval &= API_FCT(dig_node);
+ 	retval &= API_FCT(punch_node);
+ 	retval &= API_FCT(get_node_max_level);
+ 	retval &= API_FCT(get_node_level);
+ 	retval &= API_FCT(set_node_level);
+ 	retval &= API_FCT(add_node_level);
+ 	retval &= API_FCT(add_entity);
+ 	retval &= API_FCT(get_meta);
+ 	retval &= API_FCT(get_node_timer);
+ 	retval &= API_FCT(get_player_by_name);
+ 	retval &= API_FCT(get_objects_inside_radius);
+ 	retval &= API_FCT(set_timeofday);
+ 	retval &= API_FCT(get_timeofday);
+ 	retval &= API_FCT(find_node_near);
+ 	retval &= API_FCT(find_nodes_in_area);
+ 	retval &= API_FCT(get_perlin);
+ 	retval &= API_FCT(get_perlin_map);
+ 	retval &= API_FCT(get_voxel_manip);
+ 	retval &= API_FCT(get_mapgen_object);
+ 	retval &= API_FCT(set_mapgen_params);
+ 	retval &= API_FCT(clear_objects);
+ 	retval &= API_FCT(get_surface);
+ 	retval &= API_FCT(spawn_tree);
+ 	retval &= API_FCT(find_path);
+ 	retval &= API_FCT(line_of_sight);
+ 	retval &= API_FCT(transforming_liquid_add);
+ 	retval &= API_FCT(get_heat);
+ 	retval &= API_FCT(get_humidity);
+ 
+ 	return retval;
++>>>>>>> sapier/add_surface_detection_function
  }
 -
 -ModApiEnvMod modapienv_prototype;
diff --cc src/script/lua_api/l_env.h
index 5f3467f,b01fe5a..0000000
--- a/src/script/lua_api/l_env.h
+++ b/src/script/lua_api/l_env.h
@@@ -147,8 -159,13 +147,16 @@@ private
  	static int l_get_heat(lua_State *L);
  	static int l_get_humidity(lua_State *L);
  	
++<<<<<<< HEAD
++=======
+ 	// minetest.get_surface(basepos,yoffset,walkable_only=false)
+ 	static int l_get_surface(lua_State *L);
+ 
+ 	static struct EnumString es_MapgenObject[];
+ 	
++>>>>>>> sapier/add_surface_detection_function
  public:
 -	bool Initialize(lua_State *L, int top);
 +	static void Initialize(lua_State *L, int top);
  };
  
  class LuaABM : public ActiveBlockModifier





!!!!!!!!!!!!!!!!!
 Merge ShadowNinja/protection_support to next failed:

# On branch next
# You have unmerged paths.
#   (fix conflicts and run "git commit")
#
# Changes to be committed:
#
#	modified:   builtin/item.lua
#	modified:   doc/lua_api.txt
#
# Unmerged paths:
#   (use "git add <file>..." to mark resolution)
#
#	both modified:      builtin/misc.lua
#
diff --cc builtin/misc.lua
index 82a0ba2,46426ac..0000000
--- a/builtin/misc.lua
+++ b/builtin/misc.lua
@@@ -99,3 -99,15 +99,18 @@@ function minetest.setting_get_pos(name
  	return minetest.string_to_pos(value)
  end
  
++<<<<<<< HEAD
++=======
+ -- To be overriden by protection mods
+ function minetest.can_interact(pos, name)
+ 	return true
+ end
+ 
+ function minetest.formspec_escape(str)
+ 	str = string.gsub(str, "\\", "\\\\")
+ 	str = string.gsub(str, "%[", "\\[")
+ 	str = string.gsub(str, "%]", "\\]")
+ 	return str
+ end
+ 
++>>>>>>> ShadowNinja/protection_support




!!!!!!!!!!!!!!!!!
 Merge sapier/add_surface_detection_function to next failed:

# On branch next
# You have unmerged paths.
#   (fix conflicts and run "git commit")
#
# Changes to be committed:
#
#	modified:   doc/lua_api.txt
#	modified:   src/environment.h
#	modified:   src/map.cpp
#	modified:   src/map.h
#
# Unmerged paths:
#   (use "git add <file>..." to mark resolution)
#
#	both modified:      src/script/lua_api/l_env.cpp
#	both modified:      src/script/lua_api/l_env.h
#
diff --cc src/script/lua_api/l_env.cpp
index 0f2a409,47e9963..0000000
--- a/src/script/lua_api/l_env.cpp
+++ b/src/script/lua_api/l_env.cpp
@@@ -771,39 -937,49 +795,83 @@@ int ModApiEnvMod::l_get_humidity(lua_St
  }
  
  
 -bool ModApiEnvMod::Initialize(lua_State *L,int top)
 -{
 +void ModApiEnvMod::Initialize(lua_State *L, int top)
 +{
++<<<<<<< HEAD
 +	API_FCT(set_node);
 +	API_FCT(add_node);
 +	API_FCT(add_item);
 +	API_FCT(remove_node);
 +	API_FCT(get_node);
 +	API_FCT(get_node_or_nil);
 +	API_FCT(get_node_light);
 +	API_FCT(place_node);
 +	API_FCT(dig_node);
 +	API_FCT(punch_node);
 +	API_FCT(get_node_max_level);
 +	API_FCT(get_node_level);
 +	API_FCT(set_node_level);
 +	API_FCT(add_node_level);
 +	API_FCT(add_entity);
 +	API_FCT(get_meta);
 +	API_FCT(get_node_timer);
 +	API_FCT(get_player_by_name);
 +	API_FCT(get_objects_inside_radius);
 +	API_FCT(set_timeofday);
 +	API_FCT(get_timeofday);
 +	API_FCT(find_node_near);
 +	API_FCT(find_nodes_in_area);
 +	API_FCT(get_perlin);
 +	API_FCT(get_perlin_map);
 +	API_FCT(get_voxel_manip);
 +	API_FCT(clear_objects);
 +	API_FCT(spawn_tree);
 +	API_FCT(find_path);
 +	API_FCT(line_of_sight);
 +	API_FCT(transforming_liquid_add);
 +	API_FCT(get_heat);
 +	API_FCT(get_humidity);
++=======
+ 
+ 	bool retval = true;
+ 
+ 	retval &= API_FCT(set_node);
+ 	retval &= API_FCT(add_node);
+ 	retval &= API_FCT(add_item);
+ 	retval &= API_FCT(remove_node);
+ 	retval &= API_FCT(get_node);
+ 	retval &= API_FCT(get_node_or_nil);
+ 	retval &= API_FCT(get_node_light);
+ 	retval &= API_FCT(place_node);
+ 	retval &= API_FCT(dig_node);
+ 	retval &= API_FCT(punch_node);
+ 	retval &= API_FCT(get_node_max_level);
+ 	retval &= API_FCT(get_node_level);
+ 	retval &= API_FCT(set_node_level);
+ 	retval &= API_FCT(add_node_level);
+ 	retval &= API_FCT(add_entity);
+ 	retval &= API_FCT(get_meta);
+ 	retval &= API_FCT(get_node_timer);
+ 	retval &= API_FCT(get_player_by_name);
+ 	retval &= API_FCT(get_objects_inside_radius);
+ 	retval &= API_FCT(set_timeofday);
+ 	retval &= API_FCT(get_timeofday);
+ 	retval &= API_FCT(find_node_near);
+ 	retval &= API_FCT(find_nodes_in_area);
+ 	retval &= API_FCT(get_perlin);
+ 	retval &= API_FCT(get_perlin_map);
+ 	retval &= API_FCT(get_voxel_manip);
+ 	retval &= API_FCT(get_mapgen_object);
+ 	retval &= API_FCT(set_mapgen_params);
+ 	retval &= API_FCT(clear_objects);
+ 	retval &= API_FCT(get_surface);
+ 	retval &= API_FCT(spawn_tree);
+ 	retval &= API_FCT(find_path);
+ 	retval &= API_FCT(line_of_sight);
+ 	retval &= API_FCT(transforming_liquid_add);
+ 	retval &= API_FCT(get_heat);
+ 	retval &= API_FCT(get_humidity);
+ 
+ 	return retval;
++>>>>>>> sapier/add_surface_detection_function
  }
 -
 -ModApiEnvMod modapienv_prototype;
diff --cc src/script/lua_api/l_env.h
index fe2883b,b01fe5a..0000000
--- a/src/script/lua_api/l_env.h
+++ b/src/script/lua_api/l_env.h
@@@ -144,8 -159,13 +144,16 @@@ private
  	static int l_get_heat(lua_State *L);
  	static int l_get_humidity(lua_State *L);
  	
++<<<<<<< HEAD
++=======
+ 	// minetest.get_surface(basepos,yoffset,walkable_only=false)
+ 	static int l_get_surface(lua_State *L);
+ 
+ 	static struct EnumString es_MapgenObject[];
+ 	
++>>>>>>> sapier/add_surface_detection_function
  public:
 -	bool Initialize(lua_State *L, int top);
 +	static void Initialize(lua_State *L, int top);
  };
  
  class LuaABM : public ActiveBlockModifier




!!!!!!!!!!!!!!!!!
 Merge khonkhortisan/vertical_particles to next failed:

# On branch next
# You have unmerged paths.
#   (fix conflicts and run "git commit")
#
# Changes to be committed:
#
#	modified:   doc/lua_api.txt
#	modified:   src/client.cpp
#	modified:   src/client.h
#	modified:   src/clientserver.h
#	modified:   src/server.cpp
#	modified:   src/server.h
#
# Unmerged paths:
#   (use "git add <file>..." to mark resolution)
#
#	both modified:      src/game.cpp
#	both modified:      src/particles.cpp
#	both modified:      src/particles.h
#	both modified:      src/script/lua_api/l_particles.cpp
#
diff --cc src/game.cpp
index f082383,f32a73a..0000000
--- a/src/game.cpp
+++ b/src/game.cpp
@@@ -2291,9 -2069,7 +2291,13 @@@ void the_game
  						 event.spawn_particle.expirationtime,
  						 event.spawn_particle.size,
  						 event.spawn_particle.collisiondetection,
++<<<<<<< HEAD
 +						 texture,
 +						 v2f(0.0, 0.0),
 +						 v2f(1.0, 1.0));
++=======
+ 						 event.spawn_particle.vertical, ap);
++>>>>>>> khonkhortisan/vertical_particles
  				}
  				else if(event.type == CE_ADD_PARTICLESPAWNER)
  				{
@@@ -2315,7 -2091,8 +2319,12 @@@
  						 event.add_particlespawner.minsize,
  						 event.add_particlespawner.maxsize,
  						 event.add_particlespawner.collisiondetection,
++<<<<<<< HEAD
 +						 texture,
++=======
+ 						 event.add_particlespawner.vertical,
+ 						 ap,
++>>>>>>> khonkhortisan/vertical_particles
  						 event.add_particlespawner.id);
  				}
  				else if(event.type == CE_DELETE_PARTICLESPAWNER)
diff --cc src/particles.cpp
index 88905d4,e050df4..0000000
--- a/src/particles.cpp
+++ b/src/particles.cpp
@@@ -57,9 -57,8 +57,14 @@@ Particle::Particle
  	float expirationtime,
  	float size,
  	bool collisiondetection,
++<<<<<<< HEAD
 +	video::ITexture *texture,
 +	v2f texpos,
 +	v2f texsize
++=======
+ 	bool vertical,
+ 	AtlasPointer ap
++>>>>>>> khonkhortisan/vertical_particles
  ):
  	scene::ISceneNode(smgr->getRootSceneNode(), smgr)
  {
@@@ -199,8 -193,13 +205,13 @@@ void Particle::updateVertices(
  
  	for(u16 i=0; i<4; i++)
  	{
+ 		if (m_vertical) {
+ 			v3f ppos = m_player->getPosition()/BS;
+ 			m_vertices[i].Pos.rotateXZBy(atan2(ppos.Z-m_pos.Z, ppos.X-m_pos.X)/core::DEGTORAD+90);
+ 		} else {
 -			m_vertices[i].Pos.rotateYZBy(m_player->getPitch());
 -			m_vertices[i].Pos.rotateXZBy(m_player->getYaw());
 +		m_vertices[i].Pos.rotateYZBy(m_player->getPitch());
 +		m_vertices[i].Pos.rotateXZBy(m_player->getYaw());
+ 		}
  		m_box.addInternalPoint(m_vertices[i].Pos);
  		m_vertices[i].Pos += m_pos*BS;
  	}
@@@ -293,9 -292,8 +304,14 @@@ void addNodeParticle(IGameDef* gamedef
  		rand()%100/100., // expiration time
  		visual_size,
  		true,
++<<<<<<< HEAD
 +		texture,
 +		texpos,
 +		texsize);
++=======
+ 		false,
+ 		ap);
++>>>>>>> khonkhortisan/vertical_particles
  }
  
  /*
@@@ -306,7 -304,7 +322,11 @@@ ParticleSpawner::ParticleSpawner(IGameD
  	u16 amount, float time,
  	v3f minpos, v3f maxpos, v3f minvel, v3f maxvel, v3f minacc, v3f maxacc,
  	float minexptime, float maxexptime, float minsize, float maxsize,
++<<<<<<< HEAD
 +	bool collisiondetection, video::ITexture *texture, u32 id)
++=======
+ 	bool collisiondetection, bool vertical, AtlasPointer ap, u32 id)
++>>>>>>> khonkhortisan/vertical_particles
  {
  	m_gamedef = gamedef;
  	m_smgr = smgr;
@@@ -324,7 -322,8 +344,12 @@@
  	m_minsize = minsize;
  	m_maxsize = maxsize;
  	m_collisiondetection = collisiondetection;
++<<<<<<< HEAD
 +	m_texture = texture;
++=======
+ 	m_vertical = vertical;
+ 	m_ap = ap;
++>>>>>>> khonkhortisan/vertical_particles
  	m_time = 0;
  
  	for (u16 i = 0; i<=m_amount; i++)
@@@ -372,9 -371,8 +397,14 @@@ void ParticleSpawner::step(float dtime
  					exptime,
  					size,
  					m_collisiondetection,
++<<<<<<< HEAD
 +					m_texture,
 +					v2f(0.0, 0.0),
 +					v2f(1.0, 1.0));
++=======
+ 					m_vertical,
+ 					m_ap);
++>>>>>>> khonkhortisan/vertical_particles
  				m_spawntimes.erase(i);
  			}
  			else
@@@ -410,9 -408,8 +440,14 @@@
  					exptime,
  					size,
  					m_collisiondetection,
++<<<<<<< HEAD
 +					m_texture,
 +					v2f(0.0, 0.0),
 +					v2f(1.0, 1.0));
++=======
+ 					m_vertical,
+ 					m_ap);
++>>>>>>> khonkhortisan/vertical_particles
  			}
  		}
  	}
diff --cc src/particles.h
index 327dcbc,1b53e37..0000000
--- a/src/particles.h
+++ b/src/particles.h
@@@ -42,9 -42,8 +42,14 @@@ class Particle : public scene::ISceneNo
  		float expirationtime,
  		float size,
  		bool collisiondetection,
++<<<<<<< HEAD
 +		video::ITexture *texture,
 +		v2f texpos,
 +		v2f texsize
++=======
+ 		bool vertical,
+ 		AtlasPointer texture
++>>>>>>> khonkhortisan/vertical_particles
  	);
  	~Particle();
  
@@@ -88,7 -85,10 +93,14 @@@ private
  	v3f m_pos;
  	v3f m_velocity;
  	v3f m_acceleration;
++<<<<<<< HEAD
 +	LocalPlayer *m_player;
++=======
+ 	float tex_x0;
+ 	float tex_x1;
+ 	float tex_y0;
+ 	float tex_y1;
++>>>>>>> khonkhortisan/vertical_particles
  	float m_size;
  	u8 m_light;
  	bool m_collisiondetection;
@@@ -108,7 -111,8 +123,12 @@@ class ParticleSpawne
  		float minexptime, float maxexptime,
  		float minsize, float maxsize,
  		bool collisiondetection,
++<<<<<<< HEAD
 +		video::ITexture *texture,
++=======
+ 		bool vertical,
+ 		AtlasPointer ap,
++>>>>>>> khonkhortisan/vertical_particles
  		u32 id);
  
  	~ParticleSpawner();
@@@ -135,9 -139,10 +155,14 @@@
  	float m_maxexptime;
  	float m_minsize;
  	float m_maxsize;
++<<<<<<< HEAD
 +	video::ITexture *m_texture;
- 	std::vector<float> m_spawntimes;
++=======
  	bool m_collisiondetection;
+ 	bool m_vertical;
+ 	AtlasPointer m_ap;
++>>>>>>> khonkhortisan/vertical_particles
+ 	std::vector<float> m_spawntimes;
  };
  
  void allparticles_step (float dtime, ClientEnvironment &env);
diff --cc src/script/lua_api/l_particles.cpp
index 6b00914,bcb8286..0000000
--- a/src/script/lua_api/l_particles.cpp
+++ b/src/script/lua_api/l_particles.cpp
@@@ -17,39 -17,86 +17,94 @@@ with this program; if not, write to th
  51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
  */
  
 -#include "scriptapi.h"
 -#include "scriptapi_particles.h"
 +#include "lua_api/l_particles.h"
 +#include "lua_api/l_internal.h"
 +#include "common/c_converter.h"
  #include "server.h"
 -#include "script.h"
 -#include "scriptapi_types.h"
 -#include "scriptapi_common.h"
  
- // add_particle(pos, velocity, acceleration, expirationtime,
- // 		size, collisiondetection, texture, player)
+ // add_particle({pos=, velocity=, acceleration=, expirationtime=,
+ // 		size=, collisiondetection=, vertical=, texture=, player=})
  // pos/velocity/acceleration = {x=num, y=num, z=num}
  // expirationtime = num (seconds)
  // size = num
+ // collisiondetection = bool
+ // vertical = bool
  // texture = e.g."default_wood.png"
 -int l_add_particle(lua_State *L)
 +int ModApiParticles::l_add_particle(lua_State *L)
  {
 -	// Get server from registry
 -	Server *server = get_server(L);
  	// Get parameters
- 	v3f pos = check_v3f(L, 1);
- 	v3f vel = check_v3f(L, 2);
- 	v3f acc = check_v3f(L, 3);
- 	float expirationtime = luaL_checknumber(L, 4);
- 	float size = luaL_checknumber(L, 5);
- 	bool collisiondetection = lua_toboolean(L, 6);
- 	std::string texture = luaL_checkstring(L, 7);
+ 	v3f pos, vel, acc;
+ 	    pos= vel= acc= v3f(0, 0, 0);
+ 	float expirationtime, size;
+ 	      expirationtime= size= 1;
+ 	bool collisiondetection, vertical;
+ 	     collisiondetection= vertical= false;
+ 	std::string texture = "";
+ 	const char *playername = "";
  
+ 	if (lua_gettop(L) > 1) // deprecated
+ 	{
+ 		pos = check_v3f(L, 1);
+ 		vel = check_v3f(L, 2);
+ 		acc = check_v3f(L, 3);
+ 		expirationtime = luaL_checknumber(L, 4);
+ 		size = luaL_checknumber(L, 5);
+ 		collisiondetection = lua_toboolean(L, 6);
+ 		texture = luaL_checkstring(L, 7);
 -		if (lua_gettop(L) == 8) // only spawn for a single player
 +	if (lua_gettop(L) == 8) // only spawn for a single player
+ 			playername = luaL_checkstring(L, 8);
+ 	}
+ 	else if (lua_istable(L, 1))
  	{
+ 		int table = lua_gettop(L);
+ 		lua_pushnil(L);
+ 		while (lua_next(L, table) != 0)
+ 		{
+ 			const char *key = lua_tostring(L, -2);
+ 				  if(strcmp(key,"pos")==0){
+ 					pos=check_v3f(L, -1);
+ 			}else if(strcmp(key,"vel")==0){
+ 					vel=check_v3f(L, -1);
+ 			}else if(strcmp(key,"acc")==0){
+ 					acc=check_v3f(L, -1);
+ 			}else if(strcmp(key,"expirationtime")==0){
+ 					expirationtime=luaL_checknumber(L, -1);
+ 			}else if(strcmp(key,"size")==0){
+ 					size=luaL_checknumber(L, -1);
+ 			}else if(strcmp(key,"collisiondetection")==0){
+ 					collisiondetection=lua_toboolean(L, -1);
+ 			}else if(strcmp(key,"vertical")==0){
+ 					vertical=lua_toboolean(L, -1);
+ 			}else if(strcmp(key,"texture")==0){
+ 					texture=luaL_checkstring(L, -1);
+ 			}else if(strcmp(key,"playername")==0){
+ 					playername=luaL_checkstring(L, -1);
+ 			}
+ 			lua_pop(L, 1);
+ 		}
+ 	}
+ 	if (strcmp(playername, "")==0) // spawn for all players
+ 	{
+ 		server->spawnParticleAll(pos, vel, acc,
+ 			expirationtime, size, collisiondetection, vertical, texture);
+ 	}
+ 	else
+ 	{
++<<<<<<< HEAD:src/script/lua_api/l_particles.cpp
 +		const char *playername = luaL_checkstring(L, 8);
 +		getServer(L)->spawnParticle(playername,
 +			pos, vel, acc, expirationtime,
 +			size, collisiondetection, texture);
 +	}
 +	else // spawn for all players
 +	{
 +		getServer(L)->spawnParticleAll(pos, vel, acc,
 +			expirationtime, size, collisiondetection, texture);
++=======
+ 		server->spawnParticle(playername,
+ 			pos, vel, acc, expirationtime,
+ 			size, collisiondetection, vertical, texture);
++>>>>>>> khonkhortisan/vertical_particles:src/scriptapi_particles.cpp
  	}
  	return 1;
  }
@@@ -67,29 -115,101 +123,104 @@@
  // minexptime/maxexptime = num (seconds)
  // minsize/maxsize = num
  // collisiondetection = bool
+ // vertical = bool
  // texture = e.g."default_wood.png"
 -int l_add_particlespawner(lua_State *L)
 +int ModApiParticles::l_add_particlespawner(lua_State *L)
  {
 -	// Get server from registry
 -	Server *server = get_server(L);
  	// Get parameters
- 	u16 amount = luaL_checknumber(L, 1);
- 	float time = luaL_checknumber(L, 2);
- 	v3f minpos = check_v3f(L, 3);
- 	v3f maxpos = check_v3f(L, 4);
- 	v3f minvel = check_v3f(L, 5);
- 	v3f maxvel = check_v3f(L, 6);
- 	v3f minacc = check_v3f(L, 7);
- 	v3f maxacc = check_v3f(L, 8);
- 	float minexptime = luaL_checknumber(L, 9);
- 	float maxexptime = luaL_checknumber(L, 10);
- 	float minsize = luaL_checknumber(L, 11);
- 	float maxsize = luaL_checknumber(L, 12);
- 	bool collisiondetection = lua_toboolean(L, 13);
- 	std::string texture = luaL_checkstring(L, 14);
+ 	u16 amount = 1;
+ 	v3f minpos, maxpos, minvel, maxvel, minacc, maxacc;
+ 	    minpos= maxpos= minvel= maxvel= minacc= maxacc= v3f(0, 0, 0);
+ 	float time, minexptime, maxexptime, minsize, maxsize;
+ 	      time= minexptime= maxexptime= minsize= maxsize= 1;
+ 	bool collisiondetection, vertical;
+ 	     collisiondetection= vertical= false;
+ 	std::string texture = "";
+ 	const char *playername = "";
  
+ 	if (lua_gettop(L) > 1) //deprecated
+ 	{
+ 		amount = luaL_checknumber(L, 1);
+ 		time = luaL_checknumber(L, 2);
+ 		minpos = check_v3f(L, 3);
+ 		maxpos = check_v3f(L, 4);
+ 		minvel = check_v3f(L, 5);
+ 		maxvel = check_v3f(L, 6);
+ 		minacc = check_v3f(L, 7);
+ 		maxacc = check_v3f(L, 8);
+ 		minexptime = luaL_checknumber(L, 9);
+ 		maxexptime = luaL_checknumber(L, 10);
+ 		minsize = luaL_checknumber(L, 11);
+ 		maxsize = luaL_checknumber(L, 12);
+ 		collisiondetection = lua_toboolean(L, 13);
+ 		texture = luaL_checkstring(L, 14);
 -		if (lua_gettop(L) == 15) // only spawn for a single player
 +	if (lua_gettop(L) == 15) // only spawn for a single player
+ 			playername = luaL_checkstring(L, 15);
+ 	}
+ 	else if (lua_istable(L, 1))
+ 	{
+ 		int table = lua_gettop(L);
+ 		lua_pushnil(L);
+ 		while (lua_next(L, table) != 0)
+ 		{
+ 			const char *key = lua_tostring(L, -2);
+ 			      if(strcmp(key,"amount")==0){
+ 					amount=luaL_checknumber(L, -1);
+ 			}else if(strcmp(key,"time")==0){
+ 					time=luaL_checknumber(L, -1);
+ 			}else if(strcmp(key,"minpos")==0){
+ 					minpos=check_v3f(L, -1);
+ 			}else if(strcmp(key,"maxpos")==0){
+ 					maxpos=check_v3f(L, -1);
+ 			}else if(strcmp(key,"minvel")==0){
+ 					minvel=check_v3f(L, -1);
+ 			}else if(strcmp(key,"maxvel")==0){
+ 					maxvel=check_v3f(L, -1);
+ 			}else if(strcmp(key,"minacc")==0){
+ 					minacc=check_v3f(L, -1);
+ 			}else if(strcmp(key,"maxacc")==0){
+ 					maxacc=check_v3f(L, -1);
+ 			}else if(strcmp(key,"minexptime")==0){
+ 					minexptime=luaL_checknumber(L, -1);
+ 			}else if(strcmp(key,"maxexptime")==0){
+ 					maxexptime=luaL_checknumber(L, -1);
+ 			}else if(strcmp(key,"minsize")==0){
+ 					minsize=luaL_checknumber(L, -1);
+ 			}else if(strcmp(key,"maxsize")==0){
+ 					maxsize=luaL_checknumber(L, -1);
+ 			}else if(strcmp(key,"collisiondetection")==0){
+ 					collisiondetection=lua_toboolean(L, -1);
+ 			}else if(strcmp(key,"vertical")==0){
+ 					vertical=lua_toboolean(L, -1);
+ 			}else if(strcmp(key,"texture")==0){
+ 					texture=luaL_checkstring(L, -1);
+ 			}else if(strcmp(key,"playername")==0){
+ 					playername=luaL_checkstring(L, -1);
+ 			}
+ 			lua_pop(L, 1);
+ 		}
+ 	}
+ 	if (strcmp(playername, "")==0) //spawn for all players
+ 	{
+ 		u32 id = server->addParticleSpawnerAll(	amount, time,
+ 							minpos, maxpos,
+ 							minvel, maxvel,
+ 							minacc, maxacc,
+ 							minexptime, maxexptime,
+ 							minsize, maxsize,
+ 							collisiondetection,
+ 							vertical,
+ 							texture);
+ 		lua_pushnumber(L, id);
+ 	}
+ 	else
  	{
++<<<<<<< HEAD:src/script/lua_api/l_particles.cpp
 +		const char *playername = luaL_checkstring(L, 15);
 +		u32 id = getServer(L)->addParticleSpawner(playername,
++=======
+ 		u32 id = server->addParticleSpawner(playername,
++>>>>>>> khonkhortisan/vertical_particles:src/scriptapi_particles.cpp
  							amount, time,
  							minpos, maxpos,
  							minvel, maxvel,
@@@ -97,18 -217,7 +228,22 @@@
  							minexptime, maxexptime,
  							minsize, maxsize,
  							collisiondetection,
++<<<<<<< HEAD:src/script/lua_api/l_particles.cpp
 +							texture);
 +		lua_pushnumber(L, id);
 +	}
 +	else // spawn for all players
 +	{
 +		u32 id = getServer(L)->addParticleSpawnerAll(	amount, time,
 +							minpos, maxpos,
 +							minvel, maxvel,
 +							minacc, maxacc,
 +							minexptime, maxexptime,
 +							minsize, maxsize,
 +							collisiondetection,
++=======
+ 							vertical,
++>>>>>>> khonkhortisan/vertical_particles:src/scriptapi_particles.cpp
  							texture);
  		lua_pushnumber(L, id);
  	}




!!!!!!!!!!!!!!!!!
 Merge sfan5/leveldb to next failed:

# On branch next
# You have unmerged paths.
#   (fix conflicts and run "git commit")
#
# Changes to be committed:
#
#	modified:   src/CMakeLists.txt
#	modified:   src/cmake_config.h.in
#	modified:   src/config.h
#	new file:   src/database-dummy.cpp
#	new file:   src/database-dummy.h
#	new file:   src/database-leveldb.cpp
#	new file:   src/database-leveldb.h
#	new file:   src/database-sqlite3.cpp
#	new file:   src/database-sqlite3.h
#	new file:   src/database.cpp
#	new file:   src/database.h
#	new file:   src/leveldb/.gitignore
#	new file:   src/leveldb/AUTHORS
#	new file:   src/leveldb/CMakeLists.txt
#	new file:   src/leveldb/LICENSE
#	new file:   src/leveldb/NEWS
#	new file:   src/leveldb/README
#	new file:   src/leveldb/TODO
#	new file:   src/leveldb/build_detect_platform
#	new file:   src/leveldb/db/builder.cc
#	new file:   src/leveldb/db/builder.h
#	new file:   src/leveldb/db/c.cc
#	new file:   src/leveldb/db/c_test.c
#	new file:   src/leveldb/db/corruption_test.cc
#	new file:   src/leveldb/db/db_bench.cc
#	new file:   src/leveldb/db/db_impl.cc
#	new file:   src/leveldb/db/db_impl.h
#	new file:   src/leveldb/db/db_iter.cc
#	new file:   src/leveldb/db/db_iter.h
#	new file:   src/leveldb/db/db_test.cc
#	new file:   src/leveldb/db/dbformat.cc
#	new file:   src/leveldb/db/dbformat.h
#	new file:   src/leveldb/db/dbformat_test.cc
#	new file:   src/leveldb/db/filename.cc
#	new file:   src/leveldb/db/filename.h
#	new file:   src/leveldb/db/filename_test.cc
#	new file:   src/leveldb/db/log_format.h
#	new file:   src/leveldb/db/log_reader.cc
#	new file:   src/leveldb/db/log_reader.h
#	new file:   src/leveldb/db/log_test.cc
#	new file:   src/leveldb/db/log_writer.cc
#	new file:   src/leveldb/db/log_writer.h
#	new file:   src/leveldb/db/memtable.cc
#	new file:   src/leveldb/db/memtable.h
#	new file:   src/leveldb/db/repair.cc
#	new file:   src/leveldb/db/skiplist.h
#	new file:   src/leveldb/db/skiplist_test.cc
#	new file:   src/leveldb/db/snapshot.h
#	new file:   src/leveldb/db/table_cache.cc
#	new file:   src/leveldb/db/table_cache.h
#	new file:   src/leveldb/db/version_edit.cc
#	new file:   src/leveldb/db/version_edit.h
#	new file:   src/leveldb/db/version_edit_test.cc
#	new file:   src/leveldb/db/version_set.cc
#	new file:   src/leveldb/db/version_set.h
#	new file:   src/leveldb/db/version_set_test.cc
#	new file:   src/leveldb/db/write_batch.cc
#	new file:   src/leveldb/db/write_batch_internal.h
#	new file:   src/leveldb/db/write_batch_test.cc
#	new file:   src/leveldb/doc/bench/db_bench_sqlite3.cc
#	new file:   src/leveldb/doc/bench/db_bench_tree_db.cc
#	new file:   src/leveldb/doc/benchmark.html
#	new file:   src/leveldb/doc/doc.css
#	new file:   src/leveldb/doc/impl.html
#	new file:   src/leveldb/doc/index.html
#	new file:   src/leveldb/doc/log_format.txt
#	new file:   src/leveldb/doc/table_format.txt
#	new file:   src/leveldb/helpers/memenv/memenv.cc
#	new file:   src/leveldb/helpers/memenv/memenv.h
#	new file:   src/leveldb/helpers/memenv/memenv_test.cc
#	new file:   src/leveldb/include/leveldb/c.h
#	new file:   src/leveldb/include/leveldb/cache.h
#	new file:   src/leveldb/include/leveldb/comparator.h
#	new file:   src/leveldb/include/leveldb/db.h
#	new file:   src/leveldb/include/leveldb/env.h
#	new file:   src/leveldb/include/leveldb/filter_policy.h
#	new file:   src/leveldb/include/leveldb/iterator.h
#	new file:   src/leveldb/include/leveldb/options.h
#	new file:   src/leveldb/include/leveldb/slice.h
#	new file:   src/leveldb/include/leveldb/status.h
#	new file:   src/leveldb/include/leveldb/table.h
#	new file:   src/leveldb/include/leveldb/table_builder.h
#	new file:   src/leveldb/include/leveldb/write_batch.h
#	new file:   src/leveldb/port/README
#	new file:   src/leveldb/port/atomic_pointer.h
#	new file:   src/leveldb/port/port.h
#	new file:   src/leveldb/port/port_example.h
#	new file:   src/leveldb/port/port_posix.cc
#	new file:   src/leveldb/port/port_posix.h
#	new file:   src/leveldb/port/thread_annotations.h
#	new file:   src/leveldb/port/win/stdint.h
#	new file:   src/leveldb/table/block.cc
#	new file:   src/leveldb/table/block.h
#	new file:   src/leveldb/table/block_builder.cc
#	new file:   src/leveldb/table/block_builder.h
#	new file:   src/leveldb/table/filter_block.cc
#	new file:   src/leveldb/table/filter_block.h
#	new file:   src/leveldb/table/filter_block_test.cc
#	new file:   src/leveldb/table/format.cc
#	new file:   src/leveldb/table/format.h
#	new file:   src/leveldb/table/iterator.cc
#	new file:   src/leveldb/table/iterator_wrapper.h
#	new file:   src/leveldb/table/merger.cc
#	new file:   src/leveldb/table/merger.h
#	new file:   src/leveldb/table/table.cc
#	new file:   src/leveldb/table/table_builder.cc
#	new file:   src/leveldb/table/table_test.cc
#	new file:   src/leveldb/table/two_level_iterator.cc
#	new file:   src/leveldb/table/two_level_iterator.h
#	new file:   src/leveldb/util/arena.cc
#	new file:   src/leveldb/util/arena.h
#	new file:   src/leveldb/util/arena_test.cc
#	new file:   src/leveldb/util/bloom.cc
#	new file:   src/leveldb/util/bloom_test.cc
#	new file:   src/leveldb/util/cache.cc
#	new file:   src/leveldb/util/cache_test.cc
#	new file:   src/leveldb/util/coding.cc
#	new file:   src/leveldb/util/coding.h
#	new file:   src/leveldb/util/coding_test.cc
#	new file:   src/leveldb/util/comparator.cc
#	new file:   src/leveldb/util/crc32c.cc
#	new file:   src/leveldb/util/crc32c.h
#	new file:   src/leveldb/util/crc32c_test.cc
#	new file:   src/leveldb/util/env.cc
#	new file:   src/leveldb/util/env_posix.cc
#	new file:   src/leveldb/util/env_test.cc
#	new file:   src/leveldb/util/filter_policy.cc
#	new file:   src/leveldb/util/hash.cc
#	new file:   src/leveldb/util/hash.h
#	new file:   src/leveldb/util/histogram.cc
#	new file:   src/leveldb/util/histogram.h
#	new file:   src/leveldb/util/logging.cc
#	new file:   src/leveldb/util/logging.h
#	new file:   src/leveldb/util/mutexlock.h
#	new file:   src/leveldb/util/options.cc
#	new file:   src/leveldb/util/posix_logger.h
#	new file:   src/leveldb/util/random.h
#	new file:   src/leveldb/util/status.cc
#	new file:   src/leveldb/util/testharness.cc
#	new file:   src/leveldb/util/testharness.h
#	new file:   src/leveldb/util/testutil.cc
#	new file:   src/leveldb/util/testutil.h
#	modified:   src/main.cpp
#	modified:   src/map.h
#	modified:   src/server.h
#	modified:   src/subgame.cpp
#	modified:   src/util/string.h
#
# Unmerged paths:
#   (use "git add <file>..." to mark resolution)
#
#	both modified:      src/map.cpp
#
diff --cc src/map.cpp
index ef9cadd,e2191f9..0000000
--- a/src/map.cpp
+++ b/src/map.cpp
@@@ -3176,129 -3143,52 +3196,132 @@@ MapBlock * ServerMap::emergeBlock(v3s1
  	return NULL;
  }
  
 -s16 ServerMap::findGroundLevel(v2s16 p2d)
 -{
 -#if 0
 -	/*
 -		Uh, just do something random...
 +/**
 +		Get the ground level by searching for a non CONTENT_AIR node in a column from top to bottom
  	*/
 -	// Find existing map from top to down
 -	s16 max=63;
 -	s16 min=-64;
 -	v3s16 p(p2d.X, max, p2d.Y);
 -	for(; p.Y>min; p.Y--)
 -	{
 -		MapNode n = getNodeNoEx(p);
 -		if(n.getContent() != CONTENT_IGNORE)
 -			break;
 -	}
 -	if(p.Y == min)
 -		goto plan_b;
 -	// If this node is not air, go to plan b
 -	if(getNodeNoEx(p).getContent() != CONTENT_AIR)
 -		goto plan_b;
 -	// Search existing walkable and return it
 -	for(; p.Y>min; p.Y--)
 +s16 ServerMap::findGroundLevel(v2s16 p2d, bool cacheBlocks)
  	{
 -		MapNode n = getNodeNoEx(p);
 -		if(content_walkable(n.d) && n.getContent() != CONTENT_IGNORE)
 -			return p.Y;
 +	
 +	s16 level;
 +
 +	// The reference height is the original mapgen height
 +	s16 referenceHeight = m_emerge->getGroundLevelAtPoint(p2d);
 +	s16 maxSearchHeight =  63 + referenceHeight;
 +	s16 minSearchHeight = -63 + referenceHeight;
 +	v3s16 probePosition(p2d.X, maxSearchHeight, p2d.Y);
 +	v3s16 blockPosition = getNodeBlockPos(probePosition);
 +	v3s16 prevBlockPosition = blockPosition;
 +
 +	// Cache the block to be inspected.
 +	if(cacheBlocks) {
 +		emergeBlock(blockPosition, true);
  	}
  
 -	// Move to plan b
 -plan_b:
 -#endif
 +	// Probes the nodes in the given column
 +	for(; probePosition.Y > minSearchHeight; probePosition.Y--)
 +	{
 +		if(cacheBlocks) {
 +			// Calculate the block position of the given node
 +			blockPosition = getNodeBlockPos(probePosition); 
  
 -	/*
 -		Determine from map generator noise functions
 -	*/
 +			// If the node is in an different block, cache it
 +			if(blockPosition != prevBlockPosition) {
 +				emergeBlock(blockPosition, true);
 +				prevBlockPosition = blockPosition;
 +			}
 +		}
 +
 +		MapNode node = getNodeNoEx(probePosition);
 +		if(node.getContent() != CONTENT_IGNORE && node.getContent() != CONTENT_AIR)
 +			break;
 +	}
 +
 +	// Could not determine the ground. Use map generator noise functions.
 +	if(probePosition.Y == minSearchHeight) {
 +		level = referenceHeight; 
 +	}
 +	else {
 +		level = probePosition.Y;
 +	}
  
 -	s16 level = m_emerge->getGroundLevelAtPoint(p2d);
  	return level;
 +}
 +
++<<<<<<< HEAD
 +void ServerMap::createDatabase() {
 +	int e;
 +	assert(m_database);
 +	e = sqlite3_exec(m_database,
 +		"CREATE TABLE IF NOT EXISTS `blocks` ("
 +			"`pos` INT NOT NULL PRIMARY KEY,"
 +			"`data` BLOB"
 +		");"
 +	, NULL, NULL, NULL);
 +	if(e == SQLITE_ABORT)
 +		throw FileNotGoodException("Could not create database structure");
 +	else
 +		infostream<<"ServerMap: Database structure was created";
 +}
 +
 +void ServerMap::verifyDatabase() {
 +	if(m_database)
 +		return;
 +
 +	{
 +		std::string dbp = m_savedir + DIR_DELIM + "map.sqlite";
 +		bool needs_create = false;
 +		int d;
 +
 +		/*
 +			Open the database connection
 +		*/
 +
 +		createDirs(m_savedir);
 +
 +		if(!fs::PathExists(dbp))
 +			needs_create = true;
 +
 +		d = sqlite3_open_v2(dbp.c_str(), &m_database, SQLITE_OPEN_READWRITE | SQLITE_OPEN_CREATE, NULL);
 +		if(d != SQLITE_OK) {
 +			infostream<<"WARNING: Database failed to open: "<<sqlite3_errmsg(m_database)<<std::endl;
 +			throw FileNotGoodException("Cannot open database file");
 +		}
  
 -	//double level = base_rock_level_2d(m_seed, p2d) + AVERAGE_MUD_AMOUNT;
 -	//return (s16)level;
 +		if(needs_create)
 +			createDatabase();
 +
 +		d = sqlite3_exec(m_database, (std::string("PRAGMA synchronous = ") + g_settings->get("sqlite_synchronous")).c_str(), NULL, NULL, NULL);
 +		if(d != SQLITE_OK) {
 +			infostream<<"WARNING: Database pragma set failed: "<<sqlite3_errmsg(m_database)<<std::endl;
 +			throw FileNotGoodException("Cannot set pragma");
 +		}
 +
 +		d = sqlite3_prepare(m_database, "SELECT `data` FROM `blocks` WHERE `pos`=? LIMIT 1", -1, &m_database_read, NULL);
 +		if(d != SQLITE_OK) {
 +			infostream<<"WARNING: Database read statment failed to prepare: "<<sqlite3_errmsg(m_database)<<std::endl;
 +			throw FileNotGoodException("Cannot prepare read statement");
 +		}
 +
 +		d = sqlite3_prepare(m_database, "REPLACE INTO `blocks` VALUES(?, ?)", -1, &m_database_write, NULL);
 +		if(d != SQLITE_OK) {
 +			infostream<<"WARNING: Database write statment failed to prepare: "<<sqlite3_errmsg(m_database)<<std::endl;
 +			throw FileNotGoodException("Cannot prepare write statement");
 +		}
 +
 +		d = sqlite3_prepare(m_database, "SELECT `pos` FROM `blocks`", -1, &m_database_list, NULL);
 +		if(d != SQLITE_OK) {
 +			infostream<<"WARNING: Database list statment failed to prepare: "<<sqlite3_errmsg(m_database)<<std::endl;
 +			throw FileNotGoodException("Cannot prepare read statement");
 +		}
 +
 +		infostream<<"ServerMap: Database opened"<<std::endl;
 +	}
  }
  
++=======
++>>>>>>> sfan5/leveldb
  bool ServerMap::loadFromFolders() {
- 	if(!m_database && !fs::PathExists(m_savedir + DIR_DELIM + "map.sqlite"))
+ 	if(!dbase->Initialized() && !fs::PathExists(m_savedir + DIR_DELIM + "map.sqlite")) // ?
  		return true;
  	return false;
  }
@@@ -4044,38 -3820,11 +3953,11 @@@ MapBlock* ServerMap::loadBlock(v3s16 bl
  
  	v2s16 p2d(blockpos.X, blockpos.Z);
  
- 	if(!loadFromFolders()) {
- 		verifyDatabase();
- 
- 		if(sqlite3_bind_int64(m_database_read, 1, getBlockAsInteger(blockpos)) != SQLITE_OK)
- 			infostream<<"WARNING: Could not bind block position for load: "
- 				<<sqlite3_errmsg(m_database)<<std::endl;
- 		if(sqlite3_step(m_database_read) == SQLITE_ROW) {
- 			/*
- 				Make sure sector is loaded
- 			*/
- 			MapSector *sector = createSector(p2d);
- 
- 			/*
- 				Load block
- 			*/
- 			const char * data = (const char *)sqlite3_column_blob(m_database_read, 0);
- 			size_t len = sqlite3_column_bytes(m_database_read, 0);
- 
- 			std::string datastr(data, len);
- 
- 			loadBlock(&datastr, blockpos, sector, false);
- 
- 			sqlite3_step(m_database_read);
- 			// We should never get more than 1 row, so ok to reset
- 			sqlite3_reset(m_database_read);
- 
- 			return getBlockNoCreateNoEx(blockpos);
- 		}
- 		sqlite3_reset(m_database_read);
+ 	MapBlock *ret;
  
+ 	ret = dbase->loadBlock(blockpos);
+ 	if (ret) return (ret);
 -	// Not found in database, try the files
 +		// Not found in database, try the files
- 	}
  
  	// The directory layout we're going to load from.
  	//  1 - original sectors/xxxxzzzz/





!!!!!!!!!!!!!!!!!
 Merge sapier/avoid_facedir_if_not_moving to next failed:

# On branch next
# You have unmerged paths.
#   (fix conflicts and run "git commit")
#
# Unmerged paths:
#   (use "git add <file>..." to mark resolution)
#
#	both modified:      src/content_cao.cpp
#	both modified:      src/content_sao.cpp
#
no changes added to commit (use "git add" and/or "git commit -a")
diff --cc src/content_cao.cpp
index e97e3a1,fb4bc95..0000000
--- a/src/content_cao.cpp
+++ b/src/content_cao.cpp
@@@ -1211,9 -1211,9 +1211,15 @@@ public
  			updateNodePos();
  		}
  
++<<<<<<< HEAD
 +		if (getParent() == NULL && m_prop.automatic_face_movement_dir &&
 +				(fabs(m_velocity.Z) > 0.001 || fabs(m_velocity.X) > 0.001)){
 +			m_yaw = atan2(m_velocity.Z,m_velocity.X) * 180 / M_PI + m_prop.automatic_face_movement_dir_offset;
++=======
+ 		if ((getParent() == NULL && m_prop.automatic_face_movement_dir) &&
+ 			((m_velocity.Z != 0) || (m_velocity.X != 0))){
+ 			m_yaw = atan2(m_velocity.Z,m_velocity.X) * 180 / M_PI;
++>>>>>>> sapier/avoid_facedir_if_not_moving
  			updateNodePos();
  		}
  	}
diff --cc src/content_sao.cpp
index 85ab8d3,92cabfb..0000000
--- a/src/content_sao.cpp
+++ b/src/content_sao.cpp
@@@ -527,9 -527,9 +527,14 @@@ void LuaEntitySAO::step(float dtime, bo
  			m_velocity += dtime * m_acceleration;
  		}
  
 -		if( (m_prop.automatic_face_movement_dir) &&
 +		if((m_prop.automatic_face_movement_dir) &&
++<<<<<<< HEAD
 +				(fabs(m_velocity.Z) > 0.001 || fabs(m_velocity.X) > 0.001)){
 +			m_yaw = atan2(m_velocity.Z,m_velocity.X) * 180 / M_PI + m_prop.automatic_face_movement_dir_offset;
++=======
+ 			((m_velocity.Z != 0) || (m_velocity.X != 0))){
+ 			m_yaw = atan2(m_velocity.Z,m_velocity.X) * 180 / M_PI;
++>>>>>>> sapier/avoid_facedir_if_not_moving
  		}
  	}
  




!!!!!!!!!!!!!!!!!
 Merge sapier/modmgr_fixes to next failed:

# On branch next
# You have unmerged paths.
#   (fix conflicts and run "git commit")
#
# Unmerged paths:
#   (use "git add <file>..." to mark resolution)
#
#	both modified:      builtin/misc_helpers.lua
#
no changes added to commit (use "git add" and/or "git commit -a")
diff --cc builtin/misc_helpers.lua
index 66b5432,0110062..0000000
--- a/builtin/misc_helpers.lua
+++ b/builtin/misc_helpers.lua
@@@ -261,192 -261,6 +261,195 @@@ function tbl.splittext(text,charlimit
  	return retval
  end
  
++<<<<<<< HEAD
 +--------------------------------------------------------------------------------
 +
 +if minetest then
 +	local dirs1 = { 9, 18, 7, 12 }
 +	local dirs2 = { 20, 23, 22, 21 }
 +
 +	function minetest.rotate_and_place(itemstack, placer, pointed_thing, infinitestacks, orient_flags)
 +		orient_flags = orient_flags or {}
 +
 +		local node = minetest.get_node(pointed_thing.under)
 +		if not minetest.registered_nodes[node.name]
 +		   or not minetest.registered_nodes[node.name].on_rightclick then
 +
 +			local above = pointed_thing.above
 +			local under = pointed_thing.under
 +			local pitch = placer:get_look_pitch()
 +			local pname = minetest.get_node(under).name
 +			local node = minetest.get_node(above)
 +			local fdir = minetest.dir_to_facedir(placer:get_look_dir())
 +			local wield_name = itemstack:get_name()
 +			local reg_node = minetest.registered_nodes[pname]
 +
 +			if not reg_node or not reg_node.on_rightclick then
 +
 +				local iswall = (above.x ~= under.x) or (above.z ~= under.z)
 +				local isceiling = (above.x == under.x) and (above.z == under.z)
 +								  and (pitch > 0)
 +				local pos1 = above
 +
 +				if reg_node and reg_node.buildable_to then
 +					pos1 = under
 +					iswall = false
 +				end
 +
 +				reg_node = minetest.registered_nodes[minetest.get_node(pos1).name]
 +				if not reg_node or not reg_node.buildable_to then
 +					return
 +				end
 +
 +				if orient_flags.force_floor then
 +					iswall = false
 +					isceiling = false
 +				elseif orient_flags.force_ceiling then 
 +					iswall = false
 +					isceiling = true
 +				elseif orient_flags.force_wall then					
 +					iswall = true
 +					isceiling = false
 +				elseif orient_flags.invert_wall then
 +					iswall = not iswall
 +				end
 +
 +				if iswall then
 +					minetest.add_node(pos1, {name = wield_name, param2 = dirs1[fdir+1] })
 +				elseif isceiling then
 +					if orient_flags.force_facedir then
 +						minetest.add_node(pos1, {name = wield_name, param2 = 20 })
 +					else
 +						minetest.add_node(pos1, {name = wield_name, param2 = dirs2[fdir+1] })
 +					end
 +				else -- place right side up
 +					if orient_flags.force_facedir then
 +						minetest.add_node(pos1, {name = wield_name, param2 = 0 })
 +					else
 +						minetest.add_node(pos1, {name = wield_name, param2 = fdir })
 +					end
 +				end
 +
 +				if not infinitestacks then
 +					itemstack:take_item()
 +					return itemstack
 +				end
 +			end
 +		else
 +			minetest.registered_nodes[node.name].on_rightclick(pointed_thing.under, node, placer, itemstack)
 +		end
 +	end
 +
 +
 +--------------------------------------------------------------------------------
 +--Wrapper for rotate_and_place() to check for sneak and assume Creative mode
 +--implies infinite stacks when performing a 6d rotation.
 +--------------------------------------------------------------------------------
 +
 +
 +	minetest.rotate_node = function(itemstack, placer, pointed_thing)
 +		minetest.rotate_and_place(itemstack, placer, pointed_thing,
 +		minetest.setting_getbool("creative_mode"), 
 +		{invert_wall = placer:get_player_control().sneak})
 +		return itemstack
 +	end
 +end
 +
 +--------------------------------------------------------------------------------
 +
 +if minetest then
 +	local dirs1 = { 9, 18, 7, 12 }
 +	local dirs2 = { 20, 23, 22, 21 }
 +
 +	function minetest.rotate_and_place(itemstack, placer, pointed_thing, infinitestacks, orient_flags)
 +		orient_flags = orient_flags or {}
 +
 +		local node = minetest.get_node(pointed_thing.under)
 +		if not minetest.registered_nodes[node.name]
 +		   or not minetest.registered_nodes[node.name].on_rightclick then
 +
 +			local above = pointed_thing.above
 +			local under = pointed_thing.under
 +			local pitch = placer:get_look_pitch()
 +			local pname = minetest.get_node(under).name
 +			local node = minetest.get_node(above)
 +			local fdir = minetest.dir_to_facedir(placer:get_look_dir())
 +			local wield_name = itemstack:get_name()
 +			local reg_node = minetest.registered_nodes[pname]
 +
 +			if not reg_node or not reg_node.on_rightclick then
 +
 +				local iswall = (above.x ~= under.x) or (above.z ~= under.z)
 +				local isceiling = (above.x == under.x) and (above.z == under.z)
 +								  and (pitch > 0)
 +				local pos1 = above
 +
 +				if reg_node and reg_node.buildable_to then
 +					pos1 = under
 +					iswall = false
 +				end
 +
 +				reg_node = minetest.registered_nodes[minetest.get_node(pos1).name]
 +				if not reg_node or not reg_node.buildable_to then
 +					return
 +				end
 +
 +				if orient_flags.force_floor then
 +					iswall = false
 +					isceiling = false
 +				elseif orient_flags.force_ceiling then 
 +					iswall = false
 +					isceiling = true
 +				elseif orient_flags.force_wall then					
 +					iswall = true
 +					isceiling = false
 +				elseif orient_flags.invert_wall then
 +					iswall = not iswall
 +				end
 +
 +				if iswall then
 +					minetest.add_node(pos1, {name = wield_name, param2 = dirs1[fdir+1] })
 +				elseif isceiling then
 +					if orient_flags.force_facedir then
 +						minetest.add_node(pos1, {name = wield_name, param2 = 20 })
 +					else
 +						minetest.add_node(pos1, {name = wield_name, param2 = dirs2[fdir+1] })
 +					end
 +				else -- place right side up
 +					if orient_flags.force_facedir then
 +						minetest.add_node(pos1, {name = wield_name, param2 = 0 })
 +					else
 +						minetest.add_node(pos1, {name = wield_name, param2 = fdir })
 +					end
 +				end
 +
 +				if not infinitestacks then
 +					itemstack:take_item()
 +					return itemstack
 +				end
 +			end
 +		else
 +			minetest.registered_nodes[node.name].on_rightclick(pointed_thing.under, node, placer, itemstack)
 +		end
 +	end
 +
 +
 +--------------------------------------------------------------------------------
 +--Wrapper for rotate_and_place() to check for sneak and assume Creative mode
 +--implies infinite stacks when performing a 6d rotation.
 +--------------------------------------------------------------------------------
 +
 +
 +	minetest.rotate_node = function(itemstack, placer, pointed_thing)
 +		minetest.rotate_and_place(itemstack, placer, pointed_thing,
 +		minetest.setting_getbool("creative_mode"), 
 +		{invert_wall = placer:get_player_control().sneak})
 +		return itemstack
 +	end
 +end
 +
++=======
++>>>>>>> sapier/modmgr_fixes
  --------------------------------------------------------------------------------
  -- mainmenu only functions
  --------------------------------------------------------------------------------




!!!!!!!!!!!!!!!!!
 Merge Novatux/forceload to next failed:

# On branch next
# You have unmerged paths.
#   (fix conflicts and run "git commit")
#
# Changes to be committed:
#
#	modified:   doc/lua_api.txt
#	modified:   minetest.conf.example
#	modified:   src/defaultsettings.cpp
#	modified:   src/environment.cpp
#
# Unmerged paths:
#   (use "git add <file>..." to mark resolution)
#
#	both modified:      src/object_properties.cpp
#	both modified:      src/object_properties.h
#
diff --cc src/object_properties.cpp
index f560f59,162cc67..0000000
--- a/src/object_properties.cpp
+++ b/src/object_properties.cpp
@@@ -42,7 -42,7 +42,11 @@@ ObjectProperties::ObjectProperties()
  	automatic_rotate(0),
  	stepheight(0),
  	automatic_face_movement_dir(false),
++<<<<<<< HEAD
 +	automatic_face_movement_dir_offset(0.0)
++=======
+ 	force_load(false)
++>>>>>>> Novatux/forceload
  {
  	textures.push_back("unknown_object.png");
  	colors.push_back(video::SColor(255,255,255,255));
@@@ -105,7 -106,7 +110,11 @@@ void ObjectProperties::serialize(std::o
  	writeU8(os, collideWithObjects);
  	writeF1000(os,stepheight);
  	writeU8(os, automatic_face_movement_dir);
++<<<<<<< HEAD
 +	writeF1000(os, automatic_face_movement_dir_offset);
++=======
+ 	writeU8(os, force_load);
++>>>>>>> Novatux/forceload
  	// Add stuff only at the bottom.
  	// Never remove anything, because we don't want new versions of this
  }
@@@ -141,7 -142,7 +150,11 @@@ void ObjectProperties::deSerialize(std:
  			collideWithObjects = readU8(is);
  			stepheight = readF1000(is);
  			automatic_face_movement_dir = readU8(is);
++<<<<<<< HEAD
 +			automatic_face_movement_dir_offset = readF1000(is);
++=======
+ 			force_load = readU8(is);
++>>>>>>> Novatux/forceload
  		}catch(SerializationError &e){}
  	}
  	else
diff --cc src/object_properties.h
index 4b7f9a5,dbcbba5..0000000
--- a/src/object_properties.h
+++ b/src/object_properties.h
@@@ -46,7 -46,7 +46,11 @@@ struct ObjectPropertie
  	float automatic_rotate;
  	f32 stepheight;
  	bool automatic_face_movement_dir;
++<<<<<<< HEAD
 +	f32 automatic_face_movement_dir_offset;
++=======
+ 	bool force_load;
++>>>>>>> Novatux/forceload
  
  
  	ObjectProperties();




!!!!!!!!!!!!!!!!!
 Merge sapier/fix_crash_on_lua_exception to next failed:

# On branch next
# You have unmerged paths.
#   (fix conflicts and run "git commit")
#
# Unmerged paths:
#   (use "git add <file>..." to mark resolution)
#
#	both modified:      src/guiFormSpecMenu.cpp
#
no changes added to commit (use "git add" and/or "git commit -a")
diff --cc src/guiFormSpecMenu.cpp
index eecd2c1,01630e0..0000000
--- a/src/guiFormSpecMenu.cpp
+++ b/src/guiFormSpecMenu.cpp
@@@ -1657,7 -1597,21 +1657,25 @@@ void GUIFormSpecMenu::regenerateGui(v2u
  			Environment->addButton(mydata.rect, this, 257, text);
  			delete[] text;
  		}
++<<<<<<< HEAD
 +
++=======
+ 		changeCtype("C");
+ 	}
+ 	// Add tooltip
+ 	{
+ 		// Note: parent != this so that the tooltip isn't clipped by the menu rectangle
+ 		m_tooltip_element = Environment->addStaticText(L"",core::rect<s32>(0,0,110,18));
+ 		m_tooltip_element->enableOverrideColor(true);
+ 		m_tooltip_element->setBackgroundColor(video::SColor(255,110,130,60));
+ 		m_tooltip_element->setDrawBackground(true);
+ 		m_tooltip_element->setDrawBorder(true);
+ 		m_tooltip_element->setOverrideColor(video::SColor(255,255,255,255));
+ 		m_tooltip_element->setTextAlignment(gui::EGUIA_CENTER, gui::EGUIA_CENTER);
+ 		m_tooltip_element->setWordWrap(false);
+ 		//we're not parent so no autograb for this one!
+ 		m_tooltip_element->grab();
++>>>>>>> sapier/fix_crash_on_lua_exception
  	}
  
  	//set initial focus if parser didn't set it




!!!!!!!!!!!!!!!!!
 Merge ShadowNinja/protection_support to next failed:

# On branch next
# You have unmerged paths.
#   (fix conflicts and run "git commit")
#
# Unmerged paths:
#   (use "git add <file>..." to mark resolution)
#
#	both modified:      builtin/misc_register.lua
#	both modified:      doc/lua_api.txt
#
no changes added to commit (use "git add" and/or "git commit -a")
diff --cc builtin/misc_register.lua
index 1e081e6,3002d5e..0000000
--- a/builtin/misc_register.lua
+++ b/builtin/misc_register.lua
@@@ -342,18 -327,5 +342,21 @@@ minetest.registered_on_joinplayers, min
  minetest.registered_on_leaveplayers, minetest.register_on_leaveplayer = make_registration()
  minetest.registered_on_player_receive_fields, minetest.register_on_player_receive_fields = make_registration_reverse()
  minetest.registered_on_cheats, minetest.register_on_cheat = make_registration()
++<<<<<<< HEAD
 +minetest.registered_on_crafts, minetest.register_on_craft = make_registration()
 +minetest.registered_craft_predicts, minetest.register_craft_predict = make_registration()
++=======
++>>>>>>> ShadowNinja/protection_support
  minetest.registered_on_protection_violation, minetest.register_on_protection_violation = make_registration()
  
 +minetest.register_on_joinplayer(function(player)
 +	if minetest.is_singleplayer() then return end
 +	local player_name =  player:get_player_name()
 +	minetest.chat_send_all("*** " .. player_name .. " joined the game.")
 +end)
 +
 +minetest.register_on_dieplayer(function(player)
 +	local player_name =  player:get_player_name()
 +	if minetest.is_singleplayer() then player_name = "You" end
 +	minetest.chat_send_all(player_name .. " died.")
 +end)
diff --cc doc/lua_api.txt
index 5e9adff,7b53c19..0000000
--- a/doc/lua_api.txt
+++ b/doc/lua_api.txt
@@@ -1203,15 -1151,6 +1203,18 @@@ minetest.register_on_player_receive_fie
  minetest.register_on_mapgen_init(func(MapgenParams))
  ^ Called just before the map generator is initialized but before the environment is initialized
  ^ MapgenParams consists of a table with the fields mgname, seed, water_level, and flags
++<<<<<<< HEAD
 +minetest.register_on_craft(func(itemstack, player, old_craft_grid, craft_inv))
 +^ Called when player crafts something
 +^ itemstack is the output
 +^ old_craft_grid contains the recipe (Note: the one in the inventory is cleared)
 +^ craft_inv is the inventory with the crafting grid
 +^ Return either an ItemStack, to replace the output, or nil, to not modify it
 +minetest.register_craft_predict(func(itemstack, player, old_craft_grid, craft_inv))
 +^ The same as before, except that it is called before the player crafts, to make
 +^ craft prediction, and it should not change anything.
++=======
++>>>>>>> ShadowNinja/protection_support
  minetest.register_on_protection_violation(func(pos, name))
  ^ Called by builtin and mods when a player violates protection at a position
    (eg, digs a node or punches a protected entity).
@@@ -1564,28 -1498,6 +1567,31 @@@ minetest.is_protected(pos, name) -> boo
  minetest.record_protection_violation(pos, name)
  ^ This function calls functions registered with
    minetest.register_on_protection_violation.
++<<<<<<< HEAD
 +minetest.rotate_and_place(itemstack, placer, pointed_thing, infinitestacks, orient_flags)
 +^ Attempt to predict the desired orientation of the facedir-capable node
 +  defined by itemstack, and place it accordingly (on-wall, on the floor, or
 +  hanging from the ceiling). Stacks are handled normally if the infinitestacks
 +  field is false or omitted (else, the itemstack is not changed). orient_flags
 +  is an optional table containing extra tweaks to the placement code:
 +  invert_wall:		if true, place wall-orientation on the ground and ground-
 +					orientation on the wall.
 +  force_wall:		if true, always place the node in wall orientation.
 +  force_ceiling:	if true, always place on the ceiling.
 +  force_floor:		if true, always place the node on the floor.
 +
 +  The above four options are mutually-exclusive; the last in the list takes
 +  precedence over the first.
 +
 +  force_facedir:	if true, forcably reset the facedir to north when placing on
 +					the floor or ceiling
 +
 +minetest.rotate_node(itemstack, placer, pointed_thing)
 +^ calls rotate_and_place() with infinitestacks set according to the state of
 +  the creative mode setting, and checks for "sneak" to set the invert_wall
 +  parameter.
++=======
++>>>>>>> ShadowNinja/protection_support
  
  Global objects:
  minetest.env - EnvRef of the server environment and world.




!!!!!!!!!!!!!!!!!
 Merge Jeija/rotateto to next failed:

# On branch next
# You have unmerged paths.
#   (fix conflicts and run "git commit")
#
# Changes to be committed:
#
#	modified:   doc/lua_api.txt
#	modified:   src/content_sao.h
#	modified:   src/genericobject.cpp
#	modified:   src/genericobject.h
#	modified:   src/script/lua_api/l_object.cpp
#	modified:   src/script/lua_api/l_object.h
#
# Unmerged paths:
#   (use "git add <file>..." to mark resolution)
#
#	both modified:      src/content_cao.cpp
#	both modified:      src/content_sao.cpp
#
diff --cc src/content_cao.cpp
index eda0d54,89b8dc5..0000000
--- a/src/content_cao.cpp
+++ b/src/content_cao.cpp
@@@ -1213,35 -1215,28 +1222,60 @@@ public
  			m_yaw += dtime * m_prop.automatic_rotate * 180 / M_PI;
  			updateNodePos();
  		}
++<<<<<<< HEAD
 +
 +		if (getParent() == NULL && m_prop.automatic_face_movement_dir &&
 +				(fabs(m_velocity.Z) > 0.001 || fabs(m_velocity.X) > 0.001)){
 +			m_yaw = atan2(m_velocity.Z,m_velocity.X) * 180 / M_PI + m_prop.automatic_face_movement_dir_offset;
 +			updateNodePos();
 +		}
 +		updateAnimationSpeed();
 +	}
 +
 +	void updateAnimationSpeed()
 +	{
 +		if(m_animated_meshnode == NULL)
 +			return;
 +
 +		if (m_anim_base_velocity > 0)
 +		{
 +			//calculate current velocity
 +			float current_velocity = XZScalar(m_velocity.X,m_velocity.Z);
 +
 +			if (fabs(m_anim_last_updated_velocity-current_velocity) > 0.05)
 +			{
 +				//calculate new animation speed
 +				float new_speed = current_velocity/m_anim_base_velocity * 15;
 +
 +				m_animated_meshnode->setAnimationSpeed(new_speed);
 +
 +				m_anim_last_updated_velocity = current_velocity;
 +			}
 +		}
++=======
+ 		// Automatic rotation overrides continues rotation
+ 		if(getParent() == NULL && m_rotate_yaw_speed != 0 && fabs(m_prop.automatic_rotate) < 0.001){
+ 			float target_yaw = m_yaw + dtime * m_rotate_yaw_speed;
+ 			if ((m_rotate_yaw_speed > 0 && m_yaw < m_dest_yaw
+ 				&& target_yaw > m_dest_yaw) || (m_rotate_yaw_speed < 0 
+ 				&& m_yaw > m_dest_yaw && target_yaw < m_dest_yaw)
+ 				|| (m_rotate_yaw_speed > 0 && m_yaw < m_dest_yaw + 360
+ 				&& target_yaw > m_dest_yaw + 360))
+ 			{
+ 				// destination yaw is reached
+ 				m_yaw = m_dest_yaw;
+ 				m_rotate_yaw_speed = 0;
+ 			}
+ 			else
+ 			{
+ 				m_yaw = target_yaw;
+ 			}
+ 			updateNodePos();
+ 		}
+ 
+ 		if (m_yaw > 360) m_yaw -= 360;
+ 		if (m_yaw < 0  ) m_yaw += 360;
++>>>>>>> Jeija/rotateto
  	}
  
  	void updateTexturePos()
diff --cc src/content_sao.cpp
index d38894b,4bd6a23..0000000
--- a/src/content_sao.cpp
+++ b/src/content_sao.cpp
@@@ -528,14 -515,33 +530,39 @@@ void LuaEntitySAO::step(float dtime, bo
  			m_velocity += dtime * m_acceleration;
  		}
  
++<<<<<<< HEAD
 +		if((m_prop.automatic_face_movement_dir) &&
 +				(fabs(m_velocity.Z) > 0.001 || fabs(m_velocity.X) > 0.001)){
 +			m_yaw = atan2(m_velocity.Z,m_velocity.X) * 180 / M_PI + m_prop.automatic_face_movement_dir_offset;
 +		}
++=======
+ 		// Automatic rotation overrides continues rotation
+ 		// Perform this also on the server to make getyaw() work
+ 		if(fabs(m_prop.automatic_rotate) < 0.001){
+ 			float target_yaw = m_yaw + dtime * m_rotate_yaw_speed;
+ 			if ((m_rotate_yaw_speed > 0 && m_yaw < m_dest_yaw
+ 				&& target_yaw > m_dest_yaw) || (m_rotate_yaw_speed < 0 
+ 				&& m_yaw > m_dest_yaw && target_yaw < m_dest_yaw)
+ 				|| (m_rotate_yaw_speed > 0 && m_yaw < m_dest_yaw + 360
+ 				&& target_yaw > m_dest_yaw + 360))
+ 			{
+ 				// destination yaw is reached
+ 				m_yaw = m_dest_yaw;
+ 				m_rotate_yaw_speed = 0;
 -			}
++>>>>>>> Jeija/rotateto
++	}
+ 			else
+ 			{
+ 				m_yaw = target_yaw;
+ 			}
+ 		}
  	}
  
+ 	if (m_yaw > 360) m_yaw -= 360;
+ 	if (m_yaw < 0  ) m_yaw += 360;
+ 
  	if(m_registered){
 -		lua_State *L = m_env->getLua();
 -		scriptapi_luaentity_step(L, m_id, dtime);
 +		m_env->getScriptIface()->luaentity_Step(m_id, dtime);
  	}
  
  	if(send_recommended == false)




!!!!!!!!!!!!!!!!!
 Merge Sokomine/master to next failed:

# On branch next
# You have unmerged paths.
#   (fix conflicts and run "git commit")
#
# Unmerged paths:
#   (use "git add <file>..." to mark resolution)
#
#	both modified:      doc/lua_api.txt
#
no changes added to commit (use "git add" and/or "git commit -a")
diff --cc doc/lua_api.txt
index 303a514,5c52606..0000000
--- a/doc/lua_api.txt
+++ b/doc/lua_api.txt
@@@ -2121,11 -1998,9 +2121,17 @@@ Node definition (register_node
      <all fields allowed in item definitions>,
  
      drawtype = "normal", -- See "Node drawtypes"
++<<<<<<< HEAD
 +    visual_scale = 1.0,
 +    ^ Supported for drawtypes "plantlike", "signlike", "torchlike".
 +    ^ For plantlike, the image will start at the bottom of the node; for the
 +    ^ other drawtypes, the image will be centered on the node.
 +    ^ Note that positioning for "torchlike" may still change.
++=======
+     visual_scale = 1.0, -- supported for drawtypes "plantlike", "signlike", "torchlike"
+                         -- for plantlike, the image will start at the bottom of the node; for the other drawtypes, the image
+                         -- will be centered on the node
++>>>>>>> Sokomine/master
      tiles = {tile definition 1, def2, def3, def4, def5, def6},
      ^ Textures of node; +Y, -Y, +X, -X, +Z, -Z (old field name: tile_images)
      ^ List can be shortened to needed length




!!!!!!!!!!!!!!!!!
 Merge RealBadAngel/master to next failed:

# On branch next
# You have unmerged paths.
#   (fix conflicts and run "git commit")
#
# Changes to be committed:
#
#	modified:   src/sky.cpp
#	new file:   textures/base/pack/moon.png
#	new file:   textures/base/pack/moon_tonemap.png
#	new file:   textures/base/pack/sun.png
#	new file:   textures/base/pack/sun_tonemap.png
#
# Unmerged paths:
#   (use "git add <file>..." to mark resolution)
#
#	both modified:      src/sky.h
#
diff --cc src/sky.h
index 35c86db,6b5ae8b..0000000
--- a/src/sky.h
+++ b/src/sky.h
@@@ -114,7 -78,8 +114,12 @@@ private
  	v3f m_stars[SKY_STAR_COUNT];
  	u16 m_star_indices[SKY_STAR_COUNT*4];
  	video::S3DVertex m_star_vertices[SKY_STAR_COUNT*4];
++<<<<<<< HEAD
 +	LocalPlayer* m_player;
++=======
+ 	video::ITexture* m_sun_tonemap;
+ 	video::ITexture* m_moon_tonemap;
++>>>>>>> RealBadAngel/master
  };
  
  #endif




!!!!!!!!!!!!!!!!!
 Merge ShadowNinja/pcall_errfunc to next failed:

# On branch next
# You have unmerged paths.
#   (fix conflicts and run "git commit")
#
# Changes to be committed:
#
#	modified:   src/script/common/c_content.cpp
#	modified:   src/script/common/c_internal.cpp
#	modified:   src/script/common/c_internal.h
#	modified:   src/script/common/c_types.cpp
#	modified:   src/script/common/c_types.h
#	modified:   src/script/cpp_api/s_base.cpp
#	modified:   src/script/cpp_api/s_base.h
#	modified:   src/script/cpp_api/s_entity.cpp
#	modified:   src/script/cpp_api/s_inventory.cpp
#	modified:   src/script/cpp_api/s_item.cpp
#	modified:   src/script/cpp_api/s_mainmenu.cpp
#	modified:   src/script/cpp_api/s_node.cpp
#	modified:   src/script/cpp_api/s_nodemeta.cpp
#	modified:   src/script/cpp_api/s_server.cpp
#	modified:   src/script/lua_api/l_base.h
#	modified:   src/script/lua_api/l_craft.cpp
#	modified:   src/script/lua_api/l_item.cpp
#	modified:   src/script/lua_api/l_noise.cpp
#	modified:   src/script/lua_api/l_rollback.cpp
#	modified:   src/script/lua_api/l_server.cpp
#
# Unmerged paths:
#   (use "git add <file>..." to mark resolution)
#
#	both modified:      src/script/lua_api/l_env.cpp
#
diff --cc src/script/lua_api/l_env.cpp
index bd8e500,9bed23d..0000000
--- a/src/script/lua_api/l_env.cpp
+++ b/src/script/lua_api/l_env.cpp
@@@ -73,9 -78,9 +78,15 @@@ void LuaABM::trigger(ServerEnvironment 
  	pushnode(L, n, env->getGameDef()->ndef());
  	lua_pushnumber(L, active_object_count);
  	lua_pushnumber(L, active_object_count_wider);
++<<<<<<< HEAD
 +	pushnode(L, neighbor, env->getGameDef()->ndef());
 +	if(lua_pcall(L, 5, 0, 0))
 +		script_error(L, "error: %s", lua_tostring(L, -1));
++=======
+ 	if(lua_pcall(L, 4, 0, errorhandler))
+ 		script_error(L);
+ 	lua_pop(L, 1); // Pop error handler
++>>>>>>> ShadowNinja/pcall_errfunc
  }
  
  // Exported functions

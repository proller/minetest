



!!!!!!!!!!!!!!!!!
 Merge sapier/avoid_facedir_if_not_moving to next failed:

diff --git a/.gitmodules b/.gitmodules
deleted file mode 100644
index e9aabdb..0000000
--- a/.gitmodules
+++ /dev/null
@@ -1,3 +0,0 @@
-[submodule "games/minetest_game"]
-	path = games/minetest_game
-	url = https://github.com/proller/minetest_game.git
diff --git a/CMakeLists.txt b/CMakeLists.txt
index 3848934..f9fff75 100644
--- a/CMakeLists.txt
+++ b/CMakeLists.txt
@@ -7,7 +7,7 @@ endif(${CMAKE_VERSION} STREQUAL "2.8.2")
 # This can be read from ${PROJECT_NAME} after project() is called
 project(minetest)
 
-set(VERSION_EXTRA "next" CACHE STRING "Stuff to append to version string")
+set(VERSION_EXTRA "" CACHE STRING "Stuff to append to version string")
 
 # Also remember to set PROTOCOL_VERSION in clientserver.h when releasing
 set(VERSION_MAJOR 0)
diff --git a/builtin/item_entity.lua b/builtin/item_entity.lua
index a23fdeb..95affe3 100644
--- a/builtin/item_entity.lua
+++ b/builtin/item_entity.lua
@@ -87,7 +87,7 @@ minetest.register_entity("__builtin:item", {
 		local nn = minetest.get_node(p).name
 		-- If node is not registered or node is walkably solid and resting on nodebox
 		local v = self.object:getvelocity()
-		if not minetest.registered_nodes[nn] or (minetest.registered_nodes[nn].walkable and minetest.get_item_group(nn, "slippery")==0) and v.y == 0 then
+		if not minetest.registered_nodes[nn] or minetest.registered_nodes[nn].walkable and v.y == 0 then
 			if self.physical_state then
 				self.object:setvelocity({x=0,y=0,z=0})
 				self.object:setacceleration({x=0, y=0, z=0})
@@ -104,17 +104,6 @@ minetest.register_entity("__builtin:item", {
 				self.object:set_properties({
 					physical = true
 				})
-			elseif minetest.get_item_group(nn, "slippery") ~= 0 then
-				if math.abs(v.x) < .2 and math.abs(v.z) < .2 then
-					self.object:setvelocity({x=0,y=0,z=0})
-					self.object:setacceleration({x=0, y=0, z=0})
-					self.physical_state = false
-					self.object:set_properties({
-						physical = false
-					})
-				else
-					self.object:setacceleration({x=-v.x, y=-10, z=-v.z})
-				end
 			end
 		end
 	end,
diff --git a/builtin/mainmenu.lua b/builtin/mainmenu.lua
index 1861186..e69de29 100644
--- a/builtin/mainmenu.lua
+++ b/builtin/mainmenu.lua
@@ -1,1232 +0,0 @@
-print = engine.debug
-math.randomseed(os.time())
-os.setlocale("C", "numeric")
-
-local errorfct = error
-error = function(text)
-	print(debug.traceback(""))
-	errorfct(text)
-end
-
-local scriptpath = engine.get_scriptdir()
-
-mt_color_grey  = "#AAAAAA"
-mt_color_blue  = "#0000DD"
-mt_color_green = "#00DD00"
-mt_color_dark_green = "#003300"
-
---for all other colors ask sfan5 to complete his worK!
-
-dofile(scriptpath .. DIR_DELIM .. "misc_helpers.lua")
-dofile(scriptpath .. DIR_DELIM .. "filterlist.lua")
-dofile(scriptpath .. DIR_DELIM .. "modmgr.lua")
-dofile(scriptpath .. DIR_DELIM .. "modstore.lua")
-dofile(scriptpath .. DIR_DELIM .. "gamemgr.lua")
-dofile(scriptpath .. DIR_DELIM .. "mm_textures.lua")
-dofile(scriptpath .. DIR_DELIM .. "mm_menubar.lua")
-
-menu = {}
-local tabbuilder = {}
-local worldlist = nil
-
---------------------------------------------------------------------------------
-local function filter_texture_pack_list(list)
-	retval = {"None"}
-	for _,i in ipairs(list) do
-		if i~="base" then
-			table.insert(retval, i)
-		end
-	end
-	return retval
-end
-
---------------------------------------------------------------------------------
-function menu.render_favorite(spec,render_details)
-	local text = ""
-	
-	if spec.name ~= nil then
-		text = text .. engine.formspec_escape(spec.name:trim())
-		
---		if spec.description ~= nil and
---			engine.formspec_escape(spec.description):trim() ~= "" then
---			text = text .. " (" .. engine.formspec_escape(spec.description) .. ")"
---		end
-	else
-		if spec.address ~= nil then
-			text = text .. spec.address:trim()
-			
-			if spec.port ~= nil then
-				text = text .. ":" .. spec.port
-			end
-		end
-	end
-	
-	if not render_details then
-		return text
-	end
-	
-	local details = ""
-	if spec.password == true then
-		details = details .. "*"
-	else
-		details = details .. "_"
-	end
-	
-	if spec.creative then
-		details = details .. "C"
-	else
-		details = details .. "_"
-	end
-	
-	if spec.damage then
-		details = details .. "D"
-	else
-		details = details .. "_"
-	end
-	
-	if spec.pvp then
-		details = details .. "P"
-	else
-		details = details .. "_"
-	end
-	details = details .. " "
-	
-	local playercount = ""
-	
-	if spec.clients ~= nil and
-		spec.clients_max ~= nil then
-		playercount = string.format("%03d",spec.clients) .. "/" ..
-						string.format("%03d",spec.clients_max) .. " "
-	end
-	
-	return playercount .. engine.formspec_escape(details) ..  text
-end
-
---------------------------------------------------------------------------------
-os.tempfolder = function()
-	local filetocheck = os.tmpname()
-	os.remove(filetocheck)
-	
-	local randname = "MTTempModFolder_" .. math.random(0,10000)
-	if DIR_DELIM == "\\" then
-		local tempfolder = os.getenv("TEMP")
-		return tempfolder .. filetocheck
-	else
-		local backstring = filetocheck:reverse()
-		return filetocheck:sub(0,filetocheck:len()-backstring:find(DIR_DELIM)+1) ..randname
-	end
-
-end
-
---------------------------------------------------------------------------------
-function init_globals()
-	--init gamedata
-	gamedata.worldindex = 0
-	
-	worldlist = filterlist.create(
-					engine.get_worlds,
-					compare_worlds,
-					function(element,uid)
-						if element.name == uid then
-							return true
-						end
-						return false
-					end, --unique id compare fct
-					function(element,gameid)
-						if element.gameid == gameid then
-							return true
-						end
-						return false
-					end --filter fct
-					)
-					
-	filterlist.add_sort_mechanism(worldlist,"alphabetic",sort_worlds_alphabetic)
-	filterlist.set_sortmode(worldlist,"alphabetic")
-end
-
---------------------------------------------------------------------------------
-function update_menu()
-
-	local formspec
-	
-	-- handle errors
-	if gamedata.errormessage ~= nil then
-		formspec = "size[12,5.2]" ..
-			"field[1,2;10,2;;ERROR: " ..
-			gamedata.errormessage .. 
-			";]"..
-			"button[4.5,4.2;3,0.5;btn_error_confirm;" .. fgettext("Ok") .. "]"
-	else
-		formspec = tabbuilder.gettab()
-	end
-
-	engine.update_formspec(formspec)
-end
-
---------------------------------------------------------------------------------
-function menu.render_world_list()
-	local retval = ""
-	
-	local current_worldlist = filterlist.get_list(worldlist)
-	
-	for i,v in ipairs(current_worldlist) do
-		if retval ~= "" then
-			retval = retval ..","
-		end
-		
-		retval = retval .. engine.formspec_escape(v.name) ..
-					" \\[" .. engine.formspec_escape(v.gameid) .. "\\]"
-	end
-
-	return retval
-end
-
---------------------------------------------------------------------------------
-function menu.render_texture_pack_list(list)
-	local retval = ""
-
-	for i,v in ipairs(list) do
-		if retval ~= "" then
-			retval = retval ..","
-		end
-
-		retval = retval .. v
-	end
-
-	return retval
-end
-
---------------------------------------------------------------------------------
-function menu.init()
-	--init menu data
-	gamemgr.update_gamelist()
-	
-	menu.last_game	= tonumber(engine.setting_get("main_menu_last_game_idx"))
-	
-	if type(menu.last_game) ~= "number" then
-		menu.last_game = 1
-	end
-
-	if engine.setting_getbool("public_serverlist") then
-		menu.favorites = engine.get_favorites("online")
-	else
-		menu.favorites = engine.get_favorites("local")
-	end
-	
-	menu.defaulttexturedir = engine.get_texturepath() .. DIR_DELIM .. "base" .. 
-					DIR_DELIM .. "pack" .. DIR_DELIM
-end
-
---------------------------------------------------------------------------------
-function menu.lastgame()
-	if menu.last_game > 0 and menu.last_game <= #gamemgr.games then
-		return gamemgr.games[menu.last_game]
-	end
-	
-	if #gamemgr.games >= 1 then
-		menu.last_game = 1
-		return gamemgr.games[menu.last_game]
-	end
-	
-	--error case!!
-	return nil
-end
-
---------------------------------------------------------------------------------
-function menu.update_last_game()
-
-	local current_world = filterlist.get_raw_element(worldlist,
-							engine.setting_get("mainmenu_last_selected_world")
-							)
-							
-	if current_world == nil then
-		return
-	end
-	
-	local gamespec, i = gamemgr.find_by_gameid(current_world.gameid)
-	if i ~= nil then
-		menu.last_game = i
-		engine.setting_set("main_menu_last_game_idx",menu.last_game)
-	end
-end
-
---------------------------------------------------------------------------------
-function menu.handle_key_up_down(fields,textlist,settingname)
-
-	if fields["key_up"] then
-		local oldidx = engine.get_textlist_index(textlist)
-		
-		if oldidx > 1 then
-			local newidx = oldidx -1
-			engine.setting_set(settingname,
-				filterlist.get_raw_index(worldlist,newidx))
-		end
-	end
-	
-	if fields["key_down"] then
-		local oldidx = engine.get_textlist_index(textlist)
-		
-		if oldidx < filterlist.size(worldlist) then
-			local newidx = oldidx + 1
-			engine.setting_set(settingname,
-				filterlist.get_raw_index(worldlist,newidx))
-		end
-	end
-end
-
---------------------------------------------------------------------------------
-function tabbuilder.dialog_create_world()
-	local mapgens = {"v6", "v7", "indev", "singlenode", "math"}
-
-	local current_seed = engine.setting_get("fixed_map_seed") or ""
-	local current_mg   = engine.setting_get("mg_name")
-
-	local mglist = ""
-	local selindex = 1
-	local i = 1
-	for k,v in pairs(mapgens) do
-		if current_mg == v then
-			selindex = i
-		end
-		i = i + 1
-		mglist = mglist .. v .. ","
-	end
-	mglist = mglist:sub(1, -2)
-
-	local retval = 
-		"label[2,0;" .. fgettext("World name") .. "]"..
-		"field[4.5,0.4;6,0.5;te_world_name;;]" ..
-
-		"label[2,1;" .. fgettext("Seed") .. "]"..
-		"field[4.5,1.4;6,0.5;te_seed;;".. current_seed .. "]" ..
-
-		"label[2,2;" .. fgettext("Mapgen") .. "]"..
-		"dropdown[4.2,2;6.3;dd_mapgen;" .. mglist .. ";" .. selindex .. "]" ..
-
-		"label[2,3;" .. fgettext("Game") .. "]"..
-		"textlist[4.2,3;5.8,2.3;games;" .. gamemgr.gamelist() ..
-		";" .. menu.last_game .. ";true]" ..
-
-		"button[5,5.5;2.6,0.5;world_create_confirm;" .. fgettext("Create") .. "]" ..
-		"button[7.5,5.5;2.8,0.5;world_create_cancel;" .. fgettext("Cancel") .. "]"
-
-	return retval
-end
-
---------------------------------------------------------------------------------
-function tabbuilder.dialog_delete_world()
-	return	"label[2,2;" ..
-			fgettext("Delete World \"$1\"?", filterlist.get_raw_list(worldlist)[menu.world_to_del].name) .. "]"..
-			"button[3.5,4.2;2.6,0.5;world_delete_confirm;" .. fgettext("Yes").. "]" ..
-			"button[6,4.2;2.8,0.5;world_delete_cancel;" .. fgettext("No") .. "]"
-end
-
---------------------------------------------------------------------------------
-
-function tabbuilder.gettab()
-	local tsize = tabbuilder.tabsizes[tabbuilder.current_tab] or {width=12, height=5.2}
-	local retval = "size[" .. tsize.width .. "," .. tsize.height .. "]"
-
-	if tabbuilder.show_buttons then
-		retval = retval .. tabbuilder.tab_header()
-	end
-
-	local buildfunc = tabbuilder.tabfuncs[tabbuilder.current_tab]
-	if buildfunc ~= nil then
-		retval = retval .. buildfunc()
-	end
-	
-	retval = retval .. modmgr.gettab(tabbuilder.current_tab)
-	retval = retval .. gamemgr.gettab(tabbuilder.current_tab)
-	retval = retval .. modstore.gettab(tabbuilder.current_tab)
-
-	return retval
-end
-
---------------------------------------------------------------------------------
-function tabbuilder.handle_create_world_buttons(fields)
-	
-	if fields["world_create_confirm"] or
-		fields["key_enter"] then
-		
-		local worldname = fields["te_world_name"]
-		local gameindex = engine.get_textlist_index("games")
-		
-		if gameindex > 0 and
-			worldname ~= "" then
-			
-			local message = nil
-			
-			if not filterlist.uid_exists_raw(worldlist,worldname) then
-				engine.setting_set("mg_name",fields["dd_mapgen"])
-				message = engine.create_world(worldname,gameindex)
-			else
-				message = fgettext("A world named \"$1\" already exists", worldname)
-			end
-
-			engine.setting_set("fixed_map_seed", fields["te_seed"])
-			
-			if message ~= nil then
-				gamedata.errormessage = message
-			else
-				menu.last_game = gameindex
-				engine.setting_set("main_menu_last_game_idx",gameindex)
-				
-				filterlist.refresh(worldlist)
-				engine.setting_set("mainmenu_last_selected_world",
-									filterlist.raw_index_by_uid(worldlist,worldname))
-			end
-		else
-			gamedata.errormessage = 
-				fgettext("No worldname given or no game selected")
-		end
-	end
-	
-	if fields["games"] then
-		tabbuilder.skipformupdate = true
-		return
-	end
-	
-	--close dialog
-	tabbuilder.is_dialog = false
-	tabbuilder.show_buttons = true
-	tabbuilder.current_tab = engine.setting_get("main_menu_tab")
-end
-
---------------------------------------------------------------------------------
-function tabbuilder.handle_delete_world_buttons(fields)
-	
-	if fields["world_delete_confirm"] then
-		if menu.world_to_del > 0 and 
-			menu.world_to_del <= #filterlist.get_raw_list(worldlist) then
-			engine.delete_world(menu.world_to_del)
-			menu.world_to_del = 0
-			filterlist.refresh(worldlist)
-		end
-	end
-	
-	tabbuilder.is_dialog = false
-	tabbuilder.show_buttons = true
-	tabbuilder.current_tab = engine.setting_get("main_menu_tab")
-end
-
---------------------------------------------------------------------------------
-function tabbuilder.handle_multiplayer_buttons(fields)
-	
-	if fields["te_name"] ~= nil then
-		gamedata.playername = fields["te_name"]
-		engine.setting_set("name", fields["te_name"])
-	end
-	
-	if fields["favourites"] ~= nil then
-		local event = explode_textlist_event(fields["favourites"])
-		if event.typ == "DCL" then
-			if event.index <= #menu.favorites then
-			gamedata.address = menu.favorites[event.index].address
-			gamedata.port = menu.favorites[event.index].port
-			gamedata.playername		= fields["te_name"]
-			if fields["te_pwd"] ~= nil then
-				gamedata.password		= fields["te_pwd"]
-			end
-			gamedata.selected_world = 0
-			
-			if menu.favorites ~= nil then
-				gamedata.servername = menu.favorites[event.index].name
-				gamedata.serverdescription = menu.favorites[event.index].description
-			end
-			
-			if gamedata.address ~= nil and
-				gamedata.port ~= nil then
-					engine.setting_set("address",gamedata.address)
-					engine.setting_set("remote_port",gamedata.port)
-				engine.start()
-			end
-		end
-		end
-		
-		if event.typ == "CHG" then
-			if event.index <= #menu.favorites then
-			local address = menu.favorites[event.index].address
-			local port = menu.favorites[event.index].port
-			
-			if address ~= nil and
-				port ~= nil then
-				engine.setting_set("address",address)
-					engine.setting_set("remote_port",port)
-			end
-			
-			menu.fav_selected = event.index
-		end
-		end
-		return
-	end
-	
-	if fields["key_up"] ~= nil or
-		fields["key_down"] ~= nil then
-		
-		local fav_idx = engine.get_textlist_index("favourites")
-		
-		if fields["key_up"] ~= nil and fav_idx > 1 then
-			fav_idx = fav_idx -1
-		else if fields["key_down"] and fav_idx < #menu.favorites then
-			fav_idx = fav_idx +1
-		end end
-		
-		local address = menu.favorites[fav_idx].address
-		local port = menu.favorites[fav_idx].port
-		
-		if address ~= nil and
-			port ~= nil then
-			engine.setting_set("address",address)
-			engine.setting_set("remote_port",port)
-		end
-		
-		menu.fav_selected = fav_idx
-		return
-	end
-	
-	if fields["cb_public_serverlist"] ~= nil then
-		engine.setting_set("public_serverlist", fields["cb_public_serverlist"])
-			
-		if engine.setting_getbool("public_serverlist") then
-			menu.favorites = engine.get_favorites("online")
-		else
-			menu.favorites = engine.get_favorites("local")
-		end
-		menu.fav_selected = nil
-		return
-	end
-
-	if fields["btn_delete_favorite"] ~= nil then
-		local current_favourite = engine.get_textlist_index("favourites")
-		engine.delete_favorite(current_favourite)
-		menu.favorites = engine.get_favorites()
-		menu.fav_selected = nil
-		
-		engine.setting_set("address","")
-		engine.setting_set("remote_port","30000")
-		
-		return
-	end
-
-	if fields["btn_mp_connect"] ~= nil or
-		fields["key_enter"] ~= nil then
-		
-		gamedata.playername		= fields["te_name"]
-		gamedata.password		= fields["te_pwd"]
-		gamedata.address		= fields["te_address"]
-		gamedata.port			= fields["te_port"]
-		
-		local fav_idx = engine.get_textlist_index("favourites")
-		
-		if fav_idx > 0 and fav_idx <= #menu.favorites and
-			menu.favorites[fav_idx].address == fields["te_address"] and
-			menu.favorites[fav_idx].port == fields["te_port"] then
-			
-			gamedata.servername			= menu.favorites[fav_idx].name
-			gamedata.serverdescription	= menu.favorites[fav_idx].description
-		else
-			gamedata.servername = ""
-			gamedata.serverdescription = ""
-		end
-
-		gamedata.selected_world = 0
-		
-		engine.setting_set("address",fields["te_address"])
-		engine.setting_set("remote_port",fields["te_port"])
-		
-		engine.start()
-		return
-	end
-end
-
---------------------------------------------------------------------------------
-function tabbuilder.handle_server_buttons(fields)
-
-	local world_doubleclick = false
-
-	if fields["srv_worlds"] ~= nil then
-		local event = explode_textlist_event(fields["srv_worlds"])
-		
-		if event.typ == "DCL" then
-			world_doubleclick = true
-		end
-		if event.typ == "CHG" then
-			engine.setting_set("mainmenu_last_selected_world",
-				filterlist.get_raw_index(worldlist,engine.get_textlist_index("srv_worlds")))
-		end
-	end
-	
-	menu.handle_key_up_down(fields,"srv_worlds","mainmenu_last_selected_world")
-	
-	if fields["cb_creative_mode"] then
-		engine.setting_set("creative_mode", fields["cb_creative_mode"])
-	end
-	
-	if fields["cb_enable_damage"] then
-		engine.setting_set("enable_damage", fields["cb_enable_damage"])
-	end
-
-	if fields["cb_server_announce"] then
-		engine.setting_set("server_announce", fields["cb_server_announce"])
-	end
-	
-	if fields["start_server"] ~= nil or
-		world_doubleclick or
-		fields["key_enter"] then
-		local selected = engine.get_textlist_index("srv_worlds")
-		if selected > 0 then
-			gamedata.playername		= fields["te_playername"]
-			gamedata.password		= fields["te_passwd"]
-			gamedata.port			= fields["te_serverport"]
-			gamedata.address		= ""
-			gamedata.selected_world	= filterlist.get_raw_index(worldlist,selected)
-			
-			engine.setting_set("port",gamedata.port)
-			menu.update_last_game(gamedata.selected_world)
-			engine.start()
-		end
-	end
-	
-	if fields["world_create"] ~= nil then
-		tabbuilder.current_tab = "dialog_create_world"
-		tabbuilder.is_dialog = true
-		tabbuilder.show_buttons = false
-	end
-	
-	if fields["world_delete"] ~= nil then
-		local selected = engine.get_textlist_index("srv_worlds")
-		if selected > 0 and
-			selected <= filterlist.size(worldlist) then
-			local world = filterlist.get_list(worldlist)[selected]
-			if world ~= nil and
-				world.name ~= nil and
-				world.name ~= "" then
-				menu.world_to_del = filterlist.get_raw_index(worldlist,selected)
-				tabbuilder.current_tab = "dialog_delete_world"
-				tabbuilder.is_dialog = true
-				tabbuilder.show_buttons = false
-			else
-				menu.world_to_del = 0
-			end
-		end
-	end
-	
-	if fields["world_configure"] ~= nil then
-		selected = engine.get_textlist_index("srv_worlds")
-		if selected > 0 then
-			modmgr.world_config_selected_world = filterlist.get_raw_index(worldlist,selected)
-			if modmgr.init_worldconfig() then
-				tabbuilder.current_tab = "dialog_configure_world"
-				tabbuilder.is_dialog = true
-				tabbuilder.show_buttons = false
-			end
-		end
-	end
-end
-
---------------------------------------------------------------------------------
-function tabbuilder.handle_settings_buttons(fields)
-	if fields["cb_fancy_trees"] then
-		engine.setting_set("new_style_leaves", fields["cb_fancy_trees"])
-	end
-	if fields["cb_smooth_lighting"] then
-		engine.setting_set("smooth_lighting", fields["cb_smooth_lighting"])
-	end
-	if fields["cb_3d_clouds"] then
-		engine.setting_set("enable_3d_clouds", fields["cb_3d_clouds"])
-	end
-	if fields["cb_opaque_water"] then
-		engine.setting_set("opaque_water", fields["cb_opaque_water"])
-	end
-	
-	if fields["cb_mipmapping"] then
-		engine.setting_set("mip_map", fields["cb_mipmapping"])
-	end
-	if fields["cb_anisotrophic"] then
-		engine.setting_set("anisotropic_filter", fields["cb_anisotrophic"])
-	end
-	if fields["cb_bilinear"] then
-		engine.setting_set("bilinear_filter", fields["cb_bilinear"])
-	end
-	if fields["cb_trilinear"] then
-		engine.setting_set("trilinear_filter", fields["cb_trilinear"])
-	end
-			
-	if fields["cb_shaders"] then
-		engine.setting_set("enable_shaders", fields["cb_shaders"])
-	end
-	if fields["cb_pre_ivis"] then
-		engine.setting_set("preload_item_visuals", fields["cb_pre_ivis"])
-	end
-	if fields["cb_particles"] then
-		engine.setting_set("enable_particles", fields["cb_particles"])
-	end
-	if fields["cb_finite_liquid"] then
-		engine.setting_set("liquid_finite", fields["cb_finite_liquid"])
-	end
-
-	if fields["btn_change_keys"] ~= nil then
-		engine.show_keys_menu()
-	end
-end
-
---------------------------------------------------------------------------------
-function tabbuilder.handle_singleplayer_buttons(fields)
-
-	local world_doubleclick = false
-
-	if fields["sp_worlds"] ~= nil then
-		local event = explode_textlist_event(fields["sp_worlds"])
-		
-		if event.typ == "DCL" then
-			world_doubleclick = true
-		end
-		
-		if event.typ == "CHG" then
-			engine.setting_set("mainmenu_last_selected_world",
-				filterlist.get_raw_index(worldlist,engine.get_textlist_index("sp_worlds")))
-		end
-	end
-	
-	menu.handle_key_up_down(fields,"sp_worlds","mainmenu_last_selected_world")
-	
-	if fields["cb_creative_mode"] then
-		engine.setting_set("creative_mode", fields["cb_creative_mode"])
-	end
-	
-	if fields["cb_enable_damage"] then
-		engine.setting_set("enable_damage", fields["cb_enable_damage"])
-	end
-
-	if fields["play"] ~= nil or
-		world_doubleclick or
-		fields["key_enter"] then
-		local selected = engine.get_textlist_index("sp_worlds")
-		if selected > 0 then
-			gamedata.selected_world	= filterlist.get_raw_index(worldlist,selected)
-			gamedata.singleplayer	= true
-			
-			menu.update_last_game(gamedata.selected_world)
-			
-			engine.start()
-		end
-	end
-	
-	if fields["world_create"] ~= nil then
-		tabbuilder.current_tab = "dialog_create_world"
-		tabbuilder.is_dialog = true
-		tabbuilder.show_buttons = false
-	end
-	
-	if fields["world_delete"] ~= nil then
-		local selected = engine.get_textlist_index("sp_worlds")
-		if selected > 0 and
-			selected <= filterlist.size(worldlist) then
-			local world = filterlist.get_list(worldlist)[selected]
-			if world ~= nil and
-				world.name ~= nil and
-				world.name ~= "" then
-				menu.world_to_del = filterlist.get_raw_index(worldlist,selected)
-				tabbuilder.current_tab = "dialog_delete_world"
-				tabbuilder.is_dialog = true
-				tabbuilder.show_buttons = false
-			else
-				menu.world_to_del = 0
-			end
-		end
-	end
-	
-	if fields["world_configure"] ~= nil then
-		selected = engine.get_textlist_index("sp_worlds")
-		if selected > 0 then
-			modmgr.world_config_selected_world = filterlist.get_raw_index(worldlist,selected)
-			if modmgr.init_worldconfig() then
-				tabbuilder.current_tab = "dialog_configure_world"
-				tabbuilder.is_dialog = true
-				tabbuilder.show_buttons = false
-			end
-		end
-	end
-end
-
---------------------------------------------------------------------------------
-function tabbuilder.handle_texture_pack_buttons(fields)
-	if fields["TPs"] ~= nil then
-		local event = explode_textlist_event(fields["TPs"])
-		if event.typ == "CHG" or event.typ=="DCL" then
-			local index = engine.get_textlist_index("TPs")
-			engine.setting_set("mainmenu_last_selected_TP",
-				index)
-			local list = filter_texture_pack_list(engine.get_dirlist(engine.get_texturepath(), true))
-			local current_index = engine.get_textlist_index("TPs")
-			if #list >= current_index then
-				local new_path = engine.get_texturepath()..DIR_DELIM..list[current_index]
-				if list[current_index] == "None" then new_path = "" end
-				
-				engine.setting_set("texture_path", new_path)
-			end
-		end
-	end
-end
-
---------------------------------------------------------------------------------
-function tabbuilder.tab_header()
-
-	if tabbuilder.last_tab_index == nil then
-		tabbuilder.last_tab_index = 1
-	end
-	
-	local toadd = ""
-	
-	for i=1,#tabbuilder.current_buttons,1 do
-		
-		if toadd ~= "" then
-			toadd = toadd .. ","
-		end
-		
-		toadd = toadd .. tabbuilder.current_buttons[i].caption
-	end
-	return "tabheader[-0.3,-0.99;main_tab;" .. toadd ..";" .. tabbuilder.last_tab_index .. ";true;false]"
-end
-
---------------------------------------------------------------------------------
-function tabbuilder.handle_tab_buttons(fields)
-
-	if fields["main_tab"] then
-		local index = tonumber(fields["main_tab"])
-		tabbuilder.last_tab_index = index
-		tabbuilder.current_tab = tabbuilder.current_buttons[index].name
-		
-		engine.setting_set("main_menu_tab",tabbuilder.current_tab)
-	end
-	
-	--handle tab changes
-	if tabbuilder.current_tab ~= tabbuilder.old_tab then
-		if tabbuilder.current_tab ~= "singleplayer" and not tabbuilder.is_dialog then
-			menu.update_gametype(true)
-		end
-	end
-	
-	if tabbuilder.current_tab == "singleplayer" then
-		menu.update_gametype()
-	end
-	
-	tabbuilder.old_tab = tabbuilder.current_tab
-end
-
---------------------------------------------------------------------------------
-function tabbuilder.tab_multiplayer()
-
-	local retval =
-		"vertlabel[0,-0.25;".. fgettext("CLIENT") .. "]" ..
-		"label[1,-0.25;".. fgettext("Favorites:") .. "]"..
-		"label[1,4.25;".. fgettext("Address/Port") .. "]"..
-		"label[9,2.75;".. fgettext("Name/Password") .. "]" ..
-		"field[1.25,5.25;5.5,0.5;te_address;;" ..engine.setting_get("address") .."]" ..
-		"field[6.75,5.25;2.25,0.5;te_port;;" ..engine.setting_get("remote_port") .."]" ..
-		"checkbox[1,3.6;cb_public_serverlist;".. fgettext("Public Serverlist") .. ";" ..
-		dump(engine.setting_getbool("public_serverlist")) .. "]"
-		
-	if not engine.setting_getbool("public_serverlist") then
-		retval = retval .. 
-		"button[6.45,3.95;2.25,0.5;btn_delete_favorite;".. fgettext("Delete") .. "]"
-	end
-	
-	retval = retval ..
-		"button[9,4.95;2.5,0.5;btn_mp_connect;".. fgettext("Connect") .. "]" ..
-		"field[9.3,3.75;2.5,0.5;te_name;;" ..engine.setting_get("name") .."]" ..
-		"pwdfield[9.3,4.5;2.5,0.5;te_pwd;]" ..
-		"textarea[9.3,0.25;2.5,2.75;;"
-	if menu.fav_selected ~= nil and 
-		menu.favorites[menu.fav_selected].description ~= nil then
-		retval = retval .. 
-			engine.formspec_escape(menu.favorites[menu.fav_selected].description,true)
-	end
-	
-	retval = retval .. 
-		";]" ..
-		"textlist[1,0.35;7.5,3.35;favourites;"
-
-	local render_details = engine.setting_getbool("public_serverlist")
-
-	if #menu.favorites > 0 then
-		retval = retval .. menu.render_favorite(menu.favorites[1],render_details)
-		
-		for i=2,#menu.favorites,1 do
-			retval = retval .. "," .. menu.render_favorite(menu.favorites[i],render_details)
-		end
-	end
-
-	if menu.fav_selected ~= nil then
-		retval = retval .. ";" .. menu.fav_selected .. "]"
-	else
-		retval = retval .. ";0]"
-	end
-
-	return retval
-end
-
---------------------------------------------------------------------------------
-function tabbuilder.tab_server()
-
-	local index = filterlist.get_current_index(worldlist,
-				tonumber(engine.setting_get("mainmenu_last_selected_world"))
-				)
-	
-	local retval = 
-		"button[4,4.15;2.6,0.5;world_delete;".. fgettext("Delete") .. "]" ..
-		"button[6.5,4.15;2.8,0.5;world_create;".. fgettext("New") .. "]" ..
-		"button[9.2,4.15;2.55,0.5;world_configure;".. fgettext("Configure") .. "]" ..
-		"button[8.5,4.9;3.25,0.5;start_server;".. fgettext("Start Game") .. "]" ..
-		"label[4,-0.25;".. fgettext("Select World:") .. "]"..
-		"vertlabel[0,-0.25;".. fgettext("START SERVER") .. "]" ..
-		"checkbox[0.5,0.25;cb_creative_mode;".. fgettext("Creative Mode") .. ";" ..
-		dump(engine.setting_getbool("creative_mode")) .. "]"..
-		"checkbox[0.5,0.7;cb_enable_damage;".. fgettext("Enable Damage") .. ";" ..
-		dump(engine.setting_getbool("enable_damage")) .. "]"..
-		"checkbox[0.5,1.15;cb_server_announce;".. fgettext("Public") .. ";" ..
-		dump(engine.setting_getbool("server_announce")) .. "]"..
-		"field[0.8,3.2;3,0.5;te_playername;".. fgettext("Name") .. ";" ..
-		engine.setting_get("name") .. "]" ..
-		"pwdfield[0.8,4.2;3,0.5;te_passwd;".. fgettext("Password") .. "]" ..
-		"field[0.8,5.2;3,0.5;te_serverport;".. fgettext("Server Port") .. ";" .. 
-		engine.setting_get("port") .."]" ..
-		"textlist[4,0.25;7.5,3.7;srv_worlds;" ..
-		menu.render_world_list() ..
-		";" .. index .. "]"
-		
-	return retval
-end
-
---------------------------------------------------------------------------------
-function tabbuilder.tab_settings()
-	return	"vertlabel[0,0;" .. fgettext("SETTINGS") .. "]" ..
-			"checkbox[1,0.75;cb_fancy_trees;".. fgettext("Fancy trees") .. ";" 
-					.. dump(engine.setting_getbool("new_style_leaves")) .. "]"..
-			"checkbox[1,1.25;cb_smooth_lighting;".. fgettext("Smooth Lighting") 
-					.. ";".. dump(engine.setting_getbool("smooth_lighting")) .. "]"..
-			"checkbox[1,1.75;cb_3d_clouds;".. fgettext("3D Clouds") .. ";"
-					.. dump(engine.setting_getbool("enable_3d_clouds")) .. "]"..
-			"checkbox[1,2.25;cb_opaque_water;".. fgettext("Opaque Water") .. ";"
-					.. dump(engine.setting_getbool("opaque_water")) .. "]"..
-			
-			"checkbox[4,0.75;cb_mipmapping;".. fgettext("Mip-Mapping") .. ";"
-					.. dump(engine.setting_getbool("mip_map")) .. "]"..
-			"checkbox[4,1.25;cb_anisotrophic;".. fgettext("Anisotropic Filtering") .. ";"
-					.. dump(engine.setting_getbool("anisotropic_filter")) .. "]"..
-			"checkbox[4,1.75;cb_bilinear;".. fgettext("Bi-Linear Filtering") .. ";"
-					.. dump(engine.setting_getbool("bilinear_filter")) .. "]"..
-			"checkbox[4,2.25;cb_trilinear;".. fgettext("Tri-Linear Filtering") .. ";"
-					.. dump(engine.setting_getbool("trilinear_filter")) .. "]"..
-			
-			"checkbox[7.5,0.75;cb_shaders;".. fgettext("Shaders") .. ";"
-					.. dump(engine.setting_getbool("enable_shaders")) .. "]"..
-			"checkbox[7.5,1.25;cb_pre_ivis;".. fgettext("Preload item visuals") .. ";"
-					.. dump(engine.setting_getbool("preload_item_visuals"))	.. "]"..
-			"checkbox[7.5,1.75;cb_particles;".. fgettext("Enable Particles") .. ";"
-					.. dump(engine.setting_getbool("enable_particles"))	.. "]"..
-			"checkbox[7.5,2.25;cb_finite_liquid;".. fgettext("Finite Liquid") .. ";"
-					.. dump(engine.setting_getbool("liquid_finite")) .. "]"..
-			
-			"button[1,4.25;2.25,0.5;btn_change_keys;".. fgettext("Change keys") .. "]"
-end
-
---------------------------------------------------------------------------------
-function tabbuilder.tab_singleplayer()
-	
-	local index = filterlist.get_current_index(worldlist,
-				tonumber(engine.setting_get("mainmenu_last_selected_world"))
-				)
-
-	return	"button[4,4.15;2.6,0.5;world_delete;".. fgettext("Delete") .. "]" ..
-			"button[6.5,4.15;2.8,0.5;world_create;".. fgettext("New") .. "]" ..
-			"button[9.2,4.15;2.55,0.5;world_configure;".. fgettext("Configure") .. "]" ..
-			"button[8.5,4.95;3.25,0.5;play;".. fgettext("Play") .. "]" ..
-			"label[4,-0.25;".. fgettext("Select World:") .. "]"..
-			"vertlabel[0,-0.25;".. fgettext("SINGLE PLAYER") .. "]" ..
-			"checkbox[0.5,0.25;cb_creative_mode;".. fgettext("Creative Mode") .. ";" ..
-			dump(engine.setting_getbool("creative_mode")) .. "]"..
-			"checkbox[0.5,0.7;cb_enable_damage;".. fgettext("Enable Damage") .. ";" ..
-			dump(engine.setting_getbool("enable_damage")) .. "]"..
-			"textlist[4,0.25;7.5,3.7;sp_worlds;" ..
-			menu.render_world_list() ..
-			";" .. index .. "]" ..
-			menubar.formspec
-end
-
---------------------------------------------------------------------------------
-function tabbuilder.tab_texture_packs()
-	local retval = "label[4,-0.25;".. fgettext("Select texture pack:") .. "]"..
-			"vertlabel[0,-0.25;".. fgettext("TEXTURE PACKS") .. "]" ..
-			"textlist[4,0.25;7.5,5.0;TPs;"
-
-	local current_texture_path = engine.setting_get("texture_path")	
-	local list = filter_texture_pack_list(engine.get_dirlist(engine.get_texturepath(), true))	
-	local index = tonumber(engine.setting_get("mainmenu_last_selected_TP"))
-	
-	if index == nil then index = 1 end
-	
-	if current_texture_path == "" then
-		retval = retval ..
-			menu.render_texture_pack_list(list) ..
-			";" .. index .. "]"
-		return retval
-	end
-	
-	local infofile = current_texture_path ..DIR_DELIM.."info.txt"
-	local infotext = ""
-	local f = io.open(infofile, "r")
-	if f==nil then
-		infotext = fgettext("No information available")
-	else
-		infotext = f:read("*all")
-		f:close()
-	end
-	
-	local screenfile = current_texture_path..DIR_DELIM.."screenshot.png"
-	local no_screenshot = nil
-	if not file_exists(screenfile) then
-		screenfile = nil
-		no_screenshot = engine.get_texturepath()..DIR_DELIM..
-					"base"..DIR_DELIM.."pack"..DIR_DELIM.."no_screenshot.png"
-	end
-
-	return	retval ..
-			menu.render_texture_pack_list(list) ..
-			";" .. index .. "]" ..
-			"image[0.65,0.25;4.0,3.7;"..engine.formspec_escape(screenfile or no_screenshot).."]"..
-			"textarea[1.0,3.25;3.7,1.5;;"..engine.formspec_escape(infotext or "")..";]"
-end
-
---------------------------------------------------------------------------------
-function tabbuilder.tab_credits()
-	local logofile = menu.defaulttexturedir .. "logo.png"
-	return	"vertlabel[0,-0.5;CREDITS]" ..
-			"label[0.5,3;Minetest " .. engine.get_version() .. "]" ..
-			"label[0.5,3.3;http://minetest.net]" .. 
-			"image[0.5,1;" .. engine.formspec_escape(logofile) .. "]" ..
-			"textlist[3.5,-0.25;8.5,5.8;list_credits;" ..
-			"#FFFF00" .. fgettext("Core Developers") .."," ..
-			"Perttu Ahola (celeron55) <celeron55@gmail.com>,"..
-			"Ryan Kwolek (kwolekr) <kwolekr@minetest.net>,"..
-			"PilzAdam <pilzadam@minetest.net>," ..
-			"Ilya Zhuravlev (xyz) <xyz@minetest.net>,"..
-			"Lisa Milne (darkrose) <lisa@ltmnet.com>,"..
-			"Maciej Kasatkin (RealBadAngel) <mk@realbadangel.pl>,"..
-			"proller <proler@gmail.com>,"..
-			"sfan5 <sfan5@live.de>,"..
-			"kahrl <kahrl@gmx.net>,"..
-			"sapier,"..
-			"ShadowNinja <shadowninja@minetest.net>,"..
-			"Nathanaël Courant (Nore/Novatux) <nore@mesecons.net>,"..
-			"BlockMen,"..
-			","..
-			"#FFFF00" .. fgettext("Active Contributors") .. "," ..
-			"Vanessa Ezekowitz (VanessaE) <vanessaezekowitz@gmail.com>,"..
-			"Jurgen Doser (doserj) <jurgen.doser@gmail.com>,"..
-			"Jeija <jeija@mesecons.net>,"..
-			"MirceaKitsune <mirceakitsune@gmail.com>,"..
-			"dannydark <the_skeleton_of_a_child@yahoo.co.uk>,"..
-			"0gb.us <0gb.us@0gb.us>,"..
-			"," ..
-			"#FFFF00" .. fgettext("Previous Contributors") .. "," ..
-			"Guiseppe Bilotta (Oblomov) <guiseppe.bilotta@gmail.com>,"..
-			"Jonathan Neuschafer <j.neuschaefer@gmx.net>,"..
-			"Nils Dagsson Moskopp (erlehmann) <nils@dieweltistgarnichtso.net>,"..
-			"Constantin Wenger (SpeedProg) <constantin.wenger@googlemail.com>,"..
-			"matttpt <matttpt@gmail.com>,"..
-			"JacobF <queatz@gmail.com>,"..
-			";0;true]"
-end
-
---------------------------------------------------------------------------------
-function tabbuilder.init()
-	tabbuilder.tabfuncs = {
-		singleplayer  = tabbuilder.tab_singleplayer,
-		multiplayer   = tabbuilder.tab_multiplayer,
-		server        = tabbuilder.tab_server,
-		settings      = tabbuilder.tab_settings,
-		texture_packs = tabbuilder.tab_texture_packs,
-		credits       = tabbuilder.tab_credits,
-		dialog_create_world = tabbuilder.dialog_create_world,
-		dialog_delete_world = tabbuilder.dialog_delete_world
-	}
-
-	tabbuilder.tabsizes = {
-		dialog_create_world = {width=12, height=7},
-		dialog_delete_world = {width=12, height=5.2}
-	}
-
-	tabbuilder.current_tab = engine.setting_get("main_menu_tab")
-	
-	if tabbuilder.current_tab == nil or
-		tabbuilder.current_tab == "" then
-		tabbuilder.current_tab = "singleplayer"
-		engine.setting_set("main_menu_tab",tabbuilder.current_tab)
-	end
-	
-	--initialize tab buttons
-	tabbuilder.last_tab = nil
-	tabbuilder.show_buttons = true
-	
-	tabbuilder.current_buttons = {}
-	table.insert(tabbuilder.current_buttons,{name="singleplayer", caption=fgettext("Singleplayer")})
-	table.insert(tabbuilder.current_buttons,{name="multiplayer", caption=fgettext("Client")})
-	table.insert(tabbuilder.current_buttons,{name="server", caption=fgettext("Server")})
-	table.insert(tabbuilder.current_buttons,{name="settings", caption=fgettext("Settings")})
-	table.insert(tabbuilder.current_buttons,{name="texture_packs", caption=fgettext("Texture Packs")})
-	
-	if engine.setting_getbool("main_menu_game_mgr") then
-		table.insert(tabbuilder.current_buttons,{name="game_mgr", caption=fgettext("Games")})
-	end
-	
-	if engine.setting_getbool("main_menu_mod_mgr") then
-		table.insert(tabbuilder.current_buttons,{name="mod_mgr", caption=fgettext("Mods")})
-	end
-	table.insert(tabbuilder.current_buttons,{name="credits", caption=fgettext("Credits")})
-	
-	
-	for i=1,#tabbuilder.current_buttons,1 do
-		if tabbuilder.current_buttons[i].name == tabbuilder.current_tab then
-			tabbuilder.last_tab_index = i
-		end
-	end
-	
-	if tabbuilder.current_tab ~= "singleplayer" then
-		menu.update_gametype(true)
-	else
-		menu.update_gametype()
-	end
-end
-
---------------------------------------------------------------------------------
-function tabbuilder.checkretval(retval)
-
-	if retval ~= nil then
-		if retval.current_tab ~= nil then
-			tabbuilder.current_tab = retval.current_tab
-		end
-		
-		if retval.is_dialog ~= nil then
-			tabbuilder.is_dialog = retval.is_dialog
-		end
-		
-		if retval.show_buttons ~= nil then
-			tabbuilder.show_buttons = retval.show_buttons
-		end
-		
-		if retval.skipformupdate ~= nil then
-			tabbuilder.skipformupdate = retval.skipformupdate
-		end
-	end
-end
-
---------------------------------------------------------------------------------
---------------------------------------------------------------------------------
--- initialize callbacks
---------------------------------------------------------------------------------
---------------------------------------------------------------------------------
-engine.button_handler = function(fields)
-	--print("Buttonhandler: tab: " .. tabbuilder.current_tab .. " fields: " .. dump(fields))
-	
-	if fields["btn_error_confirm"] then
-		gamedata.errormessage = nil
-	end
-	
-	local retval = modmgr.handle_buttons(tabbuilder.current_tab,fields)
-	tabbuilder.checkretval(retval)
-	
-	retval = gamemgr.handle_buttons(tabbuilder.current_tab,fields)
-	tabbuilder.checkretval(retval)
-	
-	retval = modstore.handle_buttons(tabbuilder.current_tab,fields)
-	tabbuilder.checkretval(retval)
-	
-	if tabbuilder.current_tab == "dialog_create_world" then
-		tabbuilder.handle_create_world_buttons(fields)
-	end
-	
-	if tabbuilder.current_tab == "dialog_delete_world" then
-		tabbuilder.handle_delete_world_buttons(fields)
-	end
-	
-	if tabbuilder.current_tab == "singleplayer" then
-		tabbuilder.handle_singleplayer_buttons(fields)
-	end
-	
-	if tabbuilder.current_tab == "texture_packs" then
-		tabbuilder.handle_texture_pack_buttons(fields)
-	end
-	
-	if tabbuilder.current_tab == "multiplayer" then
-		tabbuilder.handle_multiplayer_buttons(fields)
-	end
-	
-	if tabbuilder.current_tab == "settings" then
-		tabbuilder.handle_settings_buttons(fields)
-	end
-	
-	if tabbuilder.current_tab == "server" then
-		tabbuilder.handle_server_buttons(fields)
-	end
-	
-	--tab buttons
-	tabbuilder.handle_tab_buttons(fields)
-	
-	--menubar buttons
-	menubar.handle_buttons(fields)
-	
-	if not tabbuilder.skipformupdate then
-		--update menu
-		update_menu()
-	else
-		tabbuilder.skipformupdate = false
-	end
-end
-
---------------------------------------------------------------------------------
-engine.event_handler = function(event)
-	if event == "MenuQuit" then
-		if tabbuilder.is_dialog then
-			tabbuilder.is_dialog = false
-			tabbuilder.show_buttons = true
-			tabbuilder.current_tab = engine.setting_get("main_menu_tab")
-			menu.update_gametype()
-			update_menu()
-		else
-			engine.close()
-		end
-	end
-end
-
---------------------------------------------------------------------------------
-function menu.update_gametype(reset)
-	local game = menu.lastgame()
-
-	if reset or game == nil then
-		mm_texture.reset()
-		engine.set_topleft_text("")
-		filterlist.set_filtercriteria(worldlist,nil)
-	else
-		mm_texture.update(tabbuilder.current_tab,game)
-		engine.set_topleft_text(game.name)
-		filterlist.set_filtercriteria(worldlist,game.id)
-	end
-end
-
---------------------------------------------------------------------------------
---------------------------------------------------------------------------------
--- menu startup
---------------------------------------------------------------------------------
---------------------------------------------------------------------------------
-init_globals()
-mm_texture.init()
-menu.init()
-tabbuilder.init()
-menubar.refresh()
-modstore.init()
-
-engine.sound_play("main_menu", true)
-
-update_menu()
diff --git a/src/mandelbulber/algebra.cpp b/src/mandelbulber/algebra.cpp
deleted file mode 100644
index 0dbcd6c..0000000
--- a/src/mandelbulber/algebra.cpp
+++ /dev/null
@@ -1,213 +0,0 @@
-/*
- * algebra.cpp
- *
- *  Created on: 2010-02-28
- *      Author: krzysztof
- */
-#include "algebra.hpp"
-
-/***************** class CMatrix33 ***********************/
-CMatrix33::CMatrix33()
-{
-	m11 = 0;
-	m12 = 0;
-	m13 = 0;
-	m21 = 0;
-	m22 = 0;
-	m23 = 0;
-	m31 = 0;
-	m32 = 0;
-	m33 = 0;
-}
-
-CMatrix33::CMatrix33(const CMatrix33 &matrix)
-{
-	m11 = matrix.m11;
-	m12 = matrix.m12;
-	m13 = matrix.m13;
-	m21 = matrix.m21;
-	m22 = matrix.m22;
-	m23 = matrix.m23;
-	m31 = matrix.m31;
-	m32 = matrix.m32;
-	m33 = matrix.m33;
-}
-
-CMatrix33& CMatrix33::operator=(const CMatrix33 &matrix)
-{
-	m11 = matrix.m11;
-	m12 = matrix.m12;
-	m13 = matrix.m13;
-	m21 = matrix.m21;
-	m22 = matrix.m22;
-	m23 = matrix.m23;
-	m31 = matrix.m31;
-	m32 = matrix.m32;
-	m33 = matrix.m33;
-	return *this;
-}
-
-CMatrix33 CMatrix33::operator*(const CMatrix33 &matrix) const
-{
-	CMatrix33 result;
-	result.m11 = m11 * matrix.m11 + m12 * matrix.m21 + m13 * matrix.m31;
-	result.m12 = m11 * matrix.m12 + m12 * matrix.m22 + m13 * matrix.m32;
-	result.m13 = m11 * matrix.m13 + m12 * matrix.m23 + m13 * matrix.m33;
-	result.m21 = m21 * matrix.m11 + m22 * matrix.m21 + m23 * matrix.m31;
-	result.m22 = m21 * matrix.m12 + m22 * matrix.m22 + m23 * matrix.m32;
-	result.m23 = m21 * matrix.m13 + m22 * matrix.m23 + m23 * matrix.m33;
-	result.m31 = m31 * matrix.m11 + m32 * matrix.m21 + m33 * matrix.m31;
-	result.m32 = m31 * matrix.m12 + m32 * matrix.m22 + m33 * matrix.m32;
-	result.m33 = m31 * matrix.m13 + m32 * matrix.m23 + m33 * matrix.m33;
-	return result;
-}
-
-CVector3 CMatrix33::operator*(const CVector3 &vector) const
-{
-	CVector3 result;
-	result.x = m11 * vector.x + m12 * vector.y + m13 * vector.z;
-	result.y = m21 * vector.x + m22 * vector.y + m23 * vector.z;
-	result.z = m31 * vector.x + m32 * vector.y + m33 * vector.z;
-	return result;
-}
-
-/**************** class RotarionMatrix **********************/
-CRotationMatrix::CRotationMatrix()
-{
-	matrix.m11 = 1.0;
-	matrix.m12 = 0.0;
-	matrix.m13 = 0.0;
-	matrix.m21 = 0.0;
-	matrix.m22 = 1.0;
-	matrix.m23 = 0.0;
-	matrix.m31 = 0.0;
-	matrix.m32 = 0.0;
-	matrix.m33 = 1.0;
-	zero = true;
-}
-
-void CRotationMatrix::RotateX(double angle)
-{
-	if (angle != 0.0)
-	{
-		CMatrix33 rot;
-		double s = sin(angle);
-		double c = cos(angle);
-		rot.m11 = 1.0;
-		rot.m22 = c;
-		rot.m33 = c;
-		rot.m23 = -s;
-		rot.m32 = s;
-		matrix = matrix * rot;
-		zero = false;
-	}
-}
-
-void CRotationMatrix::RotateY(double angle)
-{
-	if (angle != 0.0)
-	{
-		CMatrix33 rot;
-		double s = sin(angle);
-		double c = cos(angle);
-		rot.m22 = 1.0;
-		rot.m33 = c;
-		rot.m11 = c;
-		rot.m31 = -s;
-		rot.m13 = s;
-		matrix = matrix * rot;
-		zero = false;
-	}
-}
-
-void CRotationMatrix::RotateZ(double angle)
-{
-	if (angle != 0.0)
-	{
-		CMatrix33 rot;
-		double s = sin(angle);
-		double c = cos(angle);
-		rot.m33 = 1.0;
-		rot.m11 = c;
-		rot.m22 = c;
-		rot.m12 = -s;
-		rot.m21 = s;
-		matrix = matrix * rot;
-		zero = false;
-	}
-}
-
-void CRotationMatrix::SetRotation(double angles[3])
-{
-	Null();
-	RotateZ(angles[2]);
-	RotateY(angles[1]);
-	RotateX(angles[0]);
-}
-
-void CRotationMatrix::SetRotation(double alfa, double beta, double gamma)
-{
-	Null();
-	RotateZ(alfa);
-	RotateY(beta);
-	RotateX(gamma);
-}
-
-CVector3 CRotationMatrix::RotateVector(const CVector3& vector) const
-{
-	if (!zero)
-	{
-		CVector3 vector2 = matrix * vector;
-		return vector2;
-	}
-	else
-	{
-		return vector;
-	}
-}
-
-void CRotationMatrix::Null()
-{
-	//CRotationMatrix();
-	matrix.m11 = 1.0;
-	matrix.m12 = 0.0;
-	matrix.m13 = 0.0;
-	matrix.m21 = 0.0;
-	matrix.m22 = 1.0;
-	matrix.m23 = 0.0;
-	matrix.m31 = 0.0;
-	matrix.m32 = 0.0;
-	matrix.m33 = 1.0;
-	zero = true;
-}
-
-double CRotationMatrix::GetAlfa() const
-{
-	return atan2(matrix.m12,matrix.m22);
-}
-
-double CRotationMatrix::GetBeta() const
-{
-	return asin(-matrix.m32);
-}
-
-double CRotationMatrix::GetGamma() const
-{
-	return atan2(matrix.m31,matrix.m33);
-}
-
-CRotationMatrix CRotationMatrix::Transpose() const
-{
-	CRotationMatrix m;
-	m.matrix.m11 = matrix.m11;
-	m.matrix.m12 = matrix.m21;
-	m.matrix.m13 = matrix.m31;
-	m.matrix.m21 = matrix.m12;
-	m.matrix.m22 = matrix.m22;
-	m.matrix.m23 = matrix.m32;
-	m.matrix.m31 = matrix.m13;
-	m.matrix.m32 = matrix.m23;
-	m.matrix.m33 = matrix.m33;
-	m.zero = false;
-	return m;
-}
diff --git a/src/mandelbulber/algebra.hpp b/src/mandelbulber/algebra.hpp
deleted file mode 100644
index ae63bf2..0000000
--- a/src/mandelbulber/algebra.hpp
+++ /dev/null
@@ -1,161 +0,0 @@
-/********************************************************
- /                   3D math                             *
- /                                                       *
- / author: Krzysztof Marczak                             *
- / contact: buddhi1980@gmail.com                         *
- / licence: GNU GPL                                      *
- ********************************************************/
-
-#ifndef ALGEBRA_H_
-#define ALGEBRA_H_
-
-#include <math.h>
-
-/************************* vector 3D **********************/
-class CVector3
-{
-public:
-	inline CVector3()
-	{
-		x = 0;
-		y = 0;
-		z = 0;
-	}
-	inline CVector3(double x_init, double y_init, double z_init)
-	{
-		x = x_init;
-		y = y_init;
-		z = z_init;
-	}
-	inline CVector3(double alfa, double beta)
-	{
-		x = cos(beta) * cos(alfa);
-		y = cos(beta) * sin(alfa);
-		z = sin(beta);
-	}
-	inline CVector3(const CVector3 &vector)
-	{
-		x = vector.x;
-		y = vector.y;
-		z = vector.z;
-	}
-	inline CVector3 operator+(const CVector3 &vector) const
-	{
-		return CVector3(x + vector.x, y + vector.y, z + vector.z);
-	}
-	inline CVector3 operator-(const CVector3 &vector) const
-	{
-		return CVector3(x - vector.x, y - vector.y, z - vector.z);
-	}
-	inline CVector3 operator*(const double &scalar) const
-	{
-		return CVector3(x * scalar, y * scalar, z * scalar);
-	}
-	inline CVector3& operator=(const CVector3 &vector)
-	{
-		x = vector.x;
-		y = vector.y;
-		z = vector.z;
-		return *this;
-	}
-	inline CVector3& operator+=(const CVector3 &vector)
-	{
-		x += vector.x;
-		y += vector.y;
-		z += vector.z;
-		return *this;
-	}
-	inline CVector3& operator-=(const CVector3 &vector)
-	{
-		x -= vector.x;
-		y -= vector.y;
-		z -= vector.z;
-		return *this;
-	}
-	inline CVector3& operator*=(const double &scalar)
-	{
-		x *= scalar;
-		y *= scalar;
-		z *= scalar;
-		return *this;
-	}
-	inline double Length() const
-	{
-		return sqrt(x * x + y * y + z * z);
-	}
-	inline double Dot(const CVector3& vector) const
-	{
-		return x * vector.x + y * vector.y + z * vector.z;
-	}
-	inline CVector3 Cross(const CVector3& v)
-	{
-		CVector3 c;
-		c.x =  y*v.z - z*v.y;
-	  c.y = -x*v.z + z*v.x;
-	  c.z =  x*v.y - y*v.x;
-	  return c;
-	}
-	inline double Normalize() //returns normalization factor
-	{
-		double norm = 1.0 / Length();
-		x = x * norm;
-		y = y * norm;
-		z = z * norm;
-		return norm;
-	}
-	inline double GetAlfa() const
-	{
-		return atan2(y, x);
-	}
-	inline double GetBeta() const
-	{
-		return atan2(z, sqrt(x * x + y * y));
-	}
-	double x;
-	double y;
-	double z;
-};
-
-/************************* matrix 3x3 (fast) *****************/
-class CMatrix33
-{
-public:
-	CMatrix33();
-	CMatrix33(const CMatrix33 &matrix);
-	CMatrix33 operator*(const CMatrix33 &matrix) const;
-	CVector3 operator*(const CVector3 &vector) const;
-	CMatrix33& operator=(const CMatrix33&);
-	double m11;
-	double m12;
-	double m13;
-	double m21;
-	double m22;
-	double m23;
-	double m31;
-	double m32;
-	double m33;
-};
-
-/************************* rotation matrix *******************/
-class CRotationMatrix
-{
-public:
-	CRotationMatrix();
-	void RotateX(double angle);
-	void RotateY(double angle);
-	void RotateZ(double angle);
-	void Null();
-	CVector3 RotateVector(const CVector3& vector) const;
-	double GetAlfa() const;
-	double GetBeta() const;
-	double GetGamma() const;
-	void SetRotation(double angles[3]);
-	void SetRotation(double alfa, double beta, double gamma);
-	CRotationMatrix Transpose(void) const;
-	CMatrix33 GetMatrix() {return matrix;}
-private:
-	CMatrix33 matrix;
-	bool zero;
-};
-
-#endif /* ALGEBRA_H_ */
diff --git a/src/mandelbulber/common_math.h b/src/mandelbulber/common_math.h
deleted file mode 100644
index e9a9d71..0000000
--- a/src/mandelbulber/common_math.h
+++ /dev/null
@@ -1,51 +0,0 @@
-/*
- * common_math.h
- *
- *  Created on: 2010-01-23
- *      Author: krzysztof marczak
- */
-
-#ifndef COMMON_MATH_H_
-#define COMMON_MATH_H_
-
-#include "algebra.hpp"
-
-struct sVectorsAround
-{
-	double alpha;
-	double beta;
-	CVector3 v;
-	int R;
-	int G;
-	int B;
-	bool notBlack;
-};
-
-struct sVector
-{
-	double x;
-	double y;
-	double z;
-};
-
-struct sSortZ
-{
-	float z;
-	int i;
-};
-
-enum enumPerspectiveType
-{
-	threePoint = 0, fishEye = 1, equirectangular = 2, fishEyeCut = 3
-};
-
-//int abs(int v);
-int Random(int max);
-double dMax(double a, double b, double c);
-double dMin(double a, double b, double c);
-void QuickSortZBuffer(sSortZ *dane, int l, int p);
-CVector3 Projection3D(CVector3 point, CVector3 vp, CRotationMatrix mRot, enumPerspectiveType perspectiveType, double fov, double zoom);
-inline double SmoothConditionAGreaterB(double a, double b, double sharpness) {return 1.0 / (1.0 + exp(sharpness * (b - a)));}
-inline double SmoothConditionALessB(double a, double b, double sharpness) {return 1.0 / (1.0 + exp(sharpness * (a - b)));}
-
-#endif /* COMMON_MATH_H_ */
diff --git a/src/mandelbulber/fractal.cpp b/src/mandelbulber/fractal.cpp
deleted file mode 100644
index 079cc74..0000000
--- a/src/mandelbulber/fractal.cpp
+++ /dev/null
@@ -1,1502 +0,0 @@
-/********************************************************
- /                   MANDELBULBER                        *
- /                                                       *
- / author: Krzysztof Marczak                             *
- / contact: buddhi1980@gmail.com                         *
- / licence: GNU GPL                                      *
- ********************************************************/
-
-/*
- * fractal.cpp
- *
- *  Created on: 2010-01-23
- *      Author: krzysztof
- */
-
-//#include "Render3D.h"
-//#include "interface.h"
-//#include "primitives.h"
-#include <stdlib.h>
-
-#include "fractal.h"
-#include "algebra.cpp"
-
-/**
- * Compute the fractal at the point, in one of the various modes
- *
- * Mode: normal: Returns distance
- *		 fake_ao: Returns minimum radius
- *		 colouring: Returns colour index
- *		 delta_DE1, delta_DE2: Returns radius
- */
-
-unsigned int MixNumbers(double a, double b, double c)
-{
-	unsigned int result = int(a*12356312.0)^int(b*23564234.0)^int(c*35564353.0);
-	//printf("%ud\n", result);
-	return result;
-}
-
-int Noise(int seed)
-{
-	int x = seed;
-	x = (x<<7) ^ x;
-	return abs((x * (x * x * 15731 + 789221) + 1376312589) & 0x7fffffff);
-}
-
-
-template<int Mode>
-double Compute(CVector3 z, const sFractal &par, int *iter_count)
-{
-	int L;
-	double distance = 0;
-
-	double w = 0;
-	double constantw = 0;
-
-	CVector3 dz(1.0, 0.0, 0.0);
-	CVector3 one(1.0, 0.0, 0.0);
-	double r_dz = 1;
-	double ph_dz = 0;
-	double th_dz = 0;
-	double p = par.doubles.power; //mandelbulb power
-	int N = par.doubles.N;
-
-	CVector3 constant;
-
-	double fixedRadius = par.mandelbox.doubles.foldingSphericalFixed;
-	double fR2 = fixedRadius * fixedRadius;
-	double minRadius = par.mandelbox.doubles.foldingSphericalMin;
-	double mR2 = minRadius * minRadius;
-	double tglad_factor1 = fR2 / mR2;
-
-	double tgladDE = 1.0;
-
-	double scale = par.mandelbox.doubles.scale;
-
-	enumFractalFormula actualFormula = par.formula;
-	if (actualFormula == kaleidoscopic || actualFormula == menger_sponge) 
-		tgladDE = 1.0;
-
-	double tgladColor = 1.0;
-
-	if (par.juliaMode)
-	{
-		constant = par.doubles.julia;
-	}
-	else
-	{
-		constant = z * par.doubles.constantFactor;
-	}
-
-	bool hybridEnabled = false;
-	if (actualFormula == hybrid) hybridEnabled = true;
-
-	double r = z.Length();
-
-	double min = 1e200;
-	for (L = 0; L < N; L++)
-	{
-		if (hybridEnabled)
-		{
-			int tempL = L;
-			if(tempL > (int)par.formulaSequence.size()-1) tempL = (int)par.formulaSequence.size()-1;
-			actualFormula = par.formulaSequence[tempL];
-			p = par.hybridPowerSequence[tempL];
-			scale = p;
-		}
-
-		if (par.IFS.foldingMode)
-		{
-			if (par.IFS.absX) z.x = fabs(z.x);
-			if (par.IFS.absY) z.y = fabs(z.y);
-			if (par.IFS.absZ) z.z = fabs(z.z);
-
-			for (int i = 0; i < IFS_VECTOR_COUNT; i++)
-			{
-				if (par.IFS.enabled[i])
-				{
-					z = par.IFS.rot[i].RotateVector(z);
-					double length = z.Dot(par.IFS.doubles.direction[i]);
-
-					if (length < par.IFS.doubles.distance[i])
-					{
-						z -= par.IFS.doubles.direction[i] * 2.0 * (length - par.IFS.doubles.distance[i]);
-					}
-
-				}
-			}
-
-			z = par.IFS.mainRot.RotateVector(z - par.IFS.doubles.offset) + par.IFS.doubles.offset;
-			z *= par.IFS.doubles.scale;
-			z -= par.IFS.doubles.offset * (par.IFS.doubles.scale - 1.0);
-
-			r = z.Length();
-		}
-
-		if (par.tgladFoldingMode)
-		{
-			if (z.x > par.doubles.foldingLimit)
-			{
-				z.x = par.doubles.foldingValue - z.x;
-				tgladColor *= 0.9;
-			}
-			else if (z.x < -par.doubles.foldingLimit)
-			{
-				z.x = -par.doubles.foldingValue - z.x;
-				tgladColor *= 0.9;
-			}
-			if (z.y > par.doubles.foldingLimit)
-			{
-				z.y = par.doubles.foldingValue - z.y;
-				tgladColor *= 0.9;
-			}
-			else if (z.y < -par.doubles.foldingLimit)
-			{
-				z.y = -par.doubles.foldingValue - z.y;
-				tgladColor *= 0.9;
-			}
-			if (z.z > par.doubles.foldingLimit)
-			{
-				z.z = par.doubles.foldingValue - z.z;
-				tgladColor *= 0.9;
-			}
-			else if (z.z < -par.doubles.foldingLimit)
-			{
-				z.z = -par.doubles.foldingValue - z.z;
-				tgladColor *= 0.9;
-			}
-			r = z.Length();
-		}
-
-		if (par.sphericalFoldingMode)
-		{
-			double fR2_2 = par.doubles.foldingSphericalFixed * par.doubles.foldingSphericalFixed;
-			double mR2_2 = par.doubles.foldingSphericalMin * par.doubles.foldingSphericalMin;
-			double r2_2 = r * r;
-			double tglad_factor1_2 = fR2_2 / mR2_2;
-
-			if (r2_2 < mR2_2)
-			{
-				z = z * tglad_factor1_2;
-				tgladDE *= tglad_factor1_2;
-				tgladColor += 1;
-			}
-			else if (r2_2 < fR2_2)
-			{
-				double tglad_factor2_2 = fR2_2 / r2_2;
-				z = z * tglad_factor2_2;
-				tgladDE *= tglad_factor2_2;
-				tgladColor += 10;
-			}
-			r = z.Length();
-		}
-
-		switch (actualFormula)
-		{
-			case trig_DE:
-			{
-				double r1 = pow(r, p - 1);
-				double r2 = r1 * r;
-				double th = z.GetAlfa();
-				double ph = -z.GetBeta();
-				if (Mode == 0)
-				{
-					double p_r1_rdz = p * r1 * r_dz;
-					double ph_phdz = (p - 1.0) * ph + ph_dz;
-					double th_thdz = (p - 1.0) * th + th_dz;
-					CVector3 rot(th_thdz, ph_phdz);
-					dz = rot * p_r1_rdz + one;
-					r_dz = dz.Length();
-					th_dz = dz.GetAlfa();
-					ph_dz = -dz.GetBeta();
-				}
-				CVector3 rot(p * th, p * ph);
-				z = rot * r2 + constant;
-				r = z.Length();
-				break;
-			}
-			case trig_optim:
-			{
-				//optimisation based on: http://www.fractalforums.com/mandelbulb-implementation/realtime-renderingoptimisations/
-				double th0 = asin(z.z / r);
-				double ph0 = atan2(z.y, z.x);
-				double rp = pow(r, p - 1.0);
-				double th = th0 * p;
-				double ph = ph0 * p;
-				double cth = cos(th);
-				r_dz = rp * r_dz * p + 1.0;
-				rp *= r;
-				z = CVector3(cth * cos(ph), cth * sin(ph), sin(th)) * rp + constant;
-				r = z.Length();
-				break;
-			}
-			case mandelbulb2:
-			{
-				double temp, tempR;
-				tempR = sqrt(z.x * z.x + z.y * z.y);
-				z *= (1.0 / tempR);
-				temp = z.x * z.x - z.y * z.y;
-				z.y = 2.0 * z.x * z.y;
-				z.x = temp;
-				z *= tempR;
-
-				tempR = sqrt(z.y * z.y + z.z * z.z);
-				z *= (1.0 / tempR);
-				temp = z.y * z.y - z.z * z.z;
-				z.z = 2.0 * z.y * z.z;
-				z.y = temp;
-				z *= tempR;
-
-				tempR = sqrt(z.x * z.x + z.z * z.z);
-				z *= (1.0 / tempR);
-				temp = z.x * z.x - z.z * z.z;
-				z.z = 2.0 * z.x * z.z;
-				z.x = temp;
-				z *= tempR;
-
-				z = z * r;
-				z += constant;
-				r = z.Length();
-				break;
-			}
-			case mandelbulb3:
-			{
-				double temp, tempR;
-
-				double sign = 1.0;
-				double sign2 = 1.0;
-
-				if (z.x < 0) sign2 = -1.0;
-				tempR = sqrt(z.x * z.x + z.y * z.y);
-				z *= (1.0 / tempR);
-				temp = z.x * z.x - z.y * z.y;
-				z.y = 2.0 * z.x * z.y;
-				z.x = temp;
-				z *= tempR;
-
-				if (z.x < 0) sign = -1.0;
-				tempR = sqrt(z.x * z.x + z.z * z.z);
-				z *= (1.0 / tempR);
-				temp = z.x * z.x - z.z * z.z;
-				z.z = 2.0 * z.x * z.z * sign2;
-				z.x = temp * sign;
-				z *= tempR;
-
-				z = z * r;
-				z += constant;
-				r = z.Length();
-				break;
-			}
-			case mandelbulb4:
-			{
-				double rp = pow(r, p - 1);
-
-				double angZ = atan2(z.y, z.x);
-				double angY = atan2(z.z, z.x);
-				double angX = atan2(z.z, z.y);
-
-				CRotationMatrix rotM;
-				rotM.RotateX(angX * (p - 1));
-				rotM.RotateY(angY * (p - 1));
-				rotM.RotateZ(angZ * (p - 1));
-
-				z = rotM.RotateVector(z) * rp + constant;
-				r = z.Length();
-				break;
-			}
-			case xenodreambuie:
-			{
-				double rp = pow(r, p);
-				double th = atan2(z.y, z.x);
-				double ph = acos(z.z / r);
-				if (ph > 0.5 * M_PI)
-				{
-					ph = M_PI - ph;
-				}
-				else if (ph < -0.5 * M_PI)
-				{
-					ph = -M_PI - ph;
-				}
-				z.x = rp * cos(th * p) * sin(ph * p);
-				z.y = rp * sin(th * p) * sin(ph * p);
-				z.z = rp * cos(ph * p);
-				z = z + constant;
-
-				r = z.Length();
-				break;
-			}
-			case fast_trig:
-			{
-				double x2 = z.x * z.x;
-				double y2 = z.y * z.y;
-				double z2 = z.z * z.z;
-				double temp = 1.0 - z2 / (x2 + y2);
-				double newx = (x2 - y2) * temp;
-				double newy = 2.0 * z.x * z.y * temp;
-				double newz = -2.0 * z.z * sqrt(x2 + y2);
-				z.x = newx + constant.x;
-				z.y = newy + constant.y;
-				z.z = newz + constant.z;
-				r = z.Length();
-				break;
-			}
-			case minus_fast_trig:
-			{
-				double x2 = z.x * z.x;
-				double y2 = z.y * z.y;
-				double z2 = z.z * z.z;
-				double temp = 1.0 - z2 / (x2 + y2);
-				double newx = (x2 - y2) * temp;
-				double newy = 2.0 * z.x * z.y * temp;
-				double newz = 2.0 * z.z * sqrt(x2 + y2);
-				z.x = newx + constant.x;
-				z.y = newy + constant.y;
-				z.z = newz + constant.z;
-				r = z.Length();
-				break;
-			}
-			case hypercomplex:
-			{
-				CVector3 newz(z.x * z.x - z.y * z.y - z.z * z.z - w * w, 2.0 * z.x * z.y - 2.0 * w * z.z, 2.0 * z.x * z.z - 2.0 * z.y * w);
-				double neww = 2.0 * z.x * w - 2.0 * z.y * z.z;
-				z = newz + constant;
-				w = neww;
-				r = sqrt(z.x * z.x + z.y * z.y + z.z * z.z + w * w);
-				break;
-			}
-			case quaternion:
-			{
-				CVector3 newz(z.x * z.x - z.y * z.y - z.z * z.z - w * w, 2.0 * z.x * z.y, 2.0 * z.x * z.z);
-				double neww = 2.0 * z.x * w;
-				z = newz + constant;
-				w = neww;
-				r = sqrt(z.x * z.x + z.y * z.y + z.z * z.z + w * w);
-				break;
-			}
-			case menger_sponge:
-			{
-				double temp;
-				z.x = fabs(z.x);
-				z.y = fabs(z.y);
-				z.z = fabs(z.z);
-				if (z.x - z.y < 0)
-				{
-					temp = z.y;
-					z.y = z.x;
-					z.x = temp;
-				}
-				if (z.x - z.z < 0)
-				{
-					temp = z.z;
-					z.z = z.x;
-					z.x = temp;
-				}
-				if (z.y - z.z < 0)
-				{
-					temp = z.z;
-					z.z = z.y;
-					z.y = temp;
-				}
-
-				if (Mode == colouring)
-				{
-					double length2 = z.Length();
-					if (length2 < min) min = length2;
-				}
-
-				z *= 3.0;
-
-				z.x -= 2.0;
-				z.y -= 2.0;
-				if (z.z > 1.0) z.z -= 2.0;
-				r = z.Length();
-				tgladDE *= 3.0;
-				break;
-			}
-			case tglad:
-			{
-				if (par.mandelbox.rotationsEnabled)
-				{
-					bool lockout = false;
-					z = par.mandelbox.rot[0][0].RotateVector(z);
-					if (z.x > par.mandelbox.doubles.foldingLimit)
-					{
-						z.x = par.mandelbox.doubles.foldingValue - z.x;
-						tgladColor += par.mandelbox.doubles.colorFactorX;
-						lockout = true;
-					}
-					z = par.mandelbox.rotinv[0][0].RotateVector(z);
-
-					z = par.mandelbox.rot[1][0].RotateVector(z);
-					if (!lockout && z.x < -par.mandelbox.doubles.foldingLimit)
-					{
-						z.x = -par.mandelbox.doubles.foldingValue - z.x;
-						tgladColor += par.mandelbox.doubles.colorFactorX;
-					}
-					z = par.mandelbox.rotinv[1][0].RotateVector(z);
-
-					lockout = false;
-					z = par.mandelbox.rot[0][1].RotateVector(z);
-					if (z.y > par.mandelbox.doubles.foldingLimit)
-					{
-						z.y = par.mandelbox.doubles.foldingValue - z.y;
-						tgladColor += par.mandelbox.doubles.colorFactorY;
-						lockout = true;
-					}
-					z = par.mandelbox.rotinv[0][1].RotateVector(z);
-
-					z = par.mandelbox.rot[1][1].RotateVector(z);
-					if (!lockout && z.y < -par.mandelbox.doubles.foldingLimit)
-					{
-						z.y = -par.mandelbox.doubles.foldingValue - z.y;
-						tgladColor += par.mandelbox.doubles.colorFactorY;
-					}
-					z = par.mandelbox.rotinv[1][1].RotateVector(z);
-
-					lockout = false;
-					z = par.mandelbox.rot[0][2].RotateVector(z);
-					if (z.z > par.mandelbox.doubles.foldingLimit)
-					{
-						z.z = par.mandelbox.doubles.foldingValue - z.z;
-						tgladColor += par.mandelbox.doubles.colorFactorZ;
-						lockout = true;
-					}
-					z = par.mandelbox.rotinv[0][2].RotateVector(z);
-
-					z = par.mandelbox.rot[1][2].RotateVector(z);
-					if (!lockout && z.z < -par.mandelbox.doubles.foldingLimit)
-					{
-						z.z = -par.mandelbox.doubles.foldingValue - z.z;
-						tgladColor += par.mandelbox.doubles.colorFactorZ;
-					}
-					z = par.mandelbox.rotinv[1][2].RotateVector(z);
-				}
-				else
-				{
-					if (z.x > par.mandelbox.doubles.foldingLimit)
-					{
-						z.x = par.mandelbox.doubles.foldingValue - z.x;
-						tgladColor += par.mandelbox.doubles.colorFactorX;
-					}
-					else if (z.x < -par.mandelbox.doubles.foldingLimit)
-					{
-						z.x = -par.mandelbox.doubles.foldingValue - z.x;
-						tgladColor += par.mandelbox.doubles.colorFactorX;
-					}
-					if (z.y > par.mandelbox.doubles.foldingLimit)
-					{
-						z.y = par.mandelbox.doubles.foldingValue - z.y;
-						tgladColor += par.mandelbox.doubles.colorFactorY;
-					}
-					else if (z.y < -par.mandelbox.doubles.foldingLimit)
-					{
-						z.y = -par.mandelbox.doubles.foldingValue - z.y;
-						tgladColor += par.mandelbox.doubles.colorFactorY;
-					}
-					if (z.z > par.mandelbox.doubles.foldingLimit)
-					{
-						z.z = par.mandelbox.doubles.foldingValue - z.z;
-						tgladColor += par.mandelbox.doubles.colorFactorZ;
-					}
-					else if (z.z < -par.mandelbox.doubles.foldingLimit)
-					{
-						z.z = -par.mandelbox.doubles.foldingValue - z.z;
-						tgladColor += par.mandelbox.doubles.colorFactorZ;
-					}
-				}
-
-				r = z.Length();
-				double r2 = r * r;
-
-				z += par.mandelbox.doubles.offset;
-
-				if (r2 < mR2)
-				{
-					z *= tglad_factor1;
-					tgladDE *= tglad_factor1;
-					tgladColor += par.mandelbox.doubles.colorFactorSp1;
-				}
-				else if (r2 < fR2)
-				{
-					double tglad_factor2 = fR2 / r2;
-					z *= tglad_factor2;
-					tgladDE *= tglad_factor2;
-					tgladColor += par.mandelbox.doubles.colorFactorSp2;
-				}
-
-				z -= par.mandelbox.doubles.offset;
-
-				z = par.mandelbox.mainRot.RotateVector(z);
-
-				z = z * scale + constant;
-				tgladDE = tgladDE*fabs(scale)+1.0;
-
-				r = z.Length();
-				break;
-			}
-
-			case generalizedFoldBox:
-			{
-				//Reference: http://www.fractalforums.com/new-theories-and-research/generalized-box-fold/msg36503/#msg36503
-
-				int i;
-				const CVector3 *Nv;
-				int sides;
-
-				Nv = par.genFoldBox.Nv_tet;
-				sides = par.genFoldBox.sides_tet;
-
-				if (par.genFoldBox.type == foldCube)
-				{
-					Nv = par.genFoldBox.Nv_cube;
-					sides = par.genFoldBox.sides_cube;
-				}
-				else if (par.genFoldBox.type == foldOct)
-				{
-					Nv = par.genFoldBox.Nv_oct;
-					sides = par.genFoldBox.sides_oct;
-				}
-				else if (par.genFoldBox.type == foldDodeca)
-				{
-					Nv = par.genFoldBox.Nv_dodeca;
-					sides = par.genFoldBox.sides_dodeca;
-				}
-				else if (par.genFoldBox.type == foldOctCube)
-				{
-					Nv = par.genFoldBox.Nv_oct_cube;
-					sides = par.genFoldBox.sides_oct_cube;
-				}
-				else if (par.genFoldBox.type == foldIcosa)
-				{
-					Nv = par.genFoldBox.Nv_icosa;
-					sides = par.genFoldBox.sides_icosa;
-				}
-				else if (par.genFoldBox.type == foldBox6)
-				{
-					Nv = par.genFoldBox.Nv_box6;
-					sides = par.genFoldBox.sides_box6;
-				}
-				else if (par.genFoldBox.type == foldBox5)
-				{
-					Nv = par.genFoldBox.Nv_box5;
-					sides = par.genFoldBox.sides_box5;
-				}
-
-        double melt = par.mandelbox.doubles.melt;
-        double solid = par.mandelbox.doubles.solid;
-
-				// Find the closest cutting plane if any that cuts the line between the origin and z.
-				// Line is parameterized as X = Y + L*a;
-				// Cutting plane is X.Dot(Nv) = Solid.
-				// (Y + L*a).Dot(Nv) = solid.
-				// a = (solid - Y.Dot(Nv))/L.Dot(Nv) = b/c
-				CVector3 L = z;
-				double a = 1;
-				CVector3 Y; // Y is the origin in this case.
-				int side = -1;
-				double b, c;
-
-				for (i = 0; i < sides; i++)
-				{
-					b = solid;
-					c = L.Dot(Nv[i]);
-					// A bit subtile here. a_r must be positive and I want to avoid divide by zero.
-					if ((c > 0) && ((a * c) > b))
-					{
-						side = i;
-						a = b / c;
-					}
-				}
-
-				// If z is above the foldingValue we may have to fold. Else early out.
-				if (side != -1)
-				{ // mirror check
-					int side_m = side;
-					CVector3 Nv_m = Nv[side_m];
-					CVector3 X_m = z - Nv_m * (z.Dot(Nv_m) - solid);
-
-					// Find any plane (Nv_r) closest to X_m that cuts the line between Nv_m and X_m.
-					// Nv_m cross Nv_r will define a possible rotation axis.
-					// a = (solid - Y.Dot(Nv)/L.Dot(Nv) = b/c.
-					L = X_m - Nv_m;
-					Y = Nv_m;
-					a = 1;
-					side = -1;
-
-					for (i = 0; i < sides; i++)
-					{
-						if (i != side_m)
-						{
-							b = solid - Y.Dot(Nv[i]);
-							c = L.Dot(Nv[i]);
-							// A bit subtile here. a_r must be positive and I want to avoid divide by zero.
-							if ((c > 0) && ((a * c) > b))
-							{
-								side = i;
-								a = b / c;
-							}
-						}
-					}
-
-					// Was a cutting plane found?
-					if (side != -1)
-					{ // rotation check
-						CVector3 Xmr_intersect = Y + L * a;
-						int side_r = side;
-						CVector3 Nv_r = Nv[side_r];
-						// The axis of rotation is define by the cross product of Nv_m and Nv_r and
-						// the intersection of the line between Nv_m and Nv_r and  Xmr_intersect.
-						CVector3 L_r = Nv_m.Cross(Nv_r);
-						// The closest point betwee z and the line of rotation can be found by minimizing
-						// the square of the distance (D) between z and the line
-						// X = Xmr_intersect + L_r * a_rmin.
-						// Setting dD/da_rmin equal to zero and solving for a_rmin.
-						double a_rmin = (z.Dot(L_r) - Xmr_intersect.Dot(L_r)) / (L_r.Dot(L_r));
-
-						// force a_rmin to be positive. I think I made an even number of sign errors here.
-						if (a_rmin < 0)
-						{
-							a_rmin = -a_rmin;
-							L_r = L_r * (-1);
-						}
-						CVector3 X_r = Xmr_intersect + L_r * a_rmin;
-
-						// Find any plane (Nv_i) closest to Xmr_intersect that cuts the line between
-						// Xmr_intersect and X_r. This will define a possible inversion point.
-						// a = (solid - Y.Dot(Nv)/L.Dot(Nv) = b/c.
-						L = X_r - Xmr_intersect;
-						Y = Xmr_intersect;
-						a = 1;
-						side = -1;
-
-						for (i = 0; i < sides; i++)
-						{
-							if ((i != side_m) && (i != side_r))
-							{
-								b = solid - Y.Dot(Nv[i]);
-								c = L.Dot(Nv[i]);
-								// A bit subtile here. a must be positive and I want to avoid divide by zero.
-								if ((c > 0) && ((a * c) > b))
-								{
-									side = i;
-									a = b / c;
-								}
-							}
-						}
-
-						if (side != -1)
-						{ // inversion check
-							// Only inversion point possible but still need to check for melt.
-
-							CVector3 X_i = Y + L * a;
-							CVector3 z2X = X_i - z;
-							// Is z above the melt layer.
-							if (z2X.Dot(z2X) > (melt * melt))
-							{
-								double z2X_mag = z2X.Length();
-								z = z + z2X * (2 * (z2X_mag - melt) / (z2X_mag + .00000001));
-								tgladColor += par.mandelbox.doubles.colorFactorZ;
-							}
-						}
-						else
-						{
-							// Only rotation line possible but still need to check for melt.
-							// Is z above the melt layer.
-							CVector3 z2X = X_r - z;
-							if (z2X.Dot(z2X) > (melt * melt))
-							{
-								double z2X_mag = z2X.Length();
-								z = z + z2X * (2 * (z2X_mag - melt) / (z2X_mag + .00000001));
-								tgladColor += par.mandelbox.doubles.colorFactorY;
-							}
-						}
-
-					}
-					else
-					{
-						// Only mirror plane possible but still need to check for melt.
-						CVector3 z2X = X_m - z;
-						if (z2X.Dot(z2X) > (melt * melt))
-						{
-							double z2X_mag = z2X.Length();
-							z = z + z2X * (2 * (z2X_mag - melt) / (z2X_mag + .00000001));
-							tgladColor += par.mandelbox.doubles.colorFactorX;
-						}
-					}
-				} // outside solid
-
-				r = z.Length();
-				double r2 = r * r;
-
-				z += par.mandelbox.doubles.offset;
-
-				if (r2 < mR2)
-				{
-					z *= tglad_factor1;
-					tgladDE *= tglad_factor1;
-					tgladColor += par.mandelbox.doubles.colorFactorSp1;
-				}
-				else if (r2 < fR2)
-				{
-					double tglad_factor2 = fR2 / r2;
-					z *= tglad_factor2;
-					tgladDE *= tglad_factor2;
-					tgladColor += par.mandelbox.doubles.colorFactorSp2;
-				}
-
-				z -= par.mandelbox.doubles.offset;
-
-				z = par.mandelbox.mainRot.RotateVector(z);
-
-				z = z * scale + constant;
-				tgladDE = tgladDE * fabs(scale) + 1.0;
-
-				r = z.Length();
-				break;
-			}
-
-			case smoothMandelbox:
-			{
-				double sm = par.mandelbox.doubles.sharpness;
-
-				double zk1 = SmoothConditionAGreaterB(z.x, par.mandelbox.doubles.foldingLimit,sm);
-				double zk2 = SmoothConditionALessB(z.x, -par.mandelbox.doubles.foldingLimit,sm);
-				z.x = z.x * (1.0 - zk1) + (par.mandelbox.doubles.foldingValue - z.x) * zk1;
-				z.x = z.x * (1.0 - zk2) + (-par.mandelbox.doubles.foldingValue - z.x) * zk2;
-				tgladColor += (zk1 + zk2) * par.mandelbox.doubles.colorFactorX;
-
-				double zk3 = SmoothConditionAGreaterB(z.y, par.mandelbox.doubles.foldingLimit,sm);
-				double zk4 = SmoothConditionALessB(z.y, -par.mandelbox.doubles.foldingLimit,sm);
-				z.y = z.y * (1.0 - zk3) + (par.mandelbox.doubles.foldingValue - z.y) * zk3;
-				z.y = z.y * (1.0 - zk4) + (-par.mandelbox.doubles.foldingValue - z.y) * zk4;
-				tgladColor += (zk3 + zk4) * par.mandelbox.doubles.colorFactorY;
-
-				double zk5 = SmoothConditionAGreaterB(z.z, par.mandelbox.doubles.foldingLimit,sm);
-				double zk6 = SmoothConditionALessB(z.z, -par.mandelbox.doubles.foldingLimit,sm);
-				z.z = z.z * (1.0 - zk5) + (par.mandelbox.doubles.foldingValue - z.z) * zk5;
-				z.z = z.z * (1.0 - zk6) + (-par.mandelbox.doubles.foldingValue - z.z) * zk6;
-				tgladColor += (zk5 + zk6) * par.mandelbox.doubles.colorFactorZ;
-
-				r = z.Length();
-				double r2 = r * r;
-				double tglad_factor2 = fR2 / r2;
-				double rk1 = SmoothConditionALessB(r2, mR2, sm);
-				double rk2 = SmoothConditionALessB(r2, fR2, sm);
-				double rk21 = (1.0 - rk1) * rk2;
-
-				z = z * (1.0 - rk1) + z * (tglad_factor1 * rk1);
-				z = z * (1.0 - rk21) + z * (tglad_factor2 * rk21);
-				tgladDE = tgladDE * (1.0 - rk1) + tgladDE * (tglad_factor1 * rk1);
-				tgladDE = tgladDE * (1.0 - rk21) + tgladDE * (tglad_factor2 * rk21);
-				tgladColor += rk1 * par.mandelbox.doubles.colorFactorSp1;
-				tgladColor += rk21 * par.mandelbox.doubles.colorFactorSp2;
-
-				z = par.mandelbox.mainRot.RotateVector(z);
-				z = z * scale + constant;
-
-				tgladDE = tgladDE * fabs(scale) + 1.0;
-				r = z.Length();
-				break;
-			}
-			case foldingIntPow2:
-			{
-				if (z.x > par.doubles.FoldingIntPowFoldFactor) z.x = par.doubles.FoldingIntPowFoldFactor * 2.0 - z.x;
-				else if (z.x < -par.doubles.FoldingIntPowFoldFactor) z.x = -par.doubles.FoldingIntPowFoldFactor * 2.0 - z.x;
-
-				if (z.y > par.doubles.FoldingIntPowFoldFactor) z.y = par.doubles.FoldingIntPowFoldFactor * 2.0 - z.y;
-				else if (z.y < -par.doubles.FoldingIntPowFoldFactor) z.y = -par.doubles.FoldingIntPowFoldFactor * 2.0 - z.y;
-
-				if (z.z > par.doubles.FoldingIntPowFoldFactor) z.z = par.doubles.FoldingIntPowFoldFactor * 2.0 - z.z;
-				else if (z.z < -par.doubles.FoldingIntPowFoldFactor) z.z = -par.doubles.FoldingIntPowFoldFactor * 2.0 - z.z;
-
-				r = z.Length();
-
-				double fR2_2 = 1.0;
-				double mR2_2 = 0.25;
-				double r2_2 = r * r;
-				double tglad_factor1_2 = fR2_2 / mR2_2;
-
-				if (r2_2 < mR2_2)
-				{
-					z = z * tglad_factor1_2;
-				}
-				else if (r2_2 < fR2_2)
-				{
-					double tglad_factor2_2 = fR2_2 / r2_2;
-					z = z * tglad_factor2_2;
-				}
-
-				z = z * 2.0;
-				double x2 = z.x * z.x;
-				double y2 = z.y * z.y;
-				double z2 = z.z * z.z;
-				double temp = 1.0 - z2 / (x2 + y2);
-				double newx = (x2 - y2) * temp;
-				double newy = 2.0 * z.x * z.y * temp;
-				double newz = -2.0 * z.z * sqrt(x2 + y2);
-				z.x = newx + constant.x;
-				z.y = newy + constant.y;
-				z.z = newz + constant.z;
-				z.z *= par.doubles.FoldingIntPowZfactor;
-				r = z.Length();
-				break;
-			}
-			case kaleidoscopic:
-			{
-
-				if (par.IFS.absX) z.x = fabs(z.x);
-				if (par.IFS.absY) z.y = fabs(z.y);
-				if (par.IFS.absZ) z.z = fabs(z.z);
-
-				for (int i = 0; i < IFS_VECTOR_COUNT; i++)
-				{
-					if (par.IFS.enabled[i])
-					{
-						z = par.IFS.rot[i].RotateVector(z);
-						double length = z.Dot(par.IFS.doubles.direction[i]);
-
-						if (length < par.IFS.doubles.distance[i])
-						{
-							z -= par.IFS.doubles.direction[i] * (2.0 * (length - par.IFS.doubles.distance[i]) * par.IFS.doubles.intensity[i]);
-						}
-
-					}
-				}
-				z = par.IFS.mainRot.RotateVector(z - par.IFS.doubles.offset) + par.IFS.doubles.offset;
-
-				if(par.IFS.doubles.edge.x > 0) z.x = par.IFS.doubles.edge.x - fabs(par.IFS.doubles.edge.x - z.x);
-				if(par.IFS.doubles.edge.y > 0) z.y = par.IFS.doubles.edge.y - fabs(par.IFS.doubles.edge.y - z.y);
-				if(par.IFS.doubles.edge.z > 0) z.z = par.IFS.doubles.edge.z - fabs(par.IFS.doubles.edge.z - z.z);
-
-				if (Mode == colouring)
-				{
-					double length2 = z.Length();
-					if (length2 < min) min = length2;
-				}
-
-				z *= par.IFS.doubles.scale;
-				if(par.IFS.mengerSpongeMode)
-				{
-					z.x -= par.IFS.doubles.offset.x * (par.IFS.doubles.scale - 1.0);
-					z.y -= par.IFS.doubles.offset.y * (par.IFS.doubles.scale - 1.0);
-					if (z.z > 0.5 * par.IFS.doubles.offset.z * (par.IFS.doubles.scale - 1.0)) z.z -= par.IFS.doubles.offset.z * (par.IFS.doubles.scale - 1.0);
-				}
-				else
-				{
-					z -= par.IFS.doubles.offset * (par.IFS.doubles.scale - 1.0);
-				}
-
-				tgladDE *= par.IFS.doubles.scale;
-				r = z.Length();
-
-				break;
-			}
-			case mandelboxVaryScale4D:
-			{
-				scale = scale + par.mandelbox.doubles.vary4D.scaleVary * (fabs(scale) - 1.0);
-				CVector3 oldz = z;
-				z.x = fabs(z.x + par.mandelbox.doubles.vary4D.fold) - fabs(z.x - par.mandelbox.doubles.vary4D.fold) - z.x;
-				z.y = fabs(z.y + par.mandelbox.doubles.vary4D.fold) - fabs(z.y - par.mandelbox.doubles.vary4D.fold) - z.y;
-				z.z = fabs(z.z + par.mandelbox.doubles.vary4D.fold) - fabs(z.z - par.mandelbox.doubles.vary4D.fold) - z.z;
-				w = fabs(w + par.mandelbox.doubles.vary4D.fold) - fabs(w - par.mandelbox.doubles.vary4D.fold) - w;
-				if(z.x != oldz.x) tgladColor += par.mandelbox.doubles.colorFactorX;
-				if(z.y != oldz.y) tgladColor += par.mandelbox.doubles.colorFactorY;
-				if(z.z != oldz.z) tgladColor += par.mandelbox.doubles.colorFactorZ;
-				double rr = pow(z.x * z.x + z.y * z.y + z.z * z.z + w * w, par.mandelbox.doubles.vary4D.rPower);
-				double m = scale;
-				if (rr < par.mandelbox.doubles.vary4D.minR * par.mandelbox.doubles.vary4D.minR)
-				{
-					m = scale / (par.mandelbox.doubles.vary4D.minR * par.mandelbox.doubles.vary4D.minR);
-					tgladColor += par.mandelbox.doubles.colorFactorSp1;
-				}
-				else if (rr < 1.0)
-				{
-					m = scale / rr;
-					tgladColor += par.mandelbox.doubles.colorFactorSp2;
-				}
-				z = z * m + constant;
-				w = w * m + par.mandelbox.doubles.vary4D.wadd;
-				tgladDE = tgladDE * fabs(m) + 1.0;
-				r = sqrt(z.x * z.x + z.y * z.y + z.z * z.z + w * w);
-				break;
-			}
-			case aexion:
-			{
-				if(L == 0)
-				{
-					double cx = fabs(constant.x + constant.y + constant.z) + par.doubles.cadd;
-					double cy = fabs(-constant.x - constant.y + constant.z) + par.doubles.cadd;
-					double cz = fabs(-constant.x + constant.y - constant.z) + par.doubles.cadd;
-					double cw = fabs(constant.x - constant.y - constant.z) + par.doubles.cadd;
-					constant.x = cx;
-					constant.y = cy;
-					constant.z = cz;
-					constantw = cw;
-					double tempx = fabs(z.x + z.y + z.z) + par.doubles.cadd;
-					double tempy = fabs(-z.x - z.y + z.z) + par.doubles.cadd;
-					double tempz = fabs(-z.x + z.y - z.z) + par.doubles.cadd;
-					double tempw = fabs(z.x - z.y - z.z) + par.doubles.cadd;
-					z.x = tempx;
-					z.y = tempy;
-					z.z = tempz;
-					w = tempw;
-				}
-				double tempx = z.x * z.x - z.y * z.y + 2.0 * w * z.z + constant.x;
-				double tempy = z.y * z.y - z.x * z.x + 2.0 * w * z.z + constant.y;
-				double tempz = z.z * z.z - w * w + 2.0 * z.x * z.y + constant.z;
-				double tempw = w * w - z.z * z.z + 2.0 * z.x * z.y + constantw;
-				z.x = tempx;
-				z.y = tempy;
-				z.z = tempz;
-				w = tempw;
-				r = sqrt(z.x * z.x + z.y * z.y + z.z * z.z + w * w);
-				break;
-			}
-			case benesi:
-			{
-				double r1 = z.y*z.y + z.z*z.z;
-				double newx = 0;
-				if(constant.x < 0 || z.x < sqrt(r1))
-				{
-					newx = z.x*z.x - r1;
-				}
-				else
-				{
-					newx = -z.x*z.x + r1;
-				}
-				r1 = - 1.0/sqrt(r1) * 2.0 * fabs(z.x);
-				double newy = r1 * (z.y*z.y - z.z*z.z);
-				double newz = r1 * 2.0 * z.y * z.z;
-
-				z.x = newx + constant.x;
-				z.y = newy + constant.y;
-				z.z = newz + constant.z;
-
-				r = z.Length();
-				break;
-			}
-			case bristorbrot:
-			{
-				double newx = z.x*z.x - z.y*z.y - z.z*z.z;
-				double newy = z.y * (2.0 * z.x - z.z);
-				double newz = z.z * (2.0 * z.x + z.y);
-
-				z.x = newx + constant.x;
-				z.y = newy + constant.y;
-				z.z = newz + constant.z;
-
-				r = z.Length();
-				break;
-			}
-			case invertX:
-			{
-				z.x = z.x >= 0.0 ? z.x*z.x/(fabs(z.x) + p) : -z.x*z.x/(fabs(z.x) + p);
-				r = z.Length();
-				break;
-			}
-			case invertY:
-			{
-				z.y = z.y >= 0.0 ? z.y*z.y/(fabs(z.y) + p) : -z.y*z.y/(fabs(z.y) + p);
-				r = z.Length();
-				break;
-			}
-			case invertZ:
-			{
-				z.z = z.z >= 0.0 ? z.z*z.z/(fabs(z.z) + p) : -z.z*z.z/(fabs(z.z) + p);
-				r = z.Length();
-				break;
-			}
-			case invertR:
-			{
-				double rInv = r*r/(r + p);
-				z.x = z.x / r * rInv;
-				z.y = z.y / r * rInv;
-				z.z = z.z / r * rInv;
-				r = z.Length();
-				break;
-			}
-			case sphericalFold:
-			{
-				double rr = r*r;
-				double pp = p*p;
-				if (rr < pp)
-				{
-					z.x = 1.0 / pp;
-					z.y = 1.0 / pp;
-					z.z = 1.0 / pp;
-				}
-				else if (rr < pp*4.0)
-				{
-					z.x = 1.0 / rr;
-					z.y = 1.0 / rr;
-					z.z = 1.0 / rr;
-				}
-				r = z.Length();
-				break;
-			}
-			case powXYZ:
-			{
-				z.x = z.x >= 0 ? pow(z.x,p) : -pow(-z.x,p);
-				z.y = z.y >= 0 ? pow(z.y,p) : -pow(-z.y,p);
-				z.z = z.z >= 0 ? pow(z.z,p) : -pow(-z.z,p);
-				r = z.Length();
-				break;
-			}
-			case scaleX:
-			{
-				z.x = z.x * p;
-				r = z.Length();
-				break;
-			}
-			case scaleY:
-			{
-				z.y = z.y * p;
-				r = z.Length();
-				break;
-			}
-			case scaleZ:
-			{
-				z.z = z.z * p;
-				r = z.Length();
-				break;
-			}
-			case offsetX:
-			{
-				z.x = z.x + p;
-				r = z.Length();
-				break;
-			}
-			case offsetY:
-			{
-				z.y = z.y + p;
-				r = z.Length();
-				break;
-			}
-			case offsetZ:
-			{
-				z.z = z.z + p;
-				r = z.Length();
-				break;
-			}
-			case angleMultiplyX:
-			{
-				double angle = atan2(z.z,z.y)*p;
-				double tempR = sqrt(z.z*z.z + z.y*z.y);
-				z.y = tempR * cos(angle);
-				z.z = tempR * sin(angle);
-				r = z.Length();
-				break;
-			}
-			case angleMultiplyY:
-			{
-				double angle = atan2(z.z,z.x)*p;
-				double tempR = sqrt(z.z*z.z + z.x*z.x);
-				z.x = tempR * cos(angle);
-				z.z = tempR * sin(angle);
-				r = z.Length();
-				break;
-			}
-			case angleMultiplyZ:
-			{
-				double angle = atan2(z.y,z.x)*p;
-				double tempR = sqrt(z.x*z.x + z.y*z.y);
-				z.x = tempR * cos(angle);
-				z.y = tempR * sin(angle);
-				r = z.Length();
-				break;
-			}
-			case hybrid:
-				break;
-			case none:
-				break;
-		}
-
-		//************************** iteration terminate conditions *****************
-		if (Mode == deltaDE1)
-		{
-			if (r > 1e10)
-				break;
-		}
-		else if (Mode == deltaDE2)
-		{
-			if (L == *iter_count)
-				break;
-		}
-
-		if (Mode == orbitTrap)
-		{
-			CVector3 delta = z - par.doubles.fakeLightsOrbitTrap;
-			distance = delta.Length();
-			if (L >= par.fakeLightsMinIter && L <= par.fakeLightsMaxIter && distance < min) min = distance;
-			if (distance > 1000)
-			{
-				distance = min;
-				break;
-			}
-		}
-
-		if (actualFormula == menger_sponge || actualFormula == kaleidoscopic)
-		{
-			if (r > 1000)
-			{
-				distance = (r - 2.0) / tgladDE;
-				break;
-			}
-		}
-		else if (actualFormula == tglad || actualFormula == smoothMandelbox || actualFormula == mandelboxVaryScale4D || actualFormula == generalizedFoldBox)
-		{
-			if (r > 1024)
-			{
-				distance = r / fabs(tgladDE);
-				break;
-			}
-		}
-		else
-		{
-			if (Mode == normal) //condition for all other trigonometric and hypercomplex fractals
-			{
-				if (r > 1e2)
-				{
-					distance = 0.5 * r * log(r) / r_dz;
-					break;
-				}
-			}
-			else if (Mode == fake_AO) //mode 2
-			{
-				if (r < min) min = r;
-				if (r > 1e15)
-				{
-					distance = min;
-					break;
-				}
-			}
-			else if (Mode == colouring) //mode 1
-			{
-				if(par.primitives.onlyPlane)
-				{
-					distance = z.Length();
-					if (distance > 1e15)
-					{
-						distance = (L - log(log(r) / log(N)) / log(p))/100.0;
-						break;
-					}
-				}
-				else
-				{
-					distance = z.Length();
-					if (distance < min) min = distance;
-					if (distance > 1e15)
-					{
-						distance = min;
-						break;
-					}
-				}
-			}
-		}
-	}
-
-	//************ return values *****************
-
-/*
-	N_counter += L + 1;
-	Loop_counter++;
-
-	if (L < 64)
-		histogram[L]++;
-	else
-		histogram[63]++;
-*/
-
-	if (iter_count != NULL)
-		*iter_count = L;
-
-	if (Mode == normal)
-	{
-		if (L == N)
-			distance = 0;
-		return distance;
-	}
-
-	if (Mode == deltaDE1 || Mode == deltaDE2)
-		return r;
-
-	if (Mode == fake_AO)
-		return distance;
-
-	if (Mode == orbitTrap)
-		return distance;
-
-	if (Mode == colouring)
-	{
-		if (par.formula == hybrid)
-		{
-			if (min > 100) 
-				min = 100;
-			if (distance > 20) 
-				distance = 20;
-			if (tgladColor > 1000) 
-				tgladColor = 1000;
-
-			return distance * 5000.0 + tgladColor * 100.0 + min * 1000.0;
-		} 
-		else if (actualFormula == tglad || actualFormula == smoothMandelbox || actualFormula == mandelboxVaryScale4D || actualFormula == generalizedFoldBox)
-			return tgladColor * 100.0 + z.Length()*par.mandelbox.doubles.colorFactorR;
-		else if (actualFormula == kaleidoscopic || actualFormula == menger_sponge)
-			return min * 1000.0;
-		else
-			return distance * 5000.0;
-	}
-}
-
-#if 0
-//******************* Calculate distance *******************8
-
-double CalculateDistance(CVector3 point, sFractal &params, bool *max_iter)
-{
-	int L;
-	double distance;
-	params.objectOut = objFractal;
-
-	if (params.limits_enabled)
-	{
-		bool limit = false;
-		double distance_a = 0;
-		double distance_b = 0;
-		double distance_c = 0;
-
-		if (point.x < params.doubles.amin - params.doubles.detailSize)
-		{
-			distance_a = fabs(params.doubles.amin - point.x);
-			limit = true;
-		}
-		if (point.x > params.doubles.amax + params.doubles.detailSize)
-		{
-			distance_a = fabs(params.doubles.amax - point.x);
-			limit = true;
-		}
-
-		if (point.y < params.doubles.bmin - params.doubles.detailSize)
-		{
-			distance_a = fabs(params.doubles.bmin - point.y);
-			limit = true;
-		}
-		if (point.y > params.doubles.bmax + params.doubles.detailSize)
-		{
-			distance_b = fabs(params.doubles.bmax - point.y);
-			limit = true;
-		}
-
-		if (point.z < params.doubles.cmin - params.doubles.detailSize)
-		{
-			distance_c = fabs(params.doubles.cmin - point.z);
-			limit = true;
-		}
-		if (point.z > params.doubles.cmax + params.doubles.detailSize)
-		{
-			distance_c = fabs(params.doubles.cmax - point.z);
-			limit = true;
-		}
-
-		if (limit)
-		{
-			if (max_iter != NULL)
-				*max_iter = false;
-			distance = dMax(distance_a, distance_b, distance_c);
-			return distance;
-		}
-	}
-
-	if(!params.primitives.onlyPlane)
-	{
-		if (params.analitycDE)
-		{
-			distance = Compute<normal>(point, params, &L);
-			if (max_iter != NULL)
-			{
-				if (L == (int)params.doubles.N) *max_iter = true;
-				else *max_iter = false;
-			}
-			params.itersOut = L;
-
-			if (L < params.minN && distance < params.doubles.detailSize) distance = params.doubles.detailSize;
-
-			if (params.interiorMode)
-			{
-				if (distance < 0.5 * params.doubles.detailSize || L == (int)params.doubles.N)
-				{
-					distance = params.doubles.detailSize;
-					if (max_iter != NULL) *max_iter = false;
-				}
-			}
-			if (params.iterThresh)
-			{
-				if(distance < params.doubles.detailSize)
-				{
-					distance = params.doubles.detailSize * 1.01;
-				}
-			}
-		}
-		else
-		{
-			double deltaDE = 1e-10;
-
-			double r = Compute<deltaDE1>(point, params, &L);
-			int retval = L;
-			params.itersOut = L;
-
-			point.x += deltaDE;
-			point.y += 0;
-			point.z += 0;
-			double r2 = Compute<deltaDE2>(point, params, &L);
-			double dr1 = fabs(r2 - r) / deltaDE;
-
-			point.x -= deltaDE;
-			point.y += deltaDE;
-			point.z += 0;
-			r2 = Compute<deltaDE2>(point, params, &L);
-			double dr2 = fabs(r2 - r) / deltaDE;
-
-			point.x += 0;
-			point.y -= deltaDE;
-			point.z += deltaDE;
-			r2 = Compute<deltaDE2>(point, params, &L);
-			double dr3 = fabs(r2 - r) / deltaDE;
-
-			double dr = sqrt(dr1 * dr1 + dr2 * dr2 + dr3 * dr3);
-
-			if (params.linearDEmode)
-			{
-				distance = 0.5 * r / dr;
-			}
-			else
-			{
-				distance = 0.5 * r * log(r) / dr;
-			}
-
-			if (retval == (int)params.doubles.N)
-			{
-				if (max_iter != NULL) *max_iter = true;
-				distance = 0;
-			}
-			else if (max_iter != NULL) *max_iter = false;
-
-			if (L < params.minN && distance < params.doubles.detailSize) distance = params.doubles.detailSize;
-
-			if (params.interiorMode)
-			{
-				if (distance < 0.5 * params.doubles.detailSize || retval == 256)
-				{
-					distance = params.doubles.detailSize;
-					if (max_iter != NULL) *max_iter = false;
-				}
-			}
-
-			if (params.iterThresh)
-			{
-				if(distance < params.doubles.detailSize)
-				{
-					distance = params.doubles.detailSize * 1.01;
-				}
-			}
-
-		}
-	}
-	else
-	{
-		distance = 10.0;
-		if (max_iter != NULL) *max_iter = false;
-	}
-
-	//plane
-	if (params.primitives.planeEnable)
-	{
-		double planeDistance = PrimitivePlane(point, params.doubles.primitives.planeCentre, params.doubles.primitives.planeNormal);
-		if(!params.primitives.onlyPlane && planeDistance < distance) 	params.objectOut = objPlane;
-		distance = (planeDistance < distance) ? planeDistance : distance;
-
-	}
-
-	//box
-	if (params.primitives.boxEnable)
-	{
-		double boxDistance = PrimitiveBox(point, params.doubles.primitives.boxCentre, params.doubles.primitives.boxSize);
-		if(boxDistance < distance) 	params.objectOut = objBox;
-		distance = (boxDistance < distance) ? boxDistance : distance;
-	}
-
-	//inverted box
-	if (params.primitives.invertedBoxEnable)
-	{
-		double boxDistance = PrimitiveInvertedBox(point, params.doubles.primitives.invertedBoxCentre, params.doubles.primitives.invertedBoxSize);
-		if(boxDistance < distance) 	params.objectOut = objBoxInv;
-		distance = (boxDistance < distance) ? boxDistance : distance;
-	}
-
-	//sphere
-	if (params.primitives.sphereEnable)
-	{
-		double sphereDistance = PrimitiveSphere(point, params.doubles.primitives.sphereCentre, params.doubles.primitives.sphereRadius);
-		if(sphereDistance < distance) 	params.objectOut = objSphere;
-		distance = (sphereDistance < distance) ? sphereDistance : distance;
-	}
-
-	//invertedSphere
-	if (params.primitives.invertedSphereEnable)
-	{
-		double sphereDistance = PrimitiveInvertedSphere(point, params.doubles.primitives.invertedSphereCentre, params.doubles.primitives.invertedSphereRadius);
-		if(sphereDistance < distance) 	params.objectOut = objSphereInv;
-		distance = (sphereDistance < distance) ? sphereDistance : distance;
-	}
-
-	//water
-	if (params.primitives.waterEnable)
-	{
-		double waterDistance = PrimitiveWater(point, params.doubles.primitives.waterHeight, params.doubles.primitives.waterAmplitude,
-				params.doubles.primitives.waterLength, params.doubles.primitives.waterRotation, params.primitives.waterIterations, 0.1, params.frameNo);
-		if(waterDistance < distance) 	params.objectOut = objWater;
-		distance = (waterDistance < distance) ? waterDistance : distance;
-	}
-
-	if (distance < 0) distance = 0;
-	if (max_iter != NULL)
-	{
-
-		if (*max_iter)
-		{
-			if (params.limits_enabled)
-			{
-				double distance_a1 = fabs(params.doubles.amin - point.x);
-				double distance_a2 = fabs(params.doubles.amax - point.x);
-				double distance_b1 = fabs(params.doubles.bmin - point.y);
-				double distance_b2 = fabs(params.doubles.bmax - point.y);
-				double distance_c1 = fabs(params.doubles.cmin - point.z);
-				double distance_c2 = fabs(params.doubles.cmax - point.z);
-				double min1 = dMin(distance_a1, distance_b1, distance_c1);
-				double min2 = dMin(distance_a2, distance_b2, distance_c2);
-				double min = MIN(min1, min2);
-				if(min < params.doubles.detailSize)
-				{
-					distance = min;
-				}
-			}
-			else
-			{
-				//distance = params.doubles.detailSize * 0.5;
-				distance = 0.0;
-			}
-		}
-
-
-	}
-	return distance;
-}
-#endif
-
-// force template instantiation
-template double Compute<normal>(CVector3, const sFractal&, int*);
-template double Compute<colouring>(CVector3, const sFractal&, int*);
-template double Compute<fake_AO>(CVector3, const sFractal&, int*);
-template double Compute<deltaDE1>(CVector3, const sFractal&, int*);
-template double Compute<deltaDE2>(CVector3, const sFractal&, int*);
-template double Compute<orbitTrap>(CVector3, const sFractal&, int*);
diff --git a/src/mandelbulber/fractal.h b/src/mandelbulber/fractal.h
deleted file mode 100644
index 4e957e6..0000000
--- a/src/mandelbulber/fractal.h
+++ /dev/null
@@ -1,277 +0,0 @@
-/*
- * fractal.h
- *
- *  Created on: 2010-01-23
- *      Author: krzysztof marczak
- */
-
-#ifndef FRACTAL_H_
-#define FRACTAL_H_
-
-#include <vector>
-#include "common_math.h"
-//#include "fractparams.h"
-#include <stddef.h>
-
-const int IFS_VECTOR_COUNT = 9;
-const int HYBRID_COUNT = 5;
-const int MANDELBOX_FOLDS = 2;
-
-enum enumFractalFormula
-{
-	none = 0,
-	trig_DE = 1,
-	trig_optim = 2,
-	fast_trig = 3,
-	hypercomplex = 4,
-	quaternion = 5,
-	minus_fast_trig = 6,
-	menger_sponge = 7,
-	tglad = 8,
-	kaleidoscopic = 10,
-	xenodreambuie = 11,
-	hybrid = 12,
-	mandelbulb2 = 13,
-	mandelbulb3 = 14,
-	mandelbulb4 = 15,
-	foldingIntPow2 = 16,
-	smoothMandelbox = 17,
-	mandelboxVaryScale4D = 18,
-	aexion = 19,
-	benesi = 20,
-	bristorbrot = 21,
-	invertX = 22,
-	invertY = 23,
-	invertZ = 24,
-	invertR = 25,
-	sphericalFold = 26,
-	powXYZ = 27,
-	scaleX = 28,
-	scaleY = 29,
-	scaleZ = 30,
-	offsetX = 31,
-	offsetY = 32,
-	offsetZ = 33,
-	angleMultiplyX = 34,
-	angleMultiplyY = 35,
-	angleMultiplyZ = 36,
-	generalizedFoldBox = 37
-};
-
-enum enumCalculationMode
-{
-	normal = 0, colouring = 1, fake_AO = 2, deltaDE1 = 3, deltaDE2 = 4, orbitTrap = 5
-};
-
-enum enumGeneralizedFoldBoxType
-{
-	foldTet = 0,
-	foldCube = 1,
-	foldOct = 2,
-	foldDodeca = 3,
-	foldOctCube = 4,
-	foldIcosa = 5,
-	foldBox6 = 6,
-	foldBox5 = 7
-};
-
-enum enumObjectType
-{
-	objFractal = 0,
-	objPlane = 1,
-	objWater = 2,
-	objSphere = 3,
-	objSphereInv = 4,
-	objBox = 5,
-	objBoxInv = 6
-};
-
-struct sFractalIFSD
-{
-	double rotationGamma;
-	double rotationAlfa;
-	double rotationBeta;
-	double scale;
-	double distance[IFS_VECTOR_COUNT];
-	double alfa[IFS_VECTOR_COUNT];
-	double beta[IFS_VECTOR_COUNT];
-	double gamma[IFS_VECTOR_COUNT];
-	double intensity[IFS_VECTOR_COUNT];
-	CVector3 offset;
-	CVector3 direction[IFS_VECTOR_COUNT];
-	CVector3 edge;
-};
-
-struct sFractalGeneralizedFoldBox
-{
-	enum enumGeneralizedFoldBoxType type;
-	CVector3 Nv_tet[4];
-	CVector3 Nv_cube[6];
-	CVector3 Nv_oct[8];
-	CVector3 Nv_oct_cube[14];
-	CVector3 Nv_dodeca[12];
-	CVector3 Nv_icosa[20];
-	CVector3 Nv_box6[8];
-	CVector3 Nv_box5[7];
-	int sides_tet;
-	int sides_cube;
-	int sides_oct;
-	int sides_oct_cube;
-	int sides_dodeca;
-	int sides_icosa;
-	int sides_box6;
-	int sides_box5;
-};
-
-struct sFractalIFS
-{
-	sFractalIFSD doubles;
-	bool absX, absY, absZ;
-	bool foldingMode; // Kaleidoscopic IFS folding mode
-	bool enabled[IFS_VECTOR_COUNT];
-	bool mengerSpongeMode;
-	int foldingCount;
-	CRotationMatrix mainRot;
-	CRotationMatrix rot[IFS_VECTOR_COUNT];
-};
-
-struct sFractalMandelboxVary4D
-{
-	double fold;
-	double minR;
-	double scaleVary;
-	double wadd;
-	double rPower;
-};
-
-struct sFractalMandelboxD
-{
-	double rotationMain[3];
-	double rotation[MANDELBOX_FOLDS][3][3];
-	double colorFactorX;
-	double colorFactorY;
-	double colorFactorZ;
-	double colorFactorR;
-	double colorFactorSp1;
-	double colorFactorSp2;
-	double scale;
-	double foldingLimit;
-	double foldingValue;
-	double foldingSphericalMin;
-	double foldingSphericalFixed;
-	double sharpness;
-	double solid;
-	double melt;
-	CVector3 offset;
-	sFractalMandelboxVary4D vary4D;
-};
-
-struct sFractalMandelbox
-{
-	sFractalMandelboxD doubles;
-	bool rotationsEnabled;
-	CRotationMatrix mainRot;
-	CRotationMatrix rot[MANDELBOX_FOLDS][3];
-	CRotationMatrix rotinv[MANDELBOX_FOLDS][3];
-};
-
-struct sFractalPrimitivesD
-{
-	CVector3 planeCentre;
-	CVector3 planeNormal;
-	CVector3 boxCentre;
-	CVector3 boxSize;
-	CVector3 invertedBoxCentre;
-	CVector3 invertedBoxSize;
-	CVector3 sphereCentre;
-	double sphereRadius;
-	CVector3 invertedSphereCentre;
-	double invertedSphereRadius;
-	double waterHeight;
-	double waterAmplitude;
-	double waterLength;
-	double waterRotation;
-};
-
-struct sFractalPrimitives
-{
-	bool planeEnable;
-	bool boxEnable;
-	bool invertedBoxEnable;
-	bool sphereEnable;
-	bool invertedSphereEnable;
-	bool waterEnable;
-	bool onlyPlane;
-	int waterIterations;
-};
-
-struct sFractalD
-{
-	double N;
-	double amin;  //fractal limits
-	double amax;
-	double bmin;
-	double bmax;
-	double cmin;
-	double cmax;
-	double constantFactor;
-	double FoldingIntPowZfactor;
-	double FoldingIntPowFoldFactor;
-	double foldingLimit; //paramters of TGlad's folding
-	double foldingValue;
-	double foldingSphericalMin;
-	double foldingSphericalFixed;
-	double detailSize;
-	double power;		 //power of fractal formula
-	double cadd;
-	double hybridPower[HYBRID_COUNT];
-	CVector3 julia; // Julia constant
-	CVector3 fakeLightsOrbitTrap;
-	sFractalPrimitivesD primitives;
-};
-
-struct sFractal
-{
-	sFractalD doubles;
-
-	  // maximum number of iterations
-	int minN;	  // minimum number of iterations
-
-	bool limits_enabled; // enable limits (intersections)
-	bool iterThresh;	 //maxiter threshold mode
-	bool analitycDE;	 //analytic DE mode
-	bool juliaMode;				// Julia mode
-	bool tgladFoldingMode;		// Tglad's folding mode
-	bool sphericalFoldingMode;  // spherical folding mode
-	bool interiorMode;
-	bool hybridCyclic;
-	bool linearDEmode;
-	bool constantDEThreshold;
-
-	enumFractalFormula formula;
-
-	int hybridIters[HYBRID_COUNT];
-	enumFractalFormula hybridFormula[HYBRID_COUNT];
-
-	std::vector<enumFractalFormula> formulaSequence;
-	std::vector<double> hybridPowerSequence;
-
-	sFractalIFS IFS;
-	sFractalMandelbox mandelbox;
-	sFractalGeneralizedFoldBox genFoldBox;
-	sFractalPrimitives primitives;
-
-	int frameNo;
-
-	int itersOut;
-	enumObjectType objectOut;
-
-	int fakeLightsMinIter;
-	int fakeLightsMaxIter;
-};
-
-template <int Mode> double Compute(CVector3 z, const sFractal &par, int *iter_count = NULL);
-//double CalculateDistance(CVector3 point, sFractal &par, bool *max_iter = NULL);
-
-
-#endif /* FRACTAL_H_ */
diff --git a/src/mandelbulber/fractparams.h b/src/mandelbulber/fractparams.h
deleted file mode 100644
index 9809453..0000000
--- a/src/mandelbulber/fractparams.h
+++ /dev/null
@@ -1,157 +0,0 @@
-/*
- * fractparams.h
- *
- *  Created on: 2010-05-03
- *      Author: krzysztof
- */
-
-#ifndef FRACTPARAMS_H_
-#define FRACTPARAMS_H_
-
-#include "fractal.h"
-//#include "texture.hpp"
-
-struct sParamRenderD
-{
-	double zoom; //zoom
-	double DE_factor; //factor for distance estimation steps
-	double resolution; //resolution of image in fractal coordinates
-	double persp; //perspective factor
-	double quality; //DE threshold factor
-	double smoothness;
-	double alpha; //rotation of fractal
-	double beta; //
-	double gamma;
-	double DOFFocus;
-	double DOFRadius;
-	double mainLightAlpha;
-	double mainLightBeta;
-	double auxLightIntensity;
-	double auxLightMaxDist;
-	double auxLightDistributionRadius;
-	double auxLightVisibility;
-	double auxLightPre1intensity;
-	double auxLightPre2intensity;
-	double auxLightPre3intensity;
-	double auxLightPre4intensity;
-	double stereoEyeDistance;
-	double viewDistanceMin;
-	double viewDistanceMax;
-	double volumetricLightIntensity[5];
-	double fogDensity;
-	double fogColour1Distance;
-	double fogColour2Distance;
-	double fogDistanceFactor;
-	double colourSaturation;
-	double fastAoTune;
-	double iterFogOpacity;
-	double iterFogOpacityTrim;
-	double fakeLightsIntensity;
-	double fakeLightsVisibility;
-	double fakeLightsVisibilitySize;
-	double shadowConeAngle;
-	double primitivePlaneReflect;
-	double primitiveBoxReflect;
-	double primitiveInvertedBoxReflect;
-	double primitiveSphereReflect;
-	double primitiveInvertedSphereReflect;
-	double primitiveWaterReflect;
-
-//	sImageAdjustments imageAdjustments;
-
-	CVector3 vp; //view point
-	CVector3 auxLightPre1;
-	CVector3 auxLightPre2;
-	CVector3 auxLightPre3;
-	CVector3 auxLightPre4;
-	CVector3 auxLightRandomCenter;
-};
-
-struct sParamRender
-{
-	sParamRenderD doubles;
-
-	sFractal fractal;
-	int image_width; //image width
-	int image_height; //image height
-	int globalIlumQuality; //ambient occlusion quality
-	int reflectionsMax;
-	int coloring_seed; //colouring random seed
-	int auxLightRandomSeed;
-	int auxLightNumber;
-	int SSAOQuality;
-	int startFrame;
-	int endFrame;
-	int framesPerKeyframe;
-	int imageFormat;
-	int noOfTiles;
-	int tileCount;
-
-	int OpenCLEngine;
-	int OpenCLPixelsPerJob;
-
-	enumPerspectiveType perspectiveType;
-
-	bool shadow; //enable shadows
-	bool global_ilumination; //enable global ilumination
-	bool fastGlobalIllumination; //enable fake global ilumination
-	bool slowShading; //enable fake gradient calculation for shading
-	bool textured_background; //enable testured background
-	bool background_as_fulldome;
-	bool recordMode; //path recording mode
-	bool continueRecord; //continue recording mode
-	bool playMode; //play mode
-	bool animMode; //animation mode
-	bool SSAOEnabled;
-	bool DOFEnabled;
-	bool auxLightPre1Enabled;
-	bool auxLightPre2Enabled;
-	bool auxLightPre3Enabled;
-	bool auxLightPre4Enabled;
-	bool volumetricLightEnabled[5];
-	bool penetratingLights;
-	bool stereoEnabled;
-	bool quiet;
-	bool fishEyeCut;
-	bool fakeLightsEnabled;
-/*
-	sImageSwitches imageSwitches;
-
-	sRGB background_color1; //background colour
-	sRGB background_color2;
-	sRGB background_color3;
-	sRGB auxLightPre1Colour;
-	sRGB auxLightPre2Colour;
-	sRGB auxLightPre3Colour;
-	sRGB auxLightPre4Colour;
-	sRGB fogColour1;
-	sRGB fogColour2;
-	sRGB fogColour3;
-	sRGB primitivePlaneColour;
-	sRGB primitiveBoxColour;
-	sRGB primitiveInvertedBoxColour;
-	sRGB primitiveSphereColour;
-	sRGB primitiveInvertedSphereColour;
-	sRGB primitiveWaterColour;
-	sEffectColours effectColours;
-
-	sRGB palette[256];
-
-	char file_destination[1000];
-	char file_envmap[1000];
-	char file_background[1000];
-	char file_lightmap[1000];
-	char file_path[1000];
-	char file_keyframes[1000];
-
-	cTexture *backgroundTexture;
-	cTexture *envmapTexture;
-	cTexture *lightmapTexture;
-*/
-	std::vector<enumFractalFormula> formulaSequence;
-	std::vector<double> hybridPowerSequence;
-
-	double settingsVersion;
-};
-
-#endif /* FRACTPARAMS_H_ */
diff --git a/util/next/minetest.log b/util/next/minetest.log
deleted file mode 100644
index 244279e..0000000
--- a/util/next/minetest.log
+++ /dev/null
@@ -1,780 +0,0 @@
-
-
-
-
-!!!!!!!!!!!!!!!!!
- Merge sapier/avoid_facedir_if_not_moving to next failed:
-
-# On branch next
-# You have unmerged paths.
-#   (fix conflicts and run "git commit")
-#
-# Unmerged paths:
-#   (use "git add <file>..." to mark resolution)
-#
-#	both modified:      src/content_cao.cpp
-#	both modified:      src/content_sao.cpp
-#
-no changes added to commit (use "git add" and/or "git commit -a")
-diff --cc src/content_cao.cpp
-index e97e3a1,fb4bc95..0000000
---- a/src/content_cao.cpp
-+++ b/src/content_cao.cpp
-@@@ -1211,9 -1211,9 +1211,15 @@@ public
-  			updateNodePos();
-  		}
-  
-++<<<<<<< HEAD
- +		if (getParent() == NULL && m_prop.automatic_face_movement_dir &&
- +				(fabs(m_velocity.Z) > 0.001 || fabs(m_velocity.X) > 0.001)){
- +			m_yaw = atan2(m_velocity.Z,m_velocity.X) * 180 / M_PI + m_prop.automatic_face_movement_dir_offset;
-++=======
-+ 		if ((getParent() == NULL && m_prop.automatic_face_movement_dir) &&
-+ 			((m_velocity.Z != 0) || (m_velocity.X != 0))){
-+ 			m_yaw = atan2(m_velocity.Z,m_velocity.X) * 180 / M_PI;
-++>>>>>>> sapier/avoid_facedir_if_not_moving
-  			updateNodePos();
-  		}
-  	}
-diff --cc src/content_sao.cpp
-index 85ab8d3,92cabfb..0000000
---- a/src/content_sao.cpp
-+++ b/src/content_sao.cpp
-@@@ -527,9 -527,9 +527,14 @@@ void LuaEntitySAO::step(float dtime, bo
-  			m_velocity += dtime * m_acceleration;
-  		}
-  
- -		if( (m_prop.automatic_face_movement_dir) &&
- +		if((m_prop.automatic_face_movement_dir) &&
-++<<<<<<< HEAD
- +				(fabs(m_velocity.Z) > 0.001 || fabs(m_velocity.X) > 0.001)){
- +			m_yaw = atan2(m_velocity.Z,m_velocity.X) * 180 / M_PI + m_prop.automatic_face_movement_dir_offset;
-++=======
-+ 			((m_velocity.Z != 0) || (m_velocity.X != 0))){
-+ 			m_yaw = atan2(m_velocity.Z,m_velocity.X) * 180 / M_PI;
-++>>>>>>> sapier/avoid_facedir_if_not_moving
-  		}
-  	}
-  
-
-
-
-
-!!!!!!!!!!!!!!!!!
- Merge sapier/modmgr_fixes to next failed:
-
-# On branch next
-# You have unmerged paths.
-#   (fix conflicts and run "git commit")
-#
-# Unmerged paths:
-#   (use "git add <file>..." to mark resolution)
-#
-#	both modified:      builtin/misc_helpers.lua
-#
-no changes added to commit (use "git add" and/or "git commit -a")
-diff --cc builtin/misc_helpers.lua
-index 66b5432,0110062..0000000
---- a/builtin/misc_helpers.lua
-+++ b/builtin/misc_helpers.lua
-@@@ -261,192 -261,6 +261,195 @@@ function tbl.splittext(text,charlimit
-  	return retval
-  end
-  
-++<<<<<<< HEAD
- +--------------------------------------------------------------------------------
- +
- +if minetest then
- +	local dirs1 = { 9, 18, 7, 12 }
- +	local dirs2 = { 20, 23, 22, 21 }
- +
- +	function minetest.rotate_and_place(itemstack, placer, pointed_thing, infinitestacks, orient_flags)
- +		orient_flags = orient_flags or {}
- +
- +		local node = minetest.get_node(pointed_thing.under)
- +		if not minetest.registered_nodes[node.name]
- +		   or not minetest.registered_nodes[node.name].on_rightclick then
- +
- +			local above = pointed_thing.above
- +			local under = pointed_thing.under
- +			local pitch = placer:get_look_pitch()
- +			local pname = minetest.get_node(under).name
- +			local node = minetest.get_node(above)
- +			local fdir = minetest.dir_to_facedir(placer:get_look_dir())
- +			local wield_name = itemstack:get_name()
- +			local reg_node = minetest.registered_nodes[pname]
- +
- +			if not reg_node or not reg_node.on_rightclick then
- +
- +				local iswall = (above.x ~= under.x) or (above.z ~= under.z)
- +				local isceiling = (above.x == under.x) and (above.z == under.z)
- +								  and (pitch > 0)
- +				local pos1 = above
- +
- +				if reg_node and reg_node.buildable_to then
- +					pos1 = under
- +					iswall = false
- +				end
- +
- +				reg_node = minetest.registered_nodes[minetest.get_node(pos1).name]
- +				if not reg_node or not reg_node.buildable_to then
- +					return
- +				end
- +
- +				if orient_flags.force_floor then
- +					iswall = false
- +					isceiling = false
- +				elseif orient_flags.force_ceiling then 
- +					iswall = false
- +					isceiling = true
- +				elseif orient_flags.force_wall then					
- +					iswall = true
- +					isceiling = false
- +				elseif orient_flags.invert_wall then
- +					iswall = not iswall
- +				end
- +
- +				if iswall then
- +					minetest.add_node(pos1, {name = wield_name, param2 = dirs1[fdir+1] })
- +				elseif isceiling then
- +					if orient_flags.force_facedir then
- +						minetest.add_node(pos1, {name = wield_name, param2 = 20 })
- +					else
- +						minetest.add_node(pos1, {name = wield_name, param2 = dirs2[fdir+1] })
- +					end
- +				else -- place right side up
- +					if orient_flags.force_facedir then
- +						minetest.add_node(pos1, {name = wield_name, param2 = 0 })
- +					else
- +						minetest.add_node(pos1, {name = wield_name, param2 = fdir })
- +					end
- +				end
- +
- +				if not infinitestacks then
- +					itemstack:take_item()
- +					return itemstack
- +				end
- +			end
- +		else
- +			minetest.registered_nodes[node.name].on_rightclick(pointed_thing.under, node, placer, itemstack)
- +		end
- +	end
- +
- +
- +--------------------------------------------------------------------------------
- +--Wrapper for rotate_and_place() to check for sneak and assume Creative mode
- +--implies infinite stacks when performing a 6d rotation.
- +--------------------------------------------------------------------------------
- +
- +
- +	minetest.rotate_node = function(itemstack, placer, pointed_thing)
- +		minetest.rotate_and_place(itemstack, placer, pointed_thing,
- +		minetest.setting_getbool("creative_mode"), 
- +		{invert_wall = placer:get_player_control().sneak})
- +		return itemstack
- +	end
- +end
- +
- +--------------------------------------------------------------------------------
- +
- +if minetest then
- +	local dirs1 = { 9, 18, 7, 12 }
- +	local dirs2 = { 20, 23, 22, 21 }
- +
- +	function minetest.rotate_and_place(itemstack, placer, pointed_thing, infinitestacks, orient_flags)
- +		orient_flags = orient_flags or {}
- +
- +		local node = minetest.get_node(pointed_thing.under)
- +		if not minetest.registered_nodes[node.name]
- +		   or not minetest.registered_nodes[node.name].on_rightclick then
- +
- +			local above = pointed_thing.above
- +			local under = pointed_thing.under
- +			local pitch = placer:get_look_pitch()
- +			local pname = minetest.get_node(under).name
- +			local node = minetest.get_node(above)
- +			local fdir = minetest.dir_to_facedir(placer:get_look_dir())
- +			local wield_name = itemstack:get_name()
- +			local reg_node = minetest.registered_nodes[pname]
- +
- +			if not reg_node or not reg_node.on_rightclick then
- +
- +				local iswall = (above.x ~= under.x) or (above.z ~= under.z)
- +				local isceiling = (above.x == under.x) and (above.z == under.z)
- +								  and (pitch > 0)
- +				local pos1 = above
- +
- +				if reg_node and reg_node.buildable_to then
- +					pos1 = under
- +					iswall = false
- +				end
- +
- +				reg_node = minetest.registered_nodes[minetest.get_node(pos1).name]
- +				if not reg_node or not reg_node.buildable_to then
- +					return
- +				end
- +
- +				if orient_flags.force_floor then
- +					iswall = false
- +					isceiling = false
- +				elseif orient_flags.force_ceiling then 
- +					iswall = false
- +					isceiling = true
- +				elseif orient_flags.force_wall then					
- +					iswall = true
- +					isceiling = false
- +				elseif orient_flags.invert_wall then
- +					iswall = not iswall
- +				end
- +
- +				if iswall then
- +					minetest.add_node(pos1, {name = wield_name, param2 = dirs1[fdir+1] })
- +				elseif isceiling then
- +					if orient_flags.force_facedir then
- +						minetest.add_node(pos1, {name = wield_name, param2 = 20 })
- +					else
- +						minetest.add_node(pos1, {name = wield_name, param2 = dirs2[fdir+1] })
- +					end
- +				else -- place right side up
- +					if orient_flags.force_facedir then
- +						minetest.add_node(pos1, {name = wield_name, param2 = 0 })
- +					else
- +						minetest.add_node(pos1, {name = wield_name, param2 = fdir })
- +					end
- +				end
- +
- +				if not infinitestacks then
- +					itemstack:take_item()
- +					return itemstack
- +				end
- +			end
- +		else
- +			minetest.registered_nodes[node.name].on_rightclick(pointed_thing.under, node, placer, itemstack)
- +		end
- +	end
- +
- +
- +--------------------------------------------------------------------------------
- +--Wrapper for rotate_and_place() to check for sneak and assume Creative mode
- +--implies infinite stacks when performing a 6d rotation.
- +--------------------------------------------------------------------------------
- +
- +
- +	minetest.rotate_node = function(itemstack, placer, pointed_thing)
- +		minetest.rotate_and_place(itemstack, placer, pointed_thing,
- +		minetest.setting_getbool("creative_mode"), 
- +		{invert_wall = placer:get_player_control().sneak})
- +		return itemstack
- +	end
- +end
- +
-++=======
-++>>>>>>> sapier/modmgr_fixes
-  --------------------------------------------------------------------------------
-  -- mainmenu only functions
-  --------------------------------------------------------------------------------
-
-
-
-
-!!!!!!!!!!!!!!!!!
- Merge Novatux/forceload to next failed:
-
-# On branch next
-# You have unmerged paths.
-#   (fix conflicts and run "git commit")
-#
-# Changes to be committed:
-#
-#	modified:   doc/lua_api.txt
-#	modified:   minetest.conf.example
-#	modified:   src/defaultsettings.cpp
-#	modified:   src/environment.cpp
-#
-# Unmerged paths:
-#   (use "git add <file>..." to mark resolution)
-#
-#	both modified:      src/object_properties.cpp
-#	both modified:      src/object_properties.h
-#
-diff --cc src/object_properties.cpp
-index f560f59,162cc67..0000000
---- a/src/object_properties.cpp
-+++ b/src/object_properties.cpp
-@@@ -42,7 -42,7 +42,11 @@@ ObjectProperties::ObjectProperties()
-  	automatic_rotate(0),
-  	stepheight(0),
-  	automatic_face_movement_dir(false),
-++<<<<<<< HEAD
- +	automatic_face_movement_dir_offset(0.0)
-++=======
-+ 	force_load(false)
-++>>>>>>> Novatux/forceload
-  {
-  	textures.push_back("unknown_object.png");
-  	colors.push_back(video::SColor(255,255,255,255));
-@@@ -105,7 -106,7 +110,11 @@@ void ObjectProperties::serialize(std::o
-  	writeU8(os, collideWithObjects);
-  	writeF1000(os,stepheight);
-  	writeU8(os, automatic_face_movement_dir);
-++<<<<<<< HEAD
- +	writeF1000(os, automatic_face_movement_dir_offset);
-++=======
-+ 	writeU8(os, force_load);
-++>>>>>>> Novatux/forceload
-  	// Add stuff only at the bottom.
-  	// Never remove anything, because we don't want new versions of this
-  }
-@@@ -141,7 -142,7 +150,11 @@@ void ObjectProperties::deSerialize(std:
-  			collideWithObjects = readU8(is);
-  			stepheight = readF1000(is);
-  			automatic_face_movement_dir = readU8(is);
-++<<<<<<< HEAD
- +			automatic_face_movement_dir_offset = readF1000(is);
-++=======
-+ 			force_load = readU8(is);
-++>>>>>>> Novatux/forceload
-  		}catch(SerializationError &e){}
-  	}
-  	else
-diff --cc src/object_properties.h
-index 4b7f9a5,dbcbba5..0000000
---- a/src/object_properties.h
-+++ b/src/object_properties.h
-@@@ -46,7 -46,7 +46,11 @@@ struct ObjectPropertie
-  	float automatic_rotate;
-  	f32 stepheight;
-  	bool automatic_face_movement_dir;
-++<<<<<<< HEAD
- +	f32 automatic_face_movement_dir_offset;
-++=======
-+ 	bool force_load;
-++>>>>>>> Novatux/forceload
-  
-  
-  	ObjectProperties();
-
-
-
-
-!!!!!!!!!!!!!!!!!
- Merge sapier/fix_crash_on_lua_exception to next failed:
-
-# On branch next
-# You have unmerged paths.
-#   (fix conflicts and run "git commit")
-#
-# Unmerged paths:
-#   (use "git add <file>..." to mark resolution)
-#
-#	both modified:      src/guiFormSpecMenu.cpp
-#
-no changes added to commit (use "git add" and/or "git commit -a")
-diff --cc src/guiFormSpecMenu.cpp
-index 2416e4c,01630e0..0000000
---- a/src/guiFormSpecMenu.cpp
-+++ b/src/guiFormSpecMenu.cpp
-@@@ -1657,7 -1597,21 +1657,25 @@@ void GUIFormSpecMenu::regenerateGui(v2u
-  			Environment->addButton(mydata.rect, this, 257, text);
-  			delete[] text;
-  		}
-++<<<<<<< HEAD
- +
-++=======
-+ 		changeCtype("C");
-+ 	}
-+ 	// Add tooltip
-+ 	{
-+ 		// Note: parent != this so that the tooltip isn't clipped by the menu rectangle
-+ 		m_tooltip_element = Environment->addStaticText(L"",core::rect<s32>(0,0,110,18));
-+ 		m_tooltip_element->enableOverrideColor(true);
-+ 		m_tooltip_element->setBackgroundColor(video::SColor(255,110,130,60));
-+ 		m_tooltip_element->setDrawBackground(true);
-+ 		m_tooltip_element->setDrawBorder(true);
-+ 		m_tooltip_element->setOverrideColor(video::SColor(255,255,255,255));
-+ 		m_tooltip_element->setTextAlignment(gui::EGUIA_CENTER, gui::EGUIA_CENTER);
-+ 		m_tooltip_element->setWordWrap(false);
-+ 		//we're not parent so no autograb for this one!
-+ 		m_tooltip_element->grab();
-++>>>>>>> sapier/fix_crash_on_lua_exception
-  	}
-  
-  	//set initial focus if parser didn't set it
-
-
-
-
-!!!!!!!!!!!!!!!!!
- Merge ShadowNinja/protection_support to next failed:
-
-# On branch next
-# You have unmerged paths.
-#   (fix conflicts and run "git commit")
-#
-# Unmerged paths:
-#   (use "git add <file>..." to mark resolution)
-#
-#	both modified:      builtin/misc_register.lua
-#	both modified:      doc/lua_api.txt
-#
-no changes added to commit (use "git add" and/or "git commit -a")
-diff --cc builtin/misc_register.lua
-index 479a339,3002d5e..0000000
---- a/builtin/misc_register.lua
-+++ b/builtin/misc_register.lua
-@@@ -342,22 -327,5 +342,25 @@@ minetest.registered_on_joinplayers, min
-  minetest.registered_on_leaveplayers, minetest.register_on_leaveplayer = make_registration()
-  minetest.registered_on_player_receive_fields, minetest.register_on_player_receive_fields = make_registration_reverse()
-  minetest.registered_on_cheats, minetest.register_on_cheat = make_registration()
-++<<<<<<< HEAD
- +minetest.registered_on_crafts, minetest.register_on_craft = make_registration()
- +minetest.registered_craft_predicts, minetest.register_craft_predict = make_registration()
-++=======
-++>>>>>>> ShadowNinja/protection_support
-  minetest.registered_on_protection_violation, minetest.register_on_protection_violation = make_registration()
-  
- +minetest.register_on_joinplayer(function(player)
- +	if minetest.is_singleplayer() then
- +		return
- +	end
- +	local player_name =  player:get_player_name()
- +	minetest.chat_send_all("*** " .. player_name .. " joined the game.")
- +end)
- +
- +minetest.register_on_dieplayer(function(player)
- +	local player_name =  player:get_player_name()
- +	if minetest.is_singleplayer() then
- +		player_name = "You"
- +	end
- +	minetest.chat_send_all(player_name .. " died.")
- +end)
-diff --cc doc/lua_api.txt
-index 5e9adff,7b53c19..0000000
---- a/doc/lua_api.txt
-+++ b/doc/lua_api.txt
-@@@ -1203,15 -1151,6 +1203,18 @@@ minetest.register_on_player_receive_fie
-  minetest.register_on_mapgen_init(func(MapgenParams))
-  ^ Called just before the map generator is initialized but before the environment is initialized
-  ^ MapgenParams consists of a table with the fields mgname, seed, water_level, and flags
-++<<<<<<< HEAD
- +minetest.register_on_craft(func(itemstack, player, old_craft_grid, craft_inv))
- +^ Called when player crafts something
- +^ itemstack is the output
- +^ old_craft_grid contains the recipe (Note: the one in the inventory is cleared)
- +^ craft_inv is the inventory with the crafting grid
- +^ Return either an ItemStack, to replace the output, or nil, to not modify it
- +minetest.register_craft_predict(func(itemstack, player, old_craft_grid, craft_inv))
- +^ The same as before, except that it is called before the player crafts, to make
- +^ craft prediction, and it should not change anything.
-++=======
-++>>>>>>> ShadowNinja/protection_support
-  minetest.register_on_protection_violation(func(pos, name))
-  ^ Called by builtin and mods when a player violates protection at a position
-    (eg, digs a node or punches a protected entity).
-@@@ -1564,28 -1498,6 +1567,31 @@@ minetest.is_protected(pos, name) -> boo
-  minetest.record_protection_violation(pos, name)
-  ^ This function calls functions registered with
-    minetest.register_on_protection_violation.
-++<<<<<<< HEAD
- +minetest.rotate_and_place(itemstack, placer, pointed_thing, infinitestacks, orient_flags)
- +^ Attempt to predict the desired orientation of the facedir-capable node
- +  defined by itemstack, and place it accordingly (on-wall, on the floor, or
- +  hanging from the ceiling). Stacks are handled normally if the infinitestacks
- +  field is false or omitted (else, the itemstack is not changed). orient_flags
- +  is an optional table containing extra tweaks to the placement code:
- +  invert_wall:		if true, place wall-orientation on the ground and ground-
- +					orientation on the wall.
- +  force_wall:		if true, always place the node in wall orientation.
- +  force_ceiling:	if true, always place on the ceiling.
- +  force_floor:		if true, always place the node on the floor.
- +
- +  The above four options are mutually-exclusive; the last in the list takes
- +  precedence over the first.
- +
- +  force_facedir:	if true, forcably reset the facedir to north when placing on
- +					the floor or ceiling
- +
- +minetest.rotate_node(itemstack, placer, pointed_thing)
- +^ calls rotate_and_place() with infinitestacks set according to the state of
- +  the creative mode setting, and checks for "sneak" to set the invert_wall
- +  parameter.
-++=======
-++>>>>>>> ShadowNinja/protection_support
-  
-  Global objects:
-  minetest.env - EnvRef of the server environment and world.
-
-
-
-
-!!!!!!!!!!!!!!!!!
- Merge Jeija/rotateto to next failed:
-
-# On branch next
-# You have unmerged paths.
-#   (fix conflicts and run "git commit")
-#
-# Changes to be committed:
-#
-#	modified:   doc/lua_api.txt
-#	modified:   src/content_sao.h
-#	modified:   src/genericobject.cpp
-#	modified:   src/genericobject.h
-#	modified:   src/script/lua_api/l_object.cpp
-#	modified:   src/script/lua_api/l_object.h
-#
-# Unmerged paths:
-#   (use "git add <file>..." to mark resolution)
-#
-#	both modified:      src/content_cao.cpp
-#	both modified:      src/content_sao.cpp
-#
-diff --cc src/content_cao.cpp
-index eda0d54,89b8dc5..0000000
---- a/src/content_cao.cpp
-+++ b/src/content_cao.cpp
-@@@ -1213,35 -1215,28 +1222,60 @@@ public
-  			m_yaw += dtime * m_prop.automatic_rotate * 180 / M_PI;
-  			updateNodePos();
-  		}
-++<<<<<<< HEAD
- +
- +		if (getParent() == NULL && m_prop.automatic_face_movement_dir &&
- +				(fabs(m_velocity.Z) > 0.001 || fabs(m_velocity.X) > 0.001)){
- +			m_yaw = atan2(m_velocity.Z,m_velocity.X) * 180 / M_PI + m_prop.automatic_face_movement_dir_offset;
- +			updateNodePos();
- +		}
- +		updateAnimationSpeed();
- +	}
- +
- +	void updateAnimationSpeed()
- +	{
- +		if(m_animated_meshnode == NULL)
- +			return;
- +
- +		if (m_anim_base_velocity > 0)
- +		{
- +			//calculate current velocity
- +			float current_velocity = XZScalar(m_velocity.X,m_velocity.Z);
- +
- +			if (fabs(m_anim_last_updated_velocity-current_velocity) > 0.05)
- +			{
- +				//calculate new animation speed
- +				float new_speed = current_velocity/m_anim_base_velocity * 15;
- +
- +				m_animated_meshnode->setAnimationSpeed(new_speed);
- +
- +				m_anim_last_updated_velocity = current_velocity;
- +			}
- +		}
-++=======
-+ 		// Automatic rotation overrides continues rotation
-+ 		if(getParent() == NULL && m_rotate_yaw_speed != 0 && fabs(m_prop.automatic_rotate) < 0.001){
-+ 			float target_yaw = m_yaw + dtime * m_rotate_yaw_speed;
-+ 			if ((m_rotate_yaw_speed > 0 && m_yaw < m_dest_yaw
-+ 				&& target_yaw > m_dest_yaw) || (m_rotate_yaw_speed < 0 
-+ 				&& m_yaw > m_dest_yaw && target_yaw < m_dest_yaw)
-+ 				|| (m_rotate_yaw_speed > 0 && m_yaw < m_dest_yaw + 360
-+ 				&& target_yaw > m_dest_yaw + 360))
-+ 			{
-+ 				// destination yaw is reached
-+ 				m_yaw = m_dest_yaw;
-+ 				m_rotate_yaw_speed = 0;
-+ 			}
-+ 			else
-+ 			{
-+ 				m_yaw = target_yaw;
-+ 			}
-+ 			updateNodePos();
-+ 		}
-+ 
-+ 		if (m_yaw > 360) m_yaw -= 360;
-+ 		if (m_yaw < 0  ) m_yaw += 360;
-++>>>>>>> Jeija/rotateto
-  	}
-  
-  	void updateTexturePos()
-diff --cc src/content_sao.cpp
-index d38894b,4bd6a23..0000000
---- a/src/content_sao.cpp
-+++ b/src/content_sao.cpp
-@@@ -528,14 -515,33 +530,39 @@@ void LuaEntitySAO::step(float dtime, bo
-  			m_velocity += dtime * m_acceleration;
-  		}
-  
-++<<<<<<< HEAD
- +		if((m_prop.automatic_face_movement_dir) &&
- +				(fabs(m_velocity.Z) > 0.001 || fabs(m_velocity.X) > 0.001)){
- +			m_yaw = atan2(m_velocity.Z,m_velocity.X) * 180 / M_PI + m_prop.automatic_face_movement_dir_offset;
- +		}
-++=======
-+ 		// Automatic rotation overrides continues rotation
-+ 		// Perform this also on the server to make getyaw() work
-+ 		if(fabs(m_prop.automatic_rotate) < 0.001){
-+ 			float target_yaw = m_yaw + dtime * m_rotate_yaw_speed;
-+ 			if ((m_rotate_yaw_speed > 0 && m_yaw < m_dest_yaw
-+ 				&& target_yaw > m_dest_yaw) || (m_rotate_yaw_speed < 0 
-+ 				&& m_yaw > m_dest_yaw && target_yaw < m_dest_yaw)
-+ 				|| (m_rotate_yaw_speed > 0 && m_yaw < m_dest_yaw + 360
-+ 				&& target_yaw > m_dest_yaw + 360))
-+ 			{
-+ 				// destination yaw is reached
-+ 				m_yaw = m_dest_yaw;
-+ 				m_rotate_yaw_speed = 0;
- -			}
-++>>>>>>> Jeija/rotateto
-++	}
-+ 			else
-+ 			{
-+ 				m_yaw = target_yaw;
-+ 			}
-+ 		}
-  	}
-  
-+ 	if (m_yaw > 360) m_yaw -= 360;
-+ 	if (m_yaw < 0  ) m_yaw += 360;
-+ 
-  	if(m_registered){
- -		lua_State *L = m_env->getLua();
- -		scriptapi_luaentity_step(L, m_id, dtime);
- +		m_env->getScriptIface()->luaentity_Step(m_id, dtime);
-  	}
-  
-  	if(send_recommended == false)
-
-
-
-
-!!!!!!!!!!!!!!!!!
- Merge Sokomine/master to next failed:
-
-# On branch next
-# You have unmerged paths.
-#   (fix conflicts and run "git commit")
-#
-# Unmerged paths:
-#   (use "git add <file>..." to mark resolution)
-#
-#	both modified:      doc/lua_api.txt
-#
-no changes added to commit (use "git add" and/or "git commit -a")
-diff --cc doc/lua_api.txt
-index 303a514,5c52606..0000000
---- a/doc/lua_api.txt
-+++ b/doc/lua_api.txt
-@@@ -2121,11 -1998,9 +2121,17 @@@ Node definition (register_node
-      <all fields allowed in item definitions>,
-  
-      drawtype = "normal", -- See "Node drawtypes"
-++<<<<<<< HEAD
- +    visual_scale = 1.0,
- +    ^ Supported for drawtypes "plantlike", "signlike", "torchlike".
- +    ^ For plantlike, the image will start at the bottom of the node; for the
- +    ^ other drawtypes, the image will be centered on the node.
- +    ^ Note that positioning for "torchlike" may still change.
-++=======
-+     visual_scale = 1.0, -- supported for drawtypes "plantlike", "signlike", "torchlike"
-+                         -- for plantlike, the image will start at the bottom of the node; for the other drawtypes, the image
-+                         -- will be centered on the node
-++>>>>>>> Sokomine/master
-      tiles = {tile definition 1, def2, def3, def4, def5, def6},
-      ^ Textures of node; +Y, -Y, +X, -X, +Z, -Z (old field name: tile_images)
-      ^ List can be shortened to needed length
-
-
-
-
-!!!!!!!!!!!!!!!!!
- Merge RealBadAngel/master to next failed:
-
-# On branch next
-# You have unmerged paths.
-#   (fix conflicts and run "git commit")
-#
-# Changes to be committed:
-#
-#	modified:   src/sky.cpp
-#	new file:   textures/base/pack/moon.png
-#	new file:   textures/base/pack/moon_tonemap.png
-#	new file:   textures/base/pack/sun.png
-#	new file:   textures/base/pack/sun_tonemap.png
-#
-# Unmerged paths:
-#   (use "git add <file>..." to mark resolution)
-#
-#	both modified:      src/sky.h
-#
-diff --cc src/sky.h
-index 35c86db,6b5ae8b..0000000
---- a/src/sky.h
-+++ b/src/sky.h
-@@@ -114,7 -78,8 +114,12 @@@ private
-  	v3f m_stars[SKY_STAR_COUNT];
-  	u16 m_star_indices[SKY_STAR_COUNT*4];
-  	video::S3DVertex m_star_vertices[SKY_STAR_COUNT*4];
-++<<<<<<< HEAD
- +	LocalPlayer* m_player;
-++=======
-+ 	video::ITexture* m_sun_tonemap;
-+ 	video::ITexture* m_moon_tonemap;
-++>>>>>>> RealBadAngel/master
-  };
-  
-  #endif
-
-
-
-
-!!!!!!!!!!!!!!!!!
- Merge ShadowNinja/pcall_errfunc to next failed:
-
-# On branch next
-# You have unmerged paths.
-#   (fix conflicts and run "git commit")
-#
-# Changes to be committed:
-#
-#	modified:   src/script/common/c_content.cpp
-#	modified:   src/script/common/c_internal.cpp
-#	modified:   src/script/common/c_internal.h
-#	modified:   src/script/common/c_types.cpp
-#	modified:   src/script/cpp_api/s_base.cpp
-#	modified:   src/script/cpp_api/s_base.h
-#	modified:   src/script/cpp_api/s_entity.cpp
-#	modified:   src/script/cpp_api/s_inventory.cpp
-#	modified:   src/script/cpp_api/s_item.cpp
-#	modified:   src/script/cpp_api/s_mainmenu.cpp
-#	modified:   src/script/cpp_api/s_node.cpp
-#	modified:   src/script/cpp_api/s_nodemeta.cpp
-#	modified:   src/script/cpp_api/s_server.cpp
-#	modified:   src/script/lua_api/l_base.h
-#	modified:   src/script/lua_api/l_craft.cpp
-#	modified:   src/script/lua_api/l_noise.cpp
-#	modified:   src/script/lua_api/l_rollback.cpp
-#	modified:   src/script/lua_api/l_server.cpp
-#
-# Unmerged paths:
-#   (use "git add <file>..." to mark resolution)
-#
-#	both modified:      src/script/lua_api/l_env.cpp
-#
-diff --cc src/script/lua_api/l_env.cpp
-index bd8e500,9bed23d..0000000
---- a/src/script/lua_api/l_env.cpp
-+++ b/src/script/lua_api/l_env.cpp
-@@@ -73,9 -78,9 +78,15 @@@ void LuaABM::trigger(ServerEnvironment 
-  	pushnode(L, n, env->getGameDef()->ndef());
-  	lua_pushnumber(L, active_object_count);
-  	lua_pushnumber(L, active_object_count_wider);
-++<<<<<<< HEAD
- +	pushnode(L, neighbor, env->getGameDef()->ndef());
- +	if(lua_pcall(L, 5, 0, 0))
- +		script_error(L, "error: %s", lua_tostring(L, -1));
-++=======
-+ 	if(lua_pcall(L, 4, 0, errorhandler))
-+ 		script_error(L);
-+ 	lua_pop(L, 1); // Pop error handler
-++>>>>>>> ShadowNinja/pcall_errfunc
-  }
-  
-  // Exported functions
diff --git a/util/next/next.pl b/util/next/next.pl
deleted file mode 100755
index cecbdef..0000000
--- a/util/next/next.pl
+++ /dev/null
@@ -1,199 +0,0 @@
-#!/usr/bin/perl
-use 5.16.0;
-#use strict;
-no strict qw(refs);
-use warnings "NONFATAL" => "all";
-no warnings qw(uninitialized);
-no if $] >= 5.017011, warnings => 'experimental::smartmatch';
-use utf8;
-use lib::abs;
-
-my $what = {
-    minetest => {
-        test      => 1,
-        submodule => qq{
-games	proller	minetest_game	next
-},
-
-        merge => qq{
-proller:next_tools
-
-proller:liquid63			882
-proller:math				645
-proller:json
-proller:weather				892
-proller:liquid_send			895
-proller:liquid_default
-proller:huge_cave
-proller:weather_fog			899
-proller:wingsuit			897
-proller:collision
-proller:light_ok			931
-proller:net				
-#proller:masterserver
-proller:null
-#proller:clouds				855
-sapier:avoid_facedir_if_not_moving	879
-sapier:modmgr_fixes			884
-#ShadowNinja:bind_address		862 #crash on connect
-Zeg9:slippery				817
-#Zeg9:wieldlight				816 #no light range BUG
-MirceaKitsune:sun_moon_coloring		799
-khonkhortisan:diagonal_rail		528
-Novatux:forceload			606
-PilzAdam:vbo
-sweetbomber:spawn			744
-MirceaKitsune:brighter_sun_faces	772
-sapier:fix_crash_on_lua_exception	890
-sapier:lua_show_backtrace_on_error	891
-sapier:fix_anaglyph_mode_selectionbox_not_beeing_honored	893
-#WilliamBundy:jump_fix			866
-ShadowNinja:protection_support		856
-sapier:fix_multiplayer_server_not_saved	846
-sapier:autoupdate_anim_speed		774
-sapier:add_surface_detection_function	640
-#khonkhortisan:vertical_particles	675 #need protocol versioning
-#sfan5:minemovie			
-Jeija:rotateto				651
-ShadowNinja:more_break_particles	943
-ShadowNinja:fall_on_unknown		942
-Sokomine:master				951
-RealBadAngel:master			967
-},
-    },
-
-    minetest_game => {
-        push_no_diff => 1,
-        submodule    => qq{
-mods	proller	minetest-mod-weather-dynamic	master
-},
-        merge => qq{
-proller:sponge			185
-proller:weather
-proller:liquid63
-#proller:mod-weather
-#Zeg9:wieldlight		188
-MirceaKitsune:moonflower	175
-khonkhortisan:diagonal_rail	135
-Novatux:furnace			200 #can make 100% cpu load
-cyisfor:master			207
-},
-    },
-
-};
-
-sub file_append(;$@) {
-    my $n = shift;
-    return unless open my $fh, '>>', $n;
-    print $fh @_ ? @_ : $_;
-    @_           ? @_ : $_;
-}
-
-sub sy (@) {
-    warn @_;
-    system @_;
-    if ($? == -1) {
-        #print "failed to execute: $!\n";
-        return $?;
-    } elsif ($? & 127) {
-        #printf "child died with signal %d, %s coredump\n",($? & 127),  ($? & 128) ? 'with' : 'without';
-        return $?;
-    } else {
-        printf "child [@_] exited with value %d\n", $? >> 8 if $?;
-        return $? >> 8;
-    }
-}
-my $target = 'next';
-my $report = [];
-my $root   = lib::abs::path('.') . '/';
-REPO: for my $repo (qw(minetest_game minetest)) {
-    my $log = "$root$repo.log";
-    unlink $log;
-    my $pullroot = "https://github.com/minetest/$repo/pull/";
-    my $dir      = $root . $repo . '_' . $target;
-    sy "git clone https://github.com/proller/$repo.git $dir";
-    chdir $dir;
-    sy $_
-      for "git reset --hard",
-      "git remote add upstream https://github.com/minetest/$repo.git",
-      "git fetch upstream",
-      "git checkout upstream/master",
-      "git clean -ffd",
-      "git branch -D $target",
-      "git checkout -b $target",
-      ;
-    my $error;
-
-    for my $from (split /\n+/, $what->{$repo}{merge}) {
-        next if $from =~ /^(?:\s*#|$)/;
-        $from =~ m{^\s*(?<user>\S+)[:/](?<branch>\S+)(\s+(?<pull>\S+))?(\s+(?<comment>.+))?};
-        my $i = {%+, repo => $repo, pullfull => "$pullroot$+{pull}"};
-        #$i->{branch} = $i->{user}, $i->{user} = undef if !$i->{branch};
-        my $path = join '/', grep {$_} $i->{user}, $i->{branch};
-
-        if ($i->{repo}) {
-            sy "git remote add $i->{user} https://github.com/$i->{user}/$repo.git";
-            sy "git fetch $i->{user}";
-        }
-
-        say "merging $path to $target";
-        if (local $_ = sy "git merge --no-edit -s recursive -X patience -X ignore-all-space $path") {
-            push @$report, {%$i, status => 'fail', code => $_};
-            file_append $log, "\n\n\n\n!!!!!!!!!!!!!!!!!\n Merge $path to $target failed:\n\n";
-            sy "git status >> $log";
-            sy "git diff >> $log";
-            ++$error, last REPO if 'fail' ~~ @ARGV;
-            sy "git reset --hard";
-        } else {
-            push @$report, {%$i, status => 'ok'};
-        }
-
-    }
-
-    for my $from (split /\n+/, $what->{$repo}{submodule}) {
-        next if $from =~ /^(?:\s*#|$)/;
-        $from =~ m{^\s*(?<dir>\S+)\s+(?<user>\S+)\s+(?<repo>\S+)\s+(?<branch>\S+)(\s+(?<comment>.+))?};
-        my $i = {%+,};
-        $i->{branch} ||= 'master';
-        $i->{clone} = "https://github.com/$i->{user}/$i->{repo}.git";
-#dmp $i;
-        sy qq{
-cd $i->{dir}
-git submodule add -f $i->{clone} $i->{repo}
-cd $i->{repo}
-git reset --hard
-git fetch --all
-git checkout origin/$i->{branch}
-cd ..
-git status
-git ci -a -m "submodule add $i->{user}/$i->{repo}/$i->{branch} to $i->{dir}";
-cd ..
-}
-
-    }
-    my $diff = qx{git diff --stat origin/next};
-    unless ($what->{$repo}{push_no_diff}) {
-        unless ($diff) {
-            say "no changes";
-            goto UP;
-        }
-    }
-
-    say "changed $diff";
-    my $test = sy "cmake . -DRUN_IN_PLACE=1 && make -j4" if $what->{$repo}{test} and !$error and !('notest' ~~ @ARGV);
-    say "test = [$test]";
-    #sy "git submodule update --init --recursive";
-    sy "git push -f" if !$test and !('nopush' ~~ @ARGV);
-  UP:
-    chdir '..';
-    sy qq{git commit -m "merge log" $log};
-}
-
-unlink $root . 'report.log';
-for my $r (@$report) {
-    local $_ = join "\t", $r->{status}, "$r->{repo} $r->{user}:$r->{branch}", $r->{code}, ($r->{pull} ? $r->{pullfull} : ()), "\n";
-    print;
-    file_append $root . 'report.log', $_;
-}
-sy qq{git commit -m "report log" ${root}report.log};
-sy "git push" if !('nopush' ~~ @ARGV);
diff --git a/util/next/report.log b/util/next/report.log
deleted file mode 100644
index 5cec830..0000000
--- a/util/next/report.log
+++ /dev/null
@@ -1,43 +0,0 @@
-ok	minetest_game proller:weather		
-ok	minetest_game proller:liquid63		
-ok	minetest_game MirceaKitsune:moonflower		https://github.com/minetest/minetest_game/pull/175	
-ok	minetest_game khonkhortisan:diagonal_rail		https://github.com/minetest/minetest_game/pull/135	
-ok	minetest_game Novatux:furnace		https://github.com/minetest/minetest_game/pull/200	
-fail	minetest_game cyisfor:master	1	https://github.com/minetest/minetest_game/pull/207	
-ok	minetest proller:next_tools		
-ok	minetest proller:liquid63		https://github.com/minetest/minetest/pull/882	
-ok	minetest proller:math		https://github.com/minetest/minetest/pull/645	
-ok	minetest proller:json		
-ok	minetest proller:weather		https://github.com/minetest/minetest/pull/892	
-ok	minetest proller:liquid_send		https://github.com/minetest/minetest/pull/895	
-ok	minetest proller:huge_cave		
-ok	minetest proller:wingsuit		https://github.com/minetest/minetest/pull/897	
-ok	minetest proller:collision		
-ok	minetest proller:light_ok		https://github.com/minetest/minetest/pull/931	
-ok	minetest proller:null		
-ok	minetest proller:die		https://github.com/minetest/minetest/pull/999	
-ok	minetest proller:range		
-ok	minetest proller:make		
-fail	minetest sapier:avoid_facedir_if_not_moving	1	https://github.com/minetest/minetest/pull/879	
-fail	minetest sapier:modmgr_fixes	1	https://github.com/minetest/minetest/pull/884	
-ok	minetest Zeg9:slippery		https://github.com/minetest/minetest/pull/817	
-ok	minetest MirceaKitsune:sun_moon_coloring		https://github.com/minetest/minetest/pull/799	
-ok	minetest khonkhortisan:diagonal_rail		https://github.com/minetest/minetest/pull/528	
-fail	minetest Novatux:forceload	1	https://github.com/minetest/minetest/pull/606	
-ok	minetest PilzAdam:vbo		
-ok	minetest sweetbomber:spawn		https://github.com/minetest/minetest/pull/744	
-ok	minetest MirceaKitsune:brighter_sun_faces		https://github.com/minetest/minetest/pull/772	
-fail	minetest sapier:fix_crash_on_lua_exception	1	https://github.com/minetest/minetest/pull/890	
-ok	minetest sapier:lua_show_backtrace_on_error		https://github.com/minetest/minetest/pull/891	
-ok	minetest sapier:fix_anaglyph_mode_selectionbox_not_beeing_honored		https://github.com/minetest/minetest/pull/893	
-fail	minetest ShadowNinja:protection_support	1	https://github.com/minetest/minetest/pull/856	
-ok	minetest sapier:fix_multiplayer_server_not_saved		https://github.com/minetest/minetest/pull/846	
-ok	minetest sapier:autoupdate_anim_speed		https://github.com/minetest/minetest/pull/774	
-ok	minetest sapier:add_surface_detection_function		https://github.com/minetest/minetest/pull/640	
-fail	minetest Jeija:rotateto	1	https://github.com/minetest/minetest/pull/651	
-ok	minetest ShadowNinja:more_break_particles		https://github.com/minetest/minetest/pull/943	
-ok	minetest ShadowNinja:fall_on_unknown		https://github.com/minetest/minetest/pull/942	
-fail	minetest Sokomine:master	1	https://github.com/minetest/minetest/pull/951	
-fail	minetest RealBadAngel:master	1	https://github.com/minetest/minetest/pull/967	
-ok	minetest celeron55:duplifix		https://github.com/minetest/minetest/pull/1000	
-fail	minetest ShadowNinja:pcall_errfunc	1	https://github.com/minetest/minetest/pull/995	




!!!!!!!!!!!!!!!!!
 Merge sapier/modmgr_fixes to next failed:

diff --git a/src/mandelbulber/algebra.hpp b/src/mandelbulber/algebra.hpp
deleted file mode 100644
index ae63bf2..0000000
--- a/src/mandelbulber/algebra.hpp
+++ /dev/null
@@ -1,161 +0,0 @@
-/********************************************************
- /                   3D math                             *
- /                                                       *
- / author: Krzysztof Marczak                             *
- / contact: buddhi1980@gmail.com                         *
- / licence: GNU GPL                                      *
- ********************************************************/
-
-#ifndef ALGEBRA_H_
-#define ALGEBRA_H_
-
-#include <math.h>
-
-/************************* vector 3D **********************/
-class CVector3
-{
-public:
-	inline CVector3()
-	{
-		x = 0;
-		y = 0;
-		z = 0;
-	}
-	inline CVector3(double x_init, double y_init, double z_init)
-	{
-		x = x_init;
-		y = y_init;
-		z = z_init;
-	}
-	inline CVector3(double alfa, double beta)
-	{
-		x = cos(beta) * cos(alfa);
-		y = cos(beta) * sin(alfa);
-		z = sin(beta);
-	}
-	inline CVector3(const CVector3 &vector)
-	{
-		x = vector.x;
-		y = vector.y;
-		z = vector.z;
-	}
-	inline CVector3 operator+(const CVector3 &vector) const
-	{
-		return CVector3(x + vector.x, y + vector.y, z + vector.z);
-	}
-	inline CVector3 operator-(const CVector3 &vector) const
-	{
-		return CVector3(x - vector.x, y - vector.y, z - vector.z);
-	}
-	inline CVector3 operator*(const double &scalar) const
-	{
-		return CVector3(x * scalar, y * scalar, z * scalar);
-	}
-	inline CVector3& operator=(const CVector3 &vector)
-	{
-		x = vector.x;
-		y = vector.y;
-		z = vector.z;
-		return *this;
-	}
-	inline CVector3& operator+=(const CVector3 &vector)
-	{
-		x += vector.x;
-		y += vector.y;
-		z += vector.z;
-		return *this;
-	}
-	inline CVector3& operator-=(const CVector3 &vector)
-	{
-		x -= vector.x;
-		y -= vector.y;
-		z -= vector.z;
-		return *this;
-	}
-	inline CVector3& operator*=(const double &scalar)
-	{
-		x *= scalar;
-		y *= scalar;
-		z *= scalar;
-		return *this;
-	}
-	inline double Length() const
-	{
-		return sqrt(x * x + y * y + z * z);
-	}
-	inline double Dot(const CVector3& vector) const
-	{
-		return x * vector.x + y * vector.y + z * vector.z;
-	}
-	inline CVector3 Cross(const CVector3& v)
-	{
-		CVector3 c;
-		c.x =  y*v.z - z*v.y;
-	  c.y = -x*v.z + z*v.x;
-	  c.z =  x*v.y - y*v.x;
-	  return c;
-	}
-	inline double Normalize() //returns normalization factor
-	{
-		double norm = 1.0 / Length();
-		x = x * norm;
-		y = y * norm;
-		z = z * norm;
-		return norm;
-	}
-	inline double GetAlfa() const
-	{
-		return atan2(y, x);
-	}
-	inline double GetBeta() const
-	{
-		return atan2(z, sqrt(x * x + y * y));
-	}
-	double x;
-	double y;
-	double z;
-};
-
-/************************* matrix 3x3 (fast) *****************/
-class CMatrix33
-{
-public:
-	CMatrix33();
-	CMatrix33(const CMatrix33 &matrix);
-	CMatrix33 operator*(const CMatrix33 &matrix) const;
-	CVector3 operator*(const CVector3 &vector) const;
-	CMatrix33& operator=(const CMatrix33&);
-	double m11;
-	double m12;
-	double m13;
-	double m21;
-	double m22;
-	double m23;
-	double m31;
-	double m32;
-	double m33;
-};
-
-/************************* rotation matrix *******************/
-class CRotationMatrix
-{
-public:
-	CRotationMatrix();
-	void RotateX(double angle);
-	void RotateY(double angle);
-	void RotateZ(double angle);
-	void Null();
-	CVector3 RotateVector(const CVector3& vector) const;
-	double GetAlfa() const;
-	double GetBeta() const;
-	double GetGamma() const;
-	void SetRotation(double angles[3]);
-	void SetRotation(double alfa, double beta, double gamma);
-	CRotationMatrix Transpose(void) const;
-	CMatrix33 GetMatrix() {return matrix;}
-private:
-	CMatrix33 matrix;
-	bool zero;
-};
-
-#endif /* ALGEBRA_H_ */
diff --git a/src/mandelbulber/common_math.h b/src/mandelbulber/common_math.h
deleted file mode 100644
index e9a9d71..0000000
--- a/src/mandelbulber/common_math.h
+++ /dev/null
@@ -1,51 +0,0 @@
-/*
- * common_math.h
- *
- *  Created on: 2010-01-23
- *      Author: krzysztof marczak
- */
-
-#ifndef COMMON_MATH_H_
-#define COMMON_MATH_H_
-
-#include "algebra.hpp"
-
-struct sVectorsAround
-{
-	double alpha;
-	double beta;
-	CVector3 v;
-	int R;
-	int G;
-	int B;
-	bool notBlack;
-};
-
-struct sVector
-{
-	double x;
-	double y;
-	double z;
-};
-
-struct sSortZ
-{
-	float z;
-	int i;
-};
-
-enum enumPerspectiveType
-{
-	threePoint = 0, fishEye = 1, equirectangular = 2, fishEyeCut = 3
-};
-
-//int abs(int v);
-int Random(int max);
-double dMax(double a, double b, double c);
-double dMin(double a, double b, double c);
-void QuickSortZBuffer(sSortZ *dane, int l, int p);
-CVector3 Projection3D(CVector3 point, CVector3 vp, CRotationMatrix mRot, enumPerspectiveType perspectiveType, double fov, double zoom);
-inline double SmoothConditionAGreaterB(double a, double b, double sharpness) {return 1.0 / (1.0 + exp(sharpness * (b - a)));}
-inline double SmoothConditionALessB(double a, double b, double sharpness) {return 1.0 / (1.0 + exp(sharpness * (a - b)));}
-
-#endif /* COMMON_MATH_H_ */
diff --git a/src/mandelbulber/fractal.cpp b/src/mandelbulber/fractal.cpp
deleted file mode 100644
index 079cc74..0000000
--- a/src/mandelbulber/fractal.cpp
+++ /dev/null
@@ -1,1502 +0,0 @@
-/********************************************************
- /                   MANDELBULBER                        *
- /                                                       *
- / author: Krzysztof Marczak                             *
- / contact: buddhi1980@gmail.com                         *
- / licence: GNU GPL                                      *
- ********************************************************/
-
-/*
- * fractal.cpp
- *
- *  Created on: 2010-01-23
- *      Author: krzysztof
- */
-
-//#include "Render3D.h"
-//#include "interface.h"
-//#include "primitives.h"
-#include <stdlib.h>
-
-#include "fractal.h"
-#include "algebra.cpp"
-
-/**
- * Compute the fractal at the point, in one of the various modes
- *
- * Mode: normal: Returns distance
- *		 fake_ao: Returns minimum radius
- *		 colouring: Returns colour index
- *		 delta_DE1, delta_DE2: Returns radius
- */
-
-unsigned int MixNumbers(double a, double b, double c)
-{
-	unsigned int result = int(a*12356312.0)^int(b*23564234.0)^int(c*35564353.0);
-	//printf("%ud\n", result);
-	return result;
-}
-
-int Noise(int seed)
-{
-	int x = seed;
-	x = (x<<7) ^ x;
-	return abs((x * (x * x * 15731 + 789221) + 1376312589) & 0x7fffffff);
-}
-
-
-template<int Mode>
-double Compute(CVector3 z, const sFractal &par, int *iter_count)
-{
-	int L;
-	double distance = 0;
-
-	double w = 0;
-	double constantw = 0;
-
-	CVector3 dz(1.0, 0.0, 0.0);
-	CVector3 one(1.0, 0.0, 0.0);
-	double r_dz = 1;
-	double ph_dz = 0;
-	double th_dz = 0;
-	double p = par.doubles.power; //mandelbulb power
-	int N = par.doubles.N;
-
-	CVector3 constant;
-
-	double fixedRadius = par.mandelbox.doubles.foldingSphericalFixed;
-	double fR2 = fixedRadius * fixedRadius;
-	double minRadius = par.mandelbox.doubles.foldingSphericalMin;
-	double mR2 = minRadius * minRadius;
-	double tglad_factor1 = fR2 / mR2;
-
-	double tgladDE = 1.0;
-
-	double scale = par.mandelbox.doubles.scale;
-
-	enumFractalFormula actualFormula = par.formula;
-	if (actualFormula == kaleidoscopic || actualFormula == menger_sponge) 
-		tgladDE = 1.0;
-
-	double tgladColor = 1.0;
-
-	if (par.juliaMode)
-	{
-		constant = par.doubles.julia;
-	}
-	else
-	{
-		constant = z * par.doubles.constantFactor;
-	}
-
-	bool hybridEnabled = false;
-	if (actualFormula == hybrid) hybridEnabled = true;
-
-	double r = z.Length();
-
-	double min = 1e200;
-	for (L = 0; L < N; L++)
-	{
-		if (hybridEnabled)
-		{
-			int tempL = L;
-			if(tempL > (int)par.formulaSequence.size()-1) tempL = (int)par.formulaSequence.size()-1;
-			actualFormula = par.formulaSequence[tempL];
-			p = par.hybridPowerSequence[tempL];
-			scale = p;
-		}
-
-		if (par.IFS.foldingMode)
-		{
-			if (par.IFS.absX) z.x = fabs(z.x);
-			if (par.IFS.absY) z.y = fabs(z.y);
-			if (par.IFS.absZ) z.z = fabs(z.z);
-
-			for (int i = 0; i < IFS_VECTOR_COUNT; i++)
-			{
-				if (par.IFS.enabled[i])
-				{
-					z = par.IFS.rot[i].RotateVector(z);
-					double length = z.Dot(par.IFS.doubles.direction[i]);
-
-					if (length < par.IFS.doubles.distance[i])
-					{
-						z -= par.IFS.doubles.direction[i] * 2.0 * (length - par.IFS.doubles.distance[i]);
-					}
-
-				}
-			}
-
-			z = par.IFS.mainRot.RotateVector(z - par.IFS.doubles.offset) + par.IFS.doubles.offset;
-			z *= par.IFS.doubles.scale;
-			z -= par.IFS.doubles.offset * (par.IFS.doubles.scale - 1.0);
-
-			r = z.Length();
-		}
-
-		if (par.tgladFoldingMode)
-		{
-			if (z.x > par.doubles.foldingLimit)
-			{
-				z.x = par.doubles.foldingValue - z.x;
-				tgladColor *= 0.9;
-			}
-			else if (z.x < -par.doubles.foldingLimit)
-			{
-				z.x = -par.doubles.foldingValue - z.x;
-				tgladColor *= 0.9;
-			}
-			if (z.y > par.doubles.foldingLimit)
-			{
-				z.y = par.doubles.foldingValue - z.y;
-				tgladColor *= 0.9;
-			}
-			else if (z.y < -par.doubles.foldingLimit)
-			{
-				z.y = -par.doubles.foldingValue - z.y;
-				tgladColor *= 0.9;
-			}
-			if (z.z > par.doubles.foldingLimit)
-			{
-				z.z = par.doubles.foldingValue - z.z;
-				tgladColor *= 0.9;
-			}
-			else if (z.z < -par.doubles.foldingLimit)
-			{
-				z.z = -par.doubles.foldingValue - z.z;
-				tgladColor *= 0.9;
-			}
-			r = z.Length();
-		}
-
-		if (par.sphericalFoldingMode)
-		{
-			double fR2_2 = par.doubles.foldingSphericalFixed * par.doubles.foldingSphericalFixed;
-			double mR2_2 = par.doubles.foldingSphericalMin * par.doubles.foldingSphericalMin;
-			double r2_2 = r * r;
-			double tglad_factor1_2 = fR2_2 / mR2_2;
-
-			if (r2_2 < mR2_2)
-			{
-				z = z * tglad_factor1_2;
-				tgladDE *= tglad_factor1_2;
-				tgladColor += 1;
-			}
-			else if (r2_2 < fR2_2)
-			{
-				double tglad_factor2_2 = fR2_2 / r2_2;
-				z = z * tglad_factor2_2;
-				tgladDE *= tglad_factor2_2;
-				tgladColor += 10;
-			}
-			r = z.Length();
-		}
-
-		switch (actualFormula)
-		{
-			case trig_DE:
-			{
-				double r1 = pow(r, p - 1);
-				double r2 = r1 * r;
-				double th = z.GetAlfa();
-				double ph = -z.GetBeta();
-				if (Mode == 0)
-				{
-					double p_r1_rdz = p * r1 * r_dz;
-					double ph_phdz = (p - 1.0) * ph + ph_dz;
-					double th_thdz = (p - 1.0) * th + th_dz;
-					CVector3 rot(th_thdz, ph_phdz);
-					dz = rot * p_r1_rdz + one;
-					r_dz = dz.Length();
-					th_dz = dz.GetAlfa();
-					ph_dz = -dz.GetBeta();
-				}
-				CVector3 rot(p * th, p * ph);
-				z = rot * r2 + constant;
-				r = z.Length();
-				break;
-			}
-			case trig_optim:
-			{
-				//optimisation based on: http://www.fractalforums.com/mandelbulb-implementation/realtime-renderingoptimisations/
-				double th0 = asin(z.z / r);
-				double ph0 = atan2(z.y, z.x);
-				double rp = pow(r, p - 1.0);
-				double th = th0 * p;
-				double ph = ph0 * p;
-				double cth = cos(th);
-				r_dz = rp * r_dz * p + 1.0;
-				rp *= r;
-				z = CVector3(cth * cos(ph), cth * sin(ph), sin(th)) * rp + constant;
-				r = z.Length();
-				break;
-			}
-			case mandelbulb2:
-			{
-				double temp, tempR;
-				tempR = sqrt(z.x * z.x + z.y * z.y);
-				z *= (1.0 / tempR);
-				temp = z.x * z.x - z.y * z.y;
-				z.y = 2.0 * z.x * z.y;
-				z.x = temp;
-				z *= tempR;
-
-				tempR = sqrt(z.y * z.y + z.z * z.z);
-				z *= (1.0 / tempR);
-				temp = z.y * z.y - z.z * z.z;
-				z.z = 2.0 * z.y * z.z;
-				z.y = temp;
-				z *= tempR;
-
-				tempR = sqrt(z.x * z.x + z.z * z.z);
-				z *= (1.0 / tempR);
-				temp = z.x * z.x - z.z * z.z;
-				z.z = 2.0 * z.x * z.z;
-				z.x = temp;
-				z *= tempR;
-
-				z = z * r;
-				z += constant;
-				r = z.Length();
-				break;
-			}
-			case mandelbulb3:
-			{
-				double temp, tempR;
-
-				double sign = 1.0;
-				double sign2 = 1.0;
-
-				if (z.x < 0) sign2 = -1.0;
-				tempR = sqrt(z.x * z.x + z.y * z.y);
-				z *= (1.0 / tempR);
-				temp = z.x * z.x - z.y * z.y;
-				z.y = 2.0 * z.x * z.y;
-				z.x = temp;
-				z *= tempR;
-
-				if (z.x < 0) sign = -1.0;
-				tempR = sqrt(z.x * z.x + z.z * z.z);
-				z *= (1.0 / tempR);
-				temp = z.x * z.x - z.z * z.z;
-				z.z = 2.0 * z.x * z.z * sign2;
-				z.x = temp * sign;
-				z *= tempR;
-
-				z = z * r;
-				z += constant;
-				r = z.Length();
-				break;
-			}
-			case mandelbulb4:
-			{
-				double rp = pow(r, p - 1);
-
-				double angZ = atan2(z.y, z.x);
-				double angY = atan2(z.z, z.x);
-				double angX = atan2(z.z, z.y);
-
-				CRotationMatrix rotM;
-				rotM.RotateX(angX * (p - 1));
-				rotM.RotateY(angY * (p - 1));
-				rotM.RotateZ(angZ * (p - 1));
-
-				z = rotM.RotateVector(z) * rp + constant;
-				r = z.Length();
-				break;
-			}
-			case xenodreambuie:
-			{
-				double rp = pow(r, p);
-				double th = atan2(z.y, z.x);
-				double ph = acos(z.z / r);
-				if (ph > 0.5 * M_PI)
-				{
-					ph = M_PI - ph;
-				}
-				else if (ph < -0.5 * M_PI)
-				{
-					ph = -M_PI - ph;
-				}
-				z.x = rp * cos(th * p) * sin(ph * p);
-				z.y = rp * sin(th * p) * sin(ph * p);
-				z.z = rp * cos(ph * p);
-				z = z + constant;
-
-				r = z.Length();
-				break;
-			}
-			case fast_trig:
-			{
-				double x2 = z.x * z.x;
-				double y2 = z.y * z.y;
-				double z2 = z.z * z.z;
-				double temp = 1.0 - z2 / (x2 + y2);
-				double newx = (x2 - y2) * temp;
-				double newy = 2.0 * z.x * z.y * temp;
-				double newz = -2.0 * z.z * sqrt(x2 + y2);
-				z.x = newx + constant.x;
-				z.y = newy + constant.y;
-				z.z = newz + constant.z;
-				r = z.Length();
-				break;
-			}
-			case minus_fast_trig:
-			{
-				double x2 = z.x * z.x;
-				double y2 = z.y * z.y;
-				double z2 = z.z * z.z;
-				double temp = 1.0 - z2 / (x2 + y2);
-				double newx = (x2 - y2) * temp;
-				double newy = 2.0 * z.x * z.y * temp;
-				double newz = 2.0 * z.z * sqrt(x2 + y2);
-				z.x = newx + constant.x;
-				z.y = newy + constant.y;
-				z.z = newz + constant.z;
-				r = z.Length();
-				break;
-			}
-			case hypercomplex:
-			{
-				CVector3 newz(z.x * z.x - z.y * z.y - z.z * z.z - w * w, 2.0 * z.x * z.y - 2.0 * w * z.z, 2.0 * z.x * z.z - 2.0 * z.y * w);
-				double neww = 2.0 * z.x * w - 2.0 * z.y * z.z;
-				z = newz + constant;
-				w = neww;
-				r = sqrt(z.x * z.x + z.y * z.y + z.z * z.z + w * w);
-				break;
-			}
-			case quaternion:
-			{
-				CVector3 newz(z.x * z.x - z.y * z.y - z.z * z.z - w * w, 2.0 * z.x * z.y, 2.0 * z.x * z.z);
-				double neww = 2.0 * z.x * w;
-				z = newz + constant;
-				w = neww;
-				r = sqrt(z.x * z.x + z.y * z.y + z.z * z.z + w * w);
-				break;
-			}
-			case menger_sponge:
-			{
-				double temp;
-				z.x = fabs(z.x);
-				z.y = fabs(z.y);
-				z.z = fabs(z.z);
-				if (z.x - z.y < 0)
-				{
-					temp = z.y;
-					z.y = z.x;
-					z.x = temp;
-				}
-				if (z.x - z.z < 0)
-				{
-					temp = z.z;
-					z.z = z.x;
-					z.x = temp;
-				}
-				if (z.y - z.z < 0)
-				{
-					temp = z.z;
-					z.z = z.y;
-					z.y = temp;
-				}
-
-				if (Mode == colouring)
-				{
-					double length2 = z.Length();
-					if (length2 < min) min = length2;
-				}
-
-				z *= 3.0;
-
-				z.x -= 2.0;
-				z.y -= 2.0;
-				if (z.z > 1.0) z.z -= 2.0;
-				r = z.Length();
-				tgladDE *= 3.0;
-				break;
-			}
-			case tglad:
-			{
-				if (par.mandelbox.rotationsEnabled)
-				{
-					bool lockout = false;
-					z = par.mandelbox.rot[0][0].RotateVector(z);
-					if (z.x > par.mandelbox.doubles.foldingLimit)
-					{
-						z.x = par.mandelbox.doubles.foldingValue - z.x;
-						tgladColor += par.mandelbox.doubles.colorFactorX;
-						lockout = true;
-					}
-					z = par.mandelbox.rotinv[0][0].RotateVector(z);
-
-					z = par.mandelbox.rot[1][0].RotateVector(z);
-					if (!lockout && z.x < -par.mandelbox.doubles.foldingLimit)
-					{
-						z.x = -par.mandelbox.doubles.foldingValue - z.x;
-						tgladColor += par.mandelbox.doubles.colorFactorX;
-					}
-					z = par.mandelbox.rotinv[1][0].RotateVector(z);
-
-					lockout = false;
-					z = par.mandelbox.rot[0][1].RotateVector(z);
-					if (z.y > par.mandelbox.doubles.foldingLimit)
-					{
-						z.y = par.mandelbox.doubles.foldingValue - z.y;
-						tgladColor += par.mandelbox.doubles.colorFactorY;
-						lockout = true;
-					}
-					z = par.mandelbox.rotinv[0][1].RotateVector(z);
-
-					z = par.mandelbox.rot[1][1].RotateVector(z);
-					if (!lockout && z.y < -par.mandelbox.doubles.foldingLimit)
-					{
-						z.y = -par.mandelbox.doubles.foldingValue - z.y;
-						tgladColor += par.mandelbox.doubles.colorFactorY;
-					}
-					z = par.mandelbox.rotinv[1][1].RotateVector(z);
-
-					lockout = false;
-					z = par.mandelbox.rot[0][2].RotateVector(z);
-					if (z.z > par.mandelbox.doubles.foldingLimit)
-					{
-						z.z = par.mandelbox.doubles.foldingValue - z.z;
-						tgladColor += par.mandelbox.doubles.colorFactorZ;
-						lockout = true;
-					}
-					z = par.mandelbox.rotinv[0][2].RotateVector(z);
-
-					z = par.mandelbox.rot[1][2].RotateVector(z);
-					if (!lockout && z.z < -par.mandelbox.doubles.foldingLimit)
-					{
-						z.z = -par.mandelbox.doubles.foldingValue - z.z;
-						tgladColor += par.mandelbox.doubles.colorFactorZ;
-					}
-					z = par.mandelbox.rotinv[1][2].RotateVector(z);
-				}
-				else
-				{
-					if (z.x > par.mandelbox.doubles.foldingLimit)
-					{
-						z.x = par.mandelbox.doubles.foldingValue - z.x;
-						tgladColor += par.mandelbox.doubles.colorFactorX;
-					}
-					else if (z.x < -par.mandelbox.doubles.foldingLimit)
-					{
-						z.x = -par.mandelbox.doubles.foldingValue - z.x;
-						tgladColor += par.mandelbox.doubles.colorFactorX;
-					}
-					if (z.y > par.mandelbox.doubles.foldingLimit)
-					{
-						z.y = par.mandelbox.doubles.foldingValue - z.y;
-						tgladColor += par.mandelbox.doubles.colorFactorY;
-					}
-					else if (z.y < -par.mandelbox.doubles.foldingLimit)
-					{
-						z.y = -par.mandelbox.doubles.foldingValue - z.y;
-						tgladColor += par.mandelbox.doubles.colorFactorY;
-					}
-					if (z.z > par.mandelbox.doubles.foldingLimit)
-					{
-						z.z = par.mandelbox.doubles.foldingValue - z.z;
-						tgladColor += par.mandelbox.doubles.colorFactorZ;
-					}
-					else if (z.z < -par.mandelbox.doubles.foldingLimit)
-					{
-						z.z = -par.mandelbox.doubles.foldingValue - z.z;
-						tgladColor += par.mandelbox.doubles.colorFactorZ;
-					}
-				}
-
-				r = z.Length();
-				double r2 = r * r;
-
-				z += par.mandelbox.doubles.offset;
-
-				if (r2 < mR2)
-				{
-					z *= tglad_factor1;
-					tgladDE *= tglad_factor1;
-					tgladColor += par.mandelbox.doubles.colorFactorSp1;
-				}
-				else if (r2 < fR2)
-				{
-					double tglad_factor2 = fR2 / r2;
-					z *= tglad_factor2;
-					tgladDE *= tglad_factor2;
-					tgladColor += par.mandelbox.doubles.colorFactorSp2;
-				}
-
-				z -= par.mandelbox.doubles.offset;
-
-				z = par.mandelbox.mainRot.RotateVector(z);
-
-				z = z * scale + constant;
-				tgladDE = tgladDE*fabs(scale)+1.0;
-
-				r = z.Length();
-				break;
-			}
-
-			case generalizedFoldBox:
-			{
-				//Reference: http://www.fractalforums.com/new-theories-and-research/generalized-box-fold/msg36503/#msg36503
-
-				int i;
-				const CVector3 *Nv;
-				int sides;
-
-				Nv = par.genFoldBox.Nv_tet;
-				sides = par.genFoldBox.sides_tet;
-
-				if (par.genFoldBox.type == foldCube)
-				{
-					Nv = par.genFoldBox.Nv_cube;
-					sides = par.genFoldBox.sides_cube;
-				}
-				else if (par.genFoldBox.type == foldOct)
-				{
-					Nv = par.genFoldBox.Nv_oct;
-					sides = par.genFoldBox.sides_oct;
-				}
-				else if (par.genFoldBox.type == foldDodeca)
-				{
-					Nv = par.genFoldBox.Nv_dodeca;
-					sides = par.genFoldBox.sides_dodeca;
-				}
-				else if (par.genFoldBox.type == foldOctCube)
-				{
-					Nv = par.genFoldBox.Nv_oct_cube;
-					sides = par.genFoldBox.sides_oct_cube;
-				}
-				else if (par.genFoldBox.type == foldIcosa)
-				{
-					Nv = par.genFoldBox.Nv_icosa;
-					sides = par.genFoldBox.sides_icosa;
-				}
-				else if (par.genFoldBox.type == foldBox6)
-				{
-					Nv = par.genFoldBox.Nv_box6;
-					sides = par.genFoldBox.sides_box6;
-				}
-				else if (par.genFoldBox.type == foldBox5)
-				{
-					Nv = par.genFoldBox.Nv_box5;
-					sides = par.genFoldBox.sides_box5;
-				}
-
-        double melt = par.mandelbox.doubles.melt;
-        double solid = par.mandelbox.doubles.solid;
-
-				// Find the closest cutting plane if any that cuts the line between the origin and z.
-				// Line is parameterized as X = Y + L*a;
-				// Cutting plane is X.Dot(Nv) = Solid.
-				// (Y + L*a).Dot(Nv) = solid.
-				// a = (solid - Y.Dot(Nv))/L.Dot(Nv) = b/c
-				CVector3 L = z;
-				double a = 1;
-				CVector3 Y; // Y is the origin in this case.
-				int side = -1;
-				double b, c;
-
-				for (i = 0; i < sides; i++)
-				{
-					b = solid;
-					c = L.Dot(Nv[i]);
-					// A bit subtile here. a_r must be positive and I want to avoid divide by zero.
-					if ((c > 0) && ((a * c) > b))
-					{
-						side = i;
-						a = b / c;
-					}
-				}
-
-				// If z is above the foldingValue we may have to fold. Else early out.
-				if (side != -1)
-				{ // mirror check
-					int side_m = side;
-					CVector3 Nv_m = Nv[side_m];
-					CVector3 X_m = z - Nv_m * (z.Dot(Nv_m) - solid);
-
-					// Find any plane (Nv_r) closest to X_m that cuts the line between Nv_m and X_m.
-					// Nv_m cross Nv_r will define a possible rotation axis.
-					// a = (solid - Y.Dot(Nv)/L.Dot(Nv) = b/c.
-					L = X_m - Nv_m;
-					Y = Nv_m;
-					a = 1;
-					side = -1;
-
-					for (i = 0; i < sides; i++)
-					{
-						if (i != side_m)
-						{
-							b = solid - Y.Dot(Nv[i]);
-							c = L.Dot(Nv[i]);
-							// A bit subtile here. a_r must be positive and I want to avoid divide by zero.
-							if ((c > 0) && ((a * c) > b))
-							{
-								side = i;
-								a = b / c;
-							}
-						}
-					}
-
-					// Was a cutting plane found?
-					if (side != -1)
-					{ // rotation check
-						CVector3 Xmr_intersect = Y + L * a;
-						int side_r = side;
-						CVector3 Nv_r = Nv[side_r];
-						// The axis of rotation is define by the cross product of Nv_m and Nv_r and
-						// the intersection of the line between Nv_m and Nv_r and  Xmr_intersect.
-						CVector3 L_r = Nv_m.Cross(Nv_r);
-						// The closest point betwee z and the line of rotation can be found by minimizing
-						// the square of the distance (D) between z and the line
-						// X = Xmr_intersect + L_r * a_rmin.
-						// Setting dD/da_rmin equal to zero and solving for a_rmin.
-						double a_rmin = (z.Dot(L_r) - Xmr_intersect.Dot(L_r)) / (L_r.Dot(L_r));
-
-						// force a_rmin to be positive. I think I made an even number of sign errors here.
-						if (a_rmin < 0)
-						{
-							a_rmin = -a_rmin;
-							L_r = L_r * (-1);
-						}
-						CVector3 X_r = Xmr_intersect + L_r * a_rmin;
-
-						// Find any plane (Nv_i) closest to Xmr_intersect that cuts the line between
-						// Xmr_intersect and X_r. This will define a possible inversion point.
-						// a = (solid - Y.Dot(Nv)/L.Dot(Nv) = b/c.
-						L = X_r - Xmr_intersect;
-						Y = Xmr_intersect;
-						a = 1;
-						side = -1;
-
-						for (i = 0; i < sides; i++)
-						{
-							if ((i != side_m) && (i != side_r))
-							{
-								b = solid - Y.Dot(Nv[i]);
-								c = L.Dot(Nv[i]);
-								// A bit subtile here. a must be positive and I want to avoid divide by zero.
-								if ((c > 0) && ((a * c) > b))
-								{
-									side = i;
-									a = b / c;
-								}
-							}
-						}
-
-						if (side != -1)
-						{ // inversion check
-							// Only inversion point possible but still need to check for melt.
-
-							CVector3 X_i = Y + L * a;
-							CVector3 z2X = X_i - z;
-							// Is z above the melt layer.
-							if (z2X.Dot(z2X) > (melt * melt))
-							{
-								double z2X_mag = z2X.Length();
-								z = z + z2X * (2 * (z2X_mag - melt) / (z2X_mag + .00000001));
-								tgladColor += par.mandelbox.doubles.colorFactorZ;
-							}
-						}
-						else
-						{
-							// Only rotation line possible but still need to check for melt.
-							// Is z above the melt layer.
-							CVector3 z2X = X_r - z;
-							if (z2X.Dot(z2X) > (melt * melt))
-							{
-								double z2X_mag = z2X.Length();
-								z = z + z2X * (2 * (z2X_mag - melt) / (z2X_mag + .00000001));
-								tgladColor += par.mandelbox.doubles.colorFactorY;
-							}
-						}
-
-					}
-					else
-					{
-						// Only mirror plane possible but still need to check for melt.
-						CVector3 z2X = X_m - z;
-						if (z2X.Dot(z2X) > (melt * melt))
-						{
-							double z2X_mag = z2X.Length();
-							z = z + z2X * (2 * (z2X_mag - melt) / (z2X_mag + .00000001));
-							tgladColor += par.mandelbox.doubles.colorFactorX;
-						}
-					}
-				} // outside solid
-
-				r = z.Length();
-				double r2 = r * r;
-
-				z += par.mandelbox.doubles.offset;
-
-				if (r2 < mR2)
-				{
-					z *= tglad_factor1;
-					tgladDE *= tglad_factor1;
-					tgladColor += par.mandelbox.doubles.colorFactorSp1;
-				}
-				else if (r2 < fR2)
-				{
-					double tglad_factor2 = fR2 / r2;
-					z *= tglad_factor2;
-					tgladDE *= tglad_factor2;
-					tgladColor += par.mandelbox.doubles.colorFactorSp2;
-				}
-
-				z -= par.mandelbox.doubles.offset;
-
-				z = par.mandelbox.mainRot.RotateVector(z);
-
-				z = z * scale + constant;
-				tgladDE = tgladDE * fabs(scale) + 1.0;
-
-				r = z.Length();
-				break;
-			}
-
-			case smoothMandelbox:
-			{
-				double sm = par.mandelbox.doubles.sharpness;
-
-				double zk1 = SmoothConditionAGreaterB(z.x, par.mandelbox.doubles.foldingLimit,sm);
-				double zk2 = SmoothConditionALessB(z.x, -par.mandelbox.doubles.foldingLimit,sm);
-				z.x = z.x * (1.0 - zk1) + (par.mandelbox.doubles.foldingValue - z.x) * zk1;
-				z.x = z.x * (1.0 - zk2) + (-par.mandelbox.doubles.foldingValue - z.x) * zk2;
-				tgladColor += (zk1 + zk2) * par.mandelbox.doubles.colorFactorX;
-
-				double zk3 = SmoothConditionAGreaterB(z.y, par.mandelbox.doubles.foldingLimit,sm);
-				double zk4 = SmoothConditionALessB(z.y, -par.mandelbox.doubles.foldingLimit,sm);
-				z.y = z.y * (1.0 - zk3) + (par.mandelbox.doubles.foldingValue - z.y) * zk3;
-				z.y = z.y * (1.0 - zk4) + (-par.mandelbox.doubles.foldingValue - z.y) * zk4;
-				tgladColor += (zk3 + zk4) * par.mandelbox.doubles.colorFactorY;
-
-				double zk5 = SmoothConditionAGreaterB(z.z, par.mandelbox.doubles.foldingLimit,sm);
-				double zk6 = SmoothConditionALessB(z.z, -par.mandelbox.doubles.foldingLimit,sm);
-				z.z = z.z * (1.0 - zk5) + (par.mandelbox.doubles.foldingValue - z.z) * zk5;
-				z.z = z.z * (1.0 - zk6) + (-par.mandelbox.doubles.foldingValue - z.z) * zk6;
-				tgladColor += (zk5 + zk6) * par.mandelbox.doubles.colorFactorZ;
-
-				r = z.Length();
-				double r2 = r * r;
-				double tglad_factor2 = fR2 / r2;
-				double rk1 = SmoothConditionALessB(r2, mR2, sm);
-				double rk2 = SmoothConditionALessB(r2, fR2, sm);
-				double rk21 = (1.0 - rk1) * rk2;
-
-				z = z * (1.0 - rk1) + z * (tglad_factor1 * rk1);
-				z = z * (1.0 - rk21) + z * (tglad_factor2 * rk21);
-				tgladDE = tgladDE * (1.0 - rk1) + tgladDE * (tglad_factor1 * rk1);
-				tgladDE = tgladDE * (1.0 - rk21) + tgladDE * (tglad_factor2 * rk21);
-				tgladColor += rk1 * par.mandelbox.doubles.colorFactorSp1;
-				tgladColor += rk21 * par.mandelbox.doubles.colorFactorSp2;
-
-				z = par.mandelbox.mainRot.RotateVector(z);
-				z = z * scale + constant;
-
-				tgladDE = tgladDE * fabs(scale) + 1.0;
-				r = z.Length();
-				break;
-			}
-			case foldingIntPow2:
-			{
-				if (z.x > par.doubles.FoldingIntPowFoldFactor) z.x = par.doubles.FoldingIntPowFoldFactor * 2.0 - z.x;
-				else if (z.x < -par.doubles.FoldingIntPowFoldFactor) z.x = -par.doubles.FoldingIntPowFoldFactor * 2.0 - z.x;
-
-				if (z.y > par.doubles.FoldingIntPowFoldFactor) z.y = par.doubles.FoldingIntPowFoldFactor * 2.0 - z.y;
-				else if (z.y < -par.doubles.FoldingIntPowFoldFactor) z.y = -par.doubles.FoldingIntPowFoldFactor * 2.0 - z.y;
-
-				if (z.z > par.doubles.FoldingIntPowFoldFactor) z.z = par.doubles.FoldingIntPowFoldFactor * 2.0 - z.z;
-				else if (z.z < -par.doubles.FoldingIntPowFoldFactor) z.z = -par.doubles.FoldingIntPowFoldFactor * 2.0 - z.z;
-
-				r = z.Length();
-
-				double fR2_2 = 1.0;
-				double mR2_2 = 0.25;
-				double r2_2 = r * r;
-				double tglad_factor1_2 = fR2_2 / mR2_2;
-
-				if (r2_2 < mR2_2)
-				{
-					z = z * tglad_factor1_2;
-				}
-				else if (r2_2 < fR2_2)
-				{
-					double tglad_factor2_2 = fR2_2 / r2_2;
-					z = z * tglad_factor2_2;
-				}
-
-				z = z * 2.0;
-				double x2 = z.x * z.x;
-				double y2 = z.y * z.y;
-				double z2 = z.z * z.z;
-				double temp = 1.0 - z2 / (x2 + y2);
-				double newx = (x2 - y2) * temp;
-				double newy = 2.0 * z.x * z.y * temp;
-				double newz = -2.0 * z.z * sqrt(x2 + y2);
-				z.x = newx + constant.x;
-				z.y = newy + constant.y;
-				z.z = newz + constant.z;
-				z.z *= par.doubles.FoldingIntPowZfactor;
-				r = z.Length();
-				break;
-			}
-			case kaleidoscopic:
-			{
-
-				if (par.IFS.absX) z.x = fabs(z.x);
-				if (par.IFS.absY) z.y = fabs(z.y);
-				if (par.IFS.absZ) z.z = fabs(z.z);
-
-				for (int i = 0; i < IFS_VECTOR_COUNT; i++)
-				{
-					if (par.IFS.enabled[i])
-					{
-						z = par.IFS.rot[i].RotateVector(z);
-						double length = z.Dot(par.IFS.doubles.direction[i]);
-
-						if (length < par.IFS.doubles.distance[i])
-						{
-							z -= par.IFS.doubles.direction[i] * (2.0 * (length - par.IFS.doubles.distance[i]) * par.IFS.doubles.intensity[i]);
-						}
-
-					}
-				}
-				z = par.IFS.mainRot.RotateVector(z - par.IFS.doubles.offset) + par.IFS.doubles.offset;
-
-				if(par.IFS.doubles.edge.x > 0) z.x = par.IFS.doubles.edge.x - fabs(par.IFS.doubles.edge.x - z.x);
-				if(par.IFS.doubles.edge.y > 0) z.y = par.IFS.doubles.edge.y - fabs(par.IFS.doubles.edge.y - z.y);
-				if(par.IFS.doubles.edge.z > 0) z.z = par.IFS.doubles.edge.z - fabs(par.IFS.doubles.edge.z - z.z);
-
-				if (Mode == colouring)
-				{
-					double length2 = z.Length();
-					if (length2 < min) min = length2;
-				}
-
-				z *= par.IFS.doubles.scale;
-				if(par.IFS.mengerSpongeMode)
-				{
-					z.x -= par.IFS.doubles.offset.x * (par.IFS.doubles.scale - 1.0);
-					z.y -= par.IFS.doubles.offset.y * (par.IFS.doubles.scale - 1.0);
-					if (z.z > 0.5 * par.IFS.doubles.offset.z * (par.IFS.doubles.scale - 1.0)) z.z -= par.IFS.doubles.offset.z * (par.IFS.doubles.scale - 1.0);
-				}
-				else
-				{
-					z -= par.IFS.doubles.offset * (par.IFS.doubles.scale - 1.0);
-				}
-
-				tgladDE *= par.IFS.doubles.scale;
-				r = z.Length();
-
-				break;
-			}
-			case mandelboxVaryScale4D:
-			{
-				scale = scale + par.mandelbox.doubles.vary4D.scaleVary * (fabs(scale) - 1.0);
-				CVector3 oldz = z;
-				z.x = fabs(z.x + par.mandelbox.doubles.vary4D.fold) - fabs(z.x - par.mandelbox.doubles.vary4D.fold) - z.x;
-				z.y = fabs(z.y + par.mandelbox.doubles.vary4D.fold) - fabs(z.y - par.mandelbox.doubles.vary4D.fold) - z.y;
-				z.z = fabs(z.z + par.mandelbox.doubles.vary4D.fold) - fabs(z.z - par.mandelbox.doubles.vary4D.fold) - z.z;
-				w = fabs(w + par.mandelbox.doubles.vary4D.fold) - fabs(w - par.mandelbox.doubles.vary4D.fold) - w;
-				if(z.x != oldz.x) tgladColor += par.mandelbox.doubles.colorFactorX;
-				if(z.y != oldz.y) tgladColor += par.mandelbox.doubles.colorFactorY;
-				if(z.z != oldz.z) tgladColor += par.mandelbox.doubles.colorFactorZ;
-				double rr = pow(z.x * z.x + z.y * z.y + z.z * z.z + w * w, par.mandelbox.doubles.vary4D.rPower);
-				double m = scale;
-				if (rr < par.mandelbox.doubles.vary4D.minR * par.mandelbox.doubles.vary4D.minR)
-				{
-					m = scale / (par.mandelbox.doubles.vary4D.minR * par.mandelbox.doubles.vary4D.minR);
-					tgladColor += par.mandelbox.doubles.colorFactorSp1;
-				}
-				else if (rr < 1.0)
-				{
-					m = scale / rr;
-					tgladColor += par.mandelbox.doubles.colorFactorSp2;
-				}
-				z = z * m + constant;
-				w = w * m + par.mandelbox.doubles.vary4D.wadd;
-				tgladDE = tgladDE * fabs(m) + 1.0;
-				r = sqrt(z.x * z.x + z.y * z.y + z.z * z.z + w * w);
-				break;
-			}
-			case aexion:
-			{
-				if(L == 0)
-				{
-					double cx = fabs(constant.x + constant.y + constant.z) + par.doubles.cadd;
-					double cy = fabs(-constant.x - constant.y + constant.z) + par.doubles.cadd;
-					double cz = fabs(-constant.x + constant.y - constant.z) + par.doubles.cadd;
-					double cw = fabs(constant.x - constant.y - constant.z) + par.doubles.cadd;
-					constant.x = cx;
-					constant.y = cy;
-					constant.z = cz;
-					constantw = cw;
-					double tempx = fabs(z.x + z.y + z.z) + par.doubles.cadd;
-					double tempy = fabs(-z.x - z.y + z.z) + par.doubles.cadd;
-					double tempz = fabs(-z.x + z.y - z.z) + par.doubles.cadd;
-					double tempw = fabs(z.x - z.y - z.z) + par.doubles.cadd;
-					z.x = tempx;
-					z.y = tempy;
-					z.z = tempz;
-					w = tempw;
-				}
-				double tempx = z.x * z.x - z.y * z.y + 2.0 * w * z.z + constant.x;
-				double tempy = z.y * z.y - z.x * z.x + 2.0 * w * z.z + constant.y;
-				double tempz = z.z * z.z - w * w + 2.0 * z.x * z.y + constant.z;
-				double tempw = w * w - z.z * z.z + 2.0 * z.x * z.y + constantw;
-				z.x = tempx;
-				z.y = tempy;
-				z.z = tempz;
-				w = tempw;
-				r = sqrt(z.x * z.x + z.y * z.y + z.z * z.z + w * w);
-				break;
-			}
-			case benesi:
-			{
-				double r1 = z.y*z.y + z.z*z.z;
-				double newx = 0;
-				if(constant.x < 0 || z.x < sqrt(r1))
-				{
-					newx = z.x*z.x - r1;
-				}
-				else
-				{
-					newx = -z.x*z.x + r1;
-				}
-				r1 = - 1.0/sqrt(r1) * 2.0 * fabs(z.x);
-				double newy = r1 * (z.y*z.y - z.z*z.z);
-				double newz = r1 * 2.0 * z.y * z.z;
-
-				z.x = newx + constant.x;
-				z.y = newy + constant.y;
-				z.z = newz + constant.z;
-
-				r = z.Length();
-				break;
-			}
-			case bristorbrot:
-			{
-				double newx = z.x*z.x - z.y*z.y - z.z*z.z;
-				double newy = z.y * (2.0 * z.x - z.z);
-				double newz = z.z * (2.0 * z.x + z.y);
-
-				z.x = newx + constant.x;
-				z.y = newy + constant.y;
-				z.z = newz + constant.z;
-
-				r = z.Length();
-				break;
-			}
-			case invertX:
-			{
-				z.x = z.x >= 0.0 ? z.x*z.x/(fabs(z.x) + p) : -z.x*z.x/(fabs(z.x) + p);
-				r = z.Length();
-				break;
-			}
-			case invertY:
-			{
-				z.y = z.y >= 0.0 ? z.y*z.y/(fabs(z.y) + p) : -z.y*z.y/(fabs(z.y) + p);
-				r = z.Length();
-				break;
-			}
-			case invertZ:
-			{
-				z.z = z.z >= 0.0 ? z.z*z.z/(fabs(z.z) + p) : -z.z*z.z/(fabs(z.z) + p);
-				r = z.Length();
-				break;
-			}
-			case invertR:
-			{
-				double rInv = r*r/(r + p);
-				z.x = z.x / r * rInv;
-				z.y = z.y / r * rInv;
-				z.z = z.z / r * rInv;
-				r = z.Length();
-				break;
-			}
-			case sphericalFold:
-			{
-				double rr = r*r;
-				double pp = p*p;
-				if (rr < pp)
-				{
-					z.x = 1.0 / pp;
-					z.y = 1.0 / pp;
-					z.z = 1.0 / pp;
-				}
-				else if (rr < pp*4.0)
-				{
-					z.x = 1.0 / rr;
-					z.y = 1.0 / rr;
-					z.z = 1.0 / rr;
-				}
-				r = z.Length();
-				break;
-			}
-			case powXYZ:
-			{
-				z.x = z.x >= 0 ? pow(z.x,p) : -pow(-z.x,p);
-				z.y = z.y >= 0 ? pow(z.y,p) : -pow(-z.y,p);
-				z.z = z.z >= 0 ? pow(z.z,p) : -pow(-z.z,p);
-				r = z.Length();
-				break;
-			}
-			case scaleX:
-			{
-				z.x = z.x * p;
-				r = z.Length();
-				break;
-			}
-			case scaleY:
-			{
-				z.y = z.y * p;
-				r = z.Length();
-				break;
-			}
-			case scaleZ:
-			{
-				z.z = z.z * p;
-				r = z.Length();
-				break;
-			}
-			case offsetX:
-			{
-				z.x = z.x + p;
-				r = z.Length();
-				break;
-			}
-			case offsetY:
-			{
-				z.y = z.y + p;
-				r = z.Length();
-				break;
-			}
-			case offsetZ:
-			{
-				z.z = z.z + p;
-				r = z.Length();
-				break;
-			}
-			case angleMultiplyX:
-			{
-				double angle = atan2(z.z,z.y)*p;
-				double tempR = sqrt(z.z*z.z + z.y*z.y);
-				z.y = tempR * cos(angle);
-				z.z = tempR * sin(angle);
-				r = z.Length();
-				break;
-			}
-			case angleMultiplyY:
-			{
-				double angle = atan2(z.z,z.x)*p;
-				double tempR = sqrt(z.z*z.z + z.x*z.x);
-				z.x = tempR * cos(angle);
-				z.z = tempR * sin(angle);
-				r = z.Length();
-				break;
-			}
-			case angleMultiplyZ:
-			{
-				double angle = atan2(z.y,z.x)*p;
-				double tempR = sqrt(z.x*z.x + z.y*z.y);
-				z.x = tempR * cos(angle);
-				z.y = tempR * sin(angle);
-				r = z.Length();
-				break;
-			}
-			case hybrid:
-				break;
-			case none:
-				break;
-		}
-
-		//************************** iteration terminate conditions *****************
-		if (Mode == deltaDE1)
-		{
-			if (r > 1e10)
-				break;
-		}
-		else if (Mode == deltaDE2)
-		{
-			if (L == *iter_count)
-				break;
-		}
-
-		if (Mode == orbitTrap)
-		{
-			CVector3 delta = z - par.doubles.fakeLightsOrbitTrap;
-			distance = delta.Length();
-			if (L >= par.fakeLightsMinIter && L <= par.fakeLightsMaxIter && distance < min) min = distance;
-			if (distance > 1000)
-			{
-				distance = min;
-				break;
-			}
-		}
-
-		if (actualFormula == menger_sponge || actualFormula == kaleidoscopic)
-		{
-			if (r > 1000)
-			{
-				distance = (r - 2.0) / tgladDE;
-				break;
-			}
-		}
-		else if (actualFormula == tglad || actualFormula == smoothMandelbox || actualFormula == mandelboxVaryScale4D || actualFormula == generalizedFoldBox)
-		{
-			if (r > 1024)
-			{
-				distance = r / fabs(tgladDE);
-				break;
-			}
-		}
-		else
-		{
-			if (Mode == normal) //condition for all other trigonometric and hypercomplex fractals
-			{
-				if (r > 1e2)
-				{
-					distance = 0.5 * r * log(r) / r_dz;
-					break;
-				}
-			}
-			else if (Mode == fake_AO) //mode 2
-			{
-				if (r < min) min = r;
-				if (r > 1e15)
-				{
-					distance = min;
-					break;
-				}
-			}
-			else if (Mode == colouring) //mode 1
-			{
-				if(par.primitives.onlyPlane)
-				{
-					distance = z.Length();
-					if (distance > 1e15)
-					{
-						distance = (L - log(log(r) / log(N)) / log(p))/100.0;
-						break;
-					}
-				}
-				else
-				{
-					distance = z.Length();
-					if (distance < min) min = distance;
-					if (distance > 1e15)
-					{
-						distance = min;
-						break;
-					}
-				}
-			}
-		}
-	}
-
-	//************ return values *****************
-
-/*
-	N_counter += L + 1;
-	Loop_counter++;
-
-	if (L < 64)
-		histogram[L]++;
-	else
-		histogram[63]++;
-*/
-
-	if (iter_count != NULL)
-		*iter_count = L;
-
-	if (Mode == normal)
-	{
-		if (L == N)
-			distance = 0;
-		return distance;
-	}
-
-	if (Mode == deltaDE1 || Mode == deltaDE2)
-		return r;
-
-	if (Mode == fake_AO)
-		return distance;
-
-	if (Mode == orbitTrap)
-		return distance;
-
-	if (Mode == colouring)
-	{
-		if (par.formula == hybrid)
-		{
-			if (min > 100) 
-				min = 100;
-			if (distance > 20) 
-				distance = 20;
-			if (tgladColor > 1000) 
-				tgladColor = 1000;
-
-			return distance * 5000.0 + tgladColor * 100.0 + min * 1000.0;
-		} 
-		else if (actualFormula == tglad || actualFormula == smoothMandelbox || actualFormula == mandelboxVaryScale4D || actualFormula == generalizedFoldBox)
-			return tgladColor * 100.0 + z.Length()*par.mandelbox.doubles.colorFactorR;
-		else if (actualFormula == kaleidoscopic || actualFormula == menger_sponge)
-			return min * 1000.0;
-		else
-			return distance * 5000.0;
-	}
-}
-
-#if 0
-//******************* Calculate distance *******************8
-
-double CalculateDistance(CVector3 point, sFractal &params, bool *max_iter)
-{
-	int L;
-	double distance;
-	params.objectOut = objFractal;
-
-	if (params.limits_enabled)
-	{
-		bool limit = false;
-		double distance_a = 0;
-		double distance_b = 0;
-		double distance_c = 0;
-
-		if (point.x < params.doubles.amin - params.doubles.detailSize)
-		{
-			distance_a = fabs(params.doubles.amin - point.x);
-			limit = true;
-		}
-		if (point.x > params.doubles.amax + params.doubles.detailSize)
-		{
-			distance_a = fabs(params.doubles.amax - point.x);
-			limit = true;
-		}
-
-		if (point.y < params.doubles.bmin - params.doubles.detailSize)
-		{
-			distance_a = fabs(params.doubles.bmin - point.y);
-			limit = true;
-		}
-		if (point.y > params.doubles.bmax + params.doubles.detailSize)
-		{
-			distance_b = fabs(params.doubles.bmax - point.y);
-			limit = true;
-		}
-
-		if (point.z < params.doubles.cmin - params.doubles.detailSize)
-		{
-			distance_c = fabs(params.doubles.cmin - point.z);
-			limit = true;
-		}
-		if (point.z > params.doubles.cmax + params.doubles.detailSize)
-		{
-			distance_c = fabs(params.doubles.cmax - point.z);
-			limit = true;
-		}
-
-		if (limit)
-		{
-			if (max_iter != NULL)
-				*max_iter = false;
-			distance = dMax(distance_a, distance_b, distance_c);
-			return distance;
-		}
-	}
-
-	if(!params.primitives.onlyPlane)
-	{
-		if (params.analitycDE)
-		{
-			distance = Compute<normal>(point, params, &L);
-			if (max_iter != NULL)
-			{
-				if (L == (int)params.doubles.N) *max_iter = true;
-				else *max_iter = false;
-			}
-			params.itersOut = L;
-
-			if (L < params.minN && distance < params.doubles.detailSize) distance = params.doubles.detailSize;
-
-			if (params.interiorMode)
-			{
-				if (distance < 0.5 * params.doubles.detailSize || L == (int)params.doubles.N)
-				{
-					distance = params.doubles.detailSize;
-					if (max_iter != NULL) *max_iter = false;
-				}
-			}
-			if (params.iterThresh)
-			{
-				if(distance < params.doubles.detailSize)
-				{
-					distance = params.doubles.detailSize * 1.01;
-				}
-			}
-		}
-		else
-		{
-			double deltaDE = 1e-10;
-
-			double r = Compute<deltaDE1>(point, params, &L);
-			int retval = L;
-			params.itersOut = L;
-
-			point.x += deltaDE;
-			point.y += 0;
-			point.z += 0;
-			double r2 = Compute<deltaDE2>(point, params, &L);
-			double dr1 = fabs(r2 - r) / deltaDE;
-
-			point.x -= deltaDE;
-			point.y += deltaDE;
-			point.z += 0;
-			r2 = Compute<deltaDE2>(point, params, &L);
-			double dr2 = fabs(r2 - r) / deltaDE;
-
-			point.x += 0;
-			point.y -= deltaDE;
-			point.z += deltaDE;
-			r2 = Compute<deltaDE2>(point, params, &L);
-			double dr3 = fabs(r2 - r) / deltaDE;
-
-			double dr = sqrt(dr1 * dr1 + dr2 * dr2 + dr3 * dr3);
-
-			if (params.linearDEmode)
-			{
-				distance = 0.5 * r / dr;
-			}
-			else
-			{
-				distance = 0.5 * r * log(r) / dr;
-			}
-
-			if (retval == (int)params.doubles.N)
-			{
-				if (max_iter != NULL) *max_iter = true;
-				distance = 0;
-			}
-			else if (max_iter != NULL) *max_iter = false;
-
-			if (L < params.minN && distance < params.doubles.detailSize) distance = params.doubles.detailSize;
-
-			if (params.interiorMode)
-			{
-				if (distance < 0.5 * params.doubles.detailSize || retval == 256)
-				{
-					distance = params.doubles.detailSize;
-					if (max_iter != NULL) *max_iter = false;
-				}
-			}
-
-			if (params.iterThresh)
-			{
-				if(distance < params.doubles.detailSize)
-				{
-					distance = params.doubles.detailSize * 1.01;
-				}
-			}
-
-		}
-	}
-	else
-	{
-		distance = 10.0;
-		if (max_iter != NULL) *max_iter = false;
-	}
-
-	//plane
-	if (params.primitives.planeEnable)
-	{
-		double planeDistance = PrimitivePlane(point, params.doubles.primitives.planeCentre, params.doubles.primitives.planeNormal);
-		if(!params.primitives.onlyPlane && planeDistance < distance) 	params.objectOut = objPlane;
-		distance = (planeDistance < distance) ? planeDistance : distance;
-
-	}
-
-	//box
-	if (params.primitives.boxEnable)
-	{
-		double boxDistance = PrimitiveBox(point, params.doubles.primitives.boxCentre, params.doubles.primitives.boxSize);
-		if(boxDistance < distance) 	params.objectOut = objBox;
-		distance = (boxDistance < distance) ? boxDistance : distance;
-	}
-
-	//inverted box
-	if (params.primitives.invertedBoxEnable)
-	{
-		double boxDistance = PrimitiveInvertedBox(point, params.doubles.primitives.invertedBoxCentre, params.doubles.primitives.invertedBoxSize);
-		if(boxDistance < distance) 	params.objectOut = objBoxInv;
-		distance = (boxDistance < distance) ? boxDistance : distance;
-	}
-
-	//sphere
-	if (params.primitives.sphereEnable)
-	{
-		double sphereDistance = PrimitiveSphere(point, params.doubles.primitives.sphereCentre, params.doubles.primitives.sphereRadius);
-		if(sphereDistance < distance) 	params.objectOut = objSphere;
-		distance = (sphereDistance < distance) ? sphereDistance : distance;
-	}
-
-	//invertedSphere
-	if (params.primitives.invertedSphereEnable)
-	{
-		double sphereDistance = PrimitiveInvertedSphere(point, params.doubles.primitives.invertedSphereCentre, params.doubles.primitives.invertedSphereRadius);
-		if(sphereDistance < distance) 	params.objectOut = objSphereInv;
-		distance = (sphereDistance < distance) ? sphereDistance : distance;
-	}
-
-	//water
-	if (params.primitives.waterEnable)
-	{
-		double waterDistance = PrimitiveWater(point, params.doubles.primitives.waterHeight, params.doubles.primitives.waterAmplitude,
-				params.doubles.primitives.waterLength, params.doubles.primitives.waterRotation, params.primitives.waterIterations, 0.1, params.frameNo);
-		if(waterDistance < distance) 	params.objectOut = objWater;
-		distance = (waterDistance < distance) ? waterDistance : distance;
-	}
-
-	if (distance < 0) distance = 0;
-	if (max_iter != NULL)
-	{
-
-		if (*max_iter)
-		{
-			if (params.limits_enabled)
-			{
-				double distance_a1 = fabs(params.doubles.amin - point.x);
-				double distance_a2 = fabs(params.doubles.amax - point.x);
-				double distance_b1 = fabs(params.doubles.bmin - point.y);
-				double distance_b2 = fabs(params.doubles.bmax - point.y);
-				double distance_c1 = fabs(params.doubles.cmin - point.z);
-				double distance_c2 = fabs(params.doubles.cmax - point.z);
-				double min1 = dMin(distance_a1, distance_b1, distance_c1);
-				double min2 = dMin(distance_a2, distance_b2, distance_c2);
-				double min = MIN(min1, min2);
-				if(min < params.doubles.detailSize)
-				{
-					distance = min;
-				}
-			}
-			else
-			{
-				//distance = params.doubles.detailSize * 0.5;
-				distance = 0.0;
-			}
-		}
-
-
-	}
-	return distance;
-}
-#endif
-
-// force template instantiation
-template double Compute<normal>(CVector3, const sFractal&, int*);
-template double Compute<colouring>(CVector3, const sFractal&, int*);
-template double Compute<fake_AO>(CVector3, const sFractal&, int*);
-template double Compute<deltaDE1>(CVector3, const sFractal&, int*);
-template double Compute<deltaDE2>(CVector3, const sFractal&, int*);
-template double Compute<orbitTrap>(CVector3, const sFractal&, int*);
diff --git a/src/mandelbulber/fractal.h b/src/mandelbulber/fractal.h
deleted file mode 100644
index 4e957e6..0000000
--- a/src/mandelbulber/fractal.h
+++ /dev/null
@@ -1,277 +0,0 @@
-/*
- * fractal.h
- *
- *  Created on: 2010-01-23
- *      Author: krzysztof marczak
- */
-
-#ifndef FRACTAL_H_
-#define FRACTAL_H_
-
-#include <vector>
-#include "common_math.h"
-//#include "fractparams.h"
-#include <stddef.h>
-
-const int IFS_VECTOR_COUNT = 9;
-const int HYBRID_COUNT = 5;
-const int MANDELBOX_FOLDS = 2;
-
-enum enumFractalFormula
-{
-	none = 0,
-	trig_DE = 1,
-	trig_optim = 2,
-	fast_trig = 3,
-	hypercomplex = 4,
-	quaternion = 5,
-	minus_fast_trig = 6,
-	menger_sponge = 7,
-	tglad = 8,
-	kaleidoscopic = 10,
-	xenodreambuie = 11,
-	hybrid = 12,
-	mandelbulb2 = 13,
-	mandelbulb3 = 14,
-	mandelbulb4 = 15,
-	foldingIntPow2 = 16,
-	smoothMandelbox = 17,
-	mandelboxVaryScale4D = 18,
-	aexion = 19,
-	benesi = 20,
-	bristorbrot = 21,
-	invertX = 22,
-	invertY = 23,
-	invertZ = 24,
-	invertR = 25,
-	sphericalFold = 26,
-	powXYZ = 27,
-	scaleX = 28,
-	scaleY = 29,
-	scaleZ = 30,
-	offsetX = 31,
-	offsetY = 32,
-	offsetZ = 33,
-	angleMultiplyX = 34,
-	angleMultiplyY = 35,
-	angleMultiplyZ = 36,
-	generalizedFoldBox = 37
-};
-
-enum enumCalculationMode
-{
-	normal = 0, colouring = 1, fake_AO = 2, deltaDE1 = 3, deltaDE2 = 4, orbitTrap = 5
-};
-
-enum enumGeneralizedFoldBoxType
-{
-	foldTet = 0,
-	foldCube = 1,
-	foldOct = 2,
-	foldDodeca = 3,
-	foldOctCube = 4,
-	foldIcosa = 5,
-	foldBox6 = 6,
-	foldBox5 = 7
-};
-
-enum enumObjectType
-{
-	objFractal = 0,
-	objPlane = 1,
-	objWater = 2,
-	objSphere = 3,
-	objSphereInv = 4,
-	objBox = 5,
-	objBoxInv = 6
-};
-
-struct sFractalIFSD
-{
-	double rotationGamma;
-	double rotationAlfa;
-	double rotationBeta;
-	double scale;
-	double distance[IFS_VECTOR_COUNT];
-	double alfa[IFS_VECTOR_COUNT];
-	double beta[IFS_VECTOR_COUNT];
-	double gamma[IFS_VECTOR_COUNT];
-	double intensity[IFS_VECTOR_COUNT];
-	CVector3 offset;
-	CVector3 direction[IFS_VECTOR_COUNT];
-	CVector3 edge;
-};
-
-struct sFractalGeneralizedFoldBox
-{
-	enum enumGeneralizedFoldBoxType type;
-	CVector3 Nv_tet[4];
-	CVector3 Nv_cube[6];
-	CVector3 Nv_oct[8];
-	CVector3 Nv_oct_cube[14];
-	CVector3 Nv_dodeca[12];
-	CVector3 Nv_icosa[20];
-	CVector3 Nv_box6[8];
-	CVector3 Nv_box5[7];
-	int sides_tet;
-	int sides_cube;
-	int sides_oct;
-	int sides_oct_cube;
-	int sides_dodeca;
-	int sides_icosa;
-	int sides_box6;
-	int sides_box5;
-};
-
-struct sFractalIFS
-{
-	sFractalIFSD doubles;
-	bool absX, absY, absZ;
-	bool foldingMode; // Kaleidoscopic IFS folding mode
-	bool enabled[IFS_VECTOR_COUNT];
-	bool mengerSpongeMode;
-	int foldingCount;
-	CRotationMatrix mainRot;
-	CRotationMatrix rot[IFS_VECTOR_COUNT];
-};
-
-struct sFractalMandelboxVary4D
-{
-	double fold;
-	double minR;
-	double scaleVary;
-	double wadd;
-	double rPower;
-};
-
-struct sFractalMandelboxD
-{
-	double rotationMain[3];
-	double rotation[MANDELBOX_FOLDS][3][3];
-	double colorFactorX;
-	double colorFactorY;
-	double colorFactorZ;
-	double colorFactorR;
-	double colorFactorSp1;
-	double colorFactorSp2;
-	double scale;
-	double foldingLimit;
-	double foldingValue;
-	double foldingSphericalMin;
-	double foldingSphericalFixed;
-	double sharpness;
-	double solid;
-	double melt;
-	CVector3 offset;
-	sFractalMandelboxVary4D vary4D;
-};
-
-struct sFractalMandelbox
-{
-	sFractalMandelboxD doubles;
-	bool rotationsEnabled;
-	CRotationMatrix mainRot;
-	CRotationMatrix rot[MANDELBOX_FOLDS][3];
-	CRotationMatrix rotinv[MANDELBOX_FOLDS][3];
-};
-
-struct sFractalPrimitivesD
-{
-	CVector3 planeCentre;
-	CVector3 planeNormal;
-	CVector3 boxCentre;
-	CVector3 boxSize;
-	CVector3 invertedBoxCentre;
-	CVector3 invertedBoxSize;
-	CVector3 sphereCentre;
-	double sphereRadius;
-	CVector3 invertedSphereCentre;
-	double invertedSphereRadius;
-	double waterHeight;
-	double waterAmplitude;
-	double waterLength;
-	double waterRotation;
-};
-
-struct sFractalPrimitives
-{
-	bool planeEnable;
-	bool boxEnable;
-	bool invertedBoxEnable;
-	bool sphereEnable;
-	bool invertedSphereEnable;
-	bool waterEnable;
-	bool onlyPlane;
-	int waterIterations;
-};
-
-struct sFractalD
-{
-	double N;
-	double amin;  //fractal limits
-	double amax;
-	double bmin;
-	double bmax;
-	double cmin;
-	double cmax;
-	double constantFactor;
-	double FoldingIntPowZfactor;
-	double FoldingIntPowFoldFactor;
-	double foldingLimit; //paramters of TGlad's folding
-	double foldingValue;
-	double foldingSphericalMin;
-	double foldingSphericalFixed;
-	double detailSize;
-	double power;		 //power of fractal formula
-	double cadd;
-	double hybridPower[HYBRID_COUNT];
-	CVector3 julia; // Julia constant
-	CVector3 fakeLightsOrbitTrap;
-	sFractalPrimitivesD primitives;
-};
-
-struct sFractal
-{
-	sFractalD doubles;
-
-	  // maximum number of iterations
-	int minN;	  // minimum number of iterations
-
-	bool limits_enabled; // enable limits (intersections)
-	bool iterThresh;	 //maxiter threshold mode
-	bool analitycDE;	 //analytic DE mode
-	bool juliaMode;				// Julia mode
-	bool tgladFoldingMode;		// Tglad's folding mode
-	bool sphericalFoldingMode;  // spherical folding mode
-	bool interiorMode;
-	bool hybridCyclic;
-	bool linearDEmode;
-	bool constantDEThreshold;
-
-	enumFractalFormula formula;
-
-	int hybridIters[HYBRID_COUNT];
-	enumFractalFormula hybridFormula[HYBRID_COUNT];
-
-	std::vector<enumFractalFormula> formulaSequence;
-	std::vector<double> hybridPowerSequence;
-
-	sFractalIFS IFS;
-	sFractalMandelbox mandelbox;
-	sFractalGeneralizedFoldBox genFoldBox;
-	sFractalPrimitives primitives;
-
-	int frameNo;
-
-	int itersOut;
-	enumObjectType objectOut;
-
-	int fakeLightsMinIter;
-	int fakeLightsMaxIter;
-};
-
-template <int Mode> double Compute(CVector3 z, const sFractal &par, int *iter_count = NULL);
-//double CalculateDistance(CVector3 point, sFractal &par, bool *max_iter = NULL);
-
-
-#endif /* FRACTAL_H_ */
diff --git a/src/mandelbulber/fractparams.h b/src/mandelbulber/fractparams.h
deleted file mode 100644
index 9809453..0000000
--- a/src/mandelbulber/fractparams.h
+++ /dev/null
@@ -1,157 +0,0 @@
-/*
- * fractparams.h
- *
- *  Created on: 2010-05-03
- *      Author: krzysztof
- */
-
-#ifndef FRACTPARAMS_H_
-#define FRACTPARAMS_H_
-
-#include "fractal.h"
-//#include "texture.hpp"
-
-struct sParamRenderD
-{
-	double zoom; //zoom
-	double DE_factor; //factor for distance estimation steps
-	double resolution; //resolution of image in fractal coordinates
-	double persp; //perspective factor
-	double quality; //DE threshold factor
-	double smoothness;
-	double alpha; //rotation of fractal
-	double beta; //
-	double gamma;
-	double DOFFocus;
-	double DOFRadius;
-	double mainLightAlpha;
-	double mainLightBeta;
-	double auxLightIntensity;
-	double auxLightMaxDist;
-	double auxLightDistributionRadius;
-	double auxLightVisibility;
-	double auxLightPre1intensity;
-	double auxLightPre2intensity;
-	double auxLightPre3intensity;
-	double auxLightPre4intensity;
-	double stereoEyeDistance;
-	double viewDistanceMin;
-	double viewDistanceMax;
-	double volumetricLightIntensity[5];
-	double fogDensity;
-	double fogColour1Distance;
-	double fogColour2Distance;
-	double fogDistanceFactor;
-	double colourSaturation;
-	double fastAoTune;
-	double iterFogOpacity;
-	double iterFogOpacityTrim;
-	double fakeLightsIntensity;
-	double fakeLightsVisibility;
-	double fakeLightsVisibilitySize;
-	double shadowConeAngle;
-	double primitivePlaneReflect;
-	double primitiveBoxReflect;
-	double primitiveInvertedBoxReflect;
-	double primitiveSphereReflect;
-	double primitiveInvertedSphereReflect;
-	double primitiveWaterReflect;
-
-//	sImageAdjustments imageAdjustments;
-
-	CVector3 vp; //view point
-	CVector3 auxLightPre1;
-	CVector3 auxLightPre2;
-	CVector3 auxLightPre3;
-	CVector3 auxLightPre4;
-	CVector3 auxLightRandomCenter;
-};
-
-struct sParamRender
-{
-	sParamRenderD doubles;
-
-	sFractal fractal;
-	int image_width; //image width
-	int image_height; //image height
-	int globalIlumQuality; //ambient occlusion quality
-	int reflectionsMax;
-	int coloring_seed; //colouring random seed
-	int auxLightRandomSeed;
-	int auxLightNumber;
-	int SSAOQuality;
-	int startFrame;
-	int endFrame;
-	int framesPerKeyframe;
-	int imageFormat;
-	int noOfTiles;
-	int tileCount;
-
-	int OpenCLEngine;
-	int OpenCLPixelsPerJob;
-
-	enumPerspectiveType perspectiveType;
-
-	bool shadow; //enable shadows
-	bool global_ilumination; //enable global ilumination
-	bool fastGlobalIllumination; //enable fake global ilumination
-	bool slowShading; //enable fake gradient calculation for shading
-	bool textured_background; //enable testured background
-	bool background_as_fulldome;
-	bool recordMode; //path recording mode
-	bool continueRecord; //continue recording mode
-	bool playMode; //play mode
-	bool animMode; //animation mode
-	bool SSAOEnabled;
-	bool DOFEnabled;
-	bool auxLightPre1Enabled;
-	bool auxLightPre2Enabled;
-	bool auxLightPre3Enabled;
-	bool auxLightPre4Enabled;
-	bool volumetricLightEnabled[5];
-	bool penetratingLights;
-	bool stereoEnabled;
-	bool quiet;
-	bool fishEyeCut;
-	bool fakeLightsEnabled;
-/*
-	sImageSwitches imageSwitches;
-
-	sRGB background_color1; //background colour
-	sRGB background_color2;
-	sRGB background_color3;
-	sRGB auxLightPre1Colour;
-	sRGB auxLightPre2Colour;
-	sRGB auxLightPre3Colour;
-	sRGB auxLightPre4Colour;
-	sRGB fogColour1;
-	sRGB fogColour2;
-	sRGB fogColour3;
-	sRGB primitivePlaneColour;
-	sRGB primitiveBoxColour;
-	sRGB primitiveInvertedBoxColour;
-	sRGB primitiveSphereColour;
-	sRGB primitiveInvertedSphereColour;
-	sRGB primitiveWaterColour;
-	sEffectColours effectColours;
-
-	sRGB palette[256];
-
-	char file_destination[1000];
-	char file_envmap[1000];
-	char file_background[1000];
-	char file_lightmap[1000];
-	char file_path[1000];
-	char file_keyframes[1000];
-
-	cTexture *backgroundTexture;
-	cTexture *envmapTexture;
-	cTexture *lightmapTexture;
-*/
-	std::vector<enumFractalFormula> formulaSequence;
-	std::vector<double> hybridPowerSequence;
-
-	double settingsVersion;
-};
-
-#endif /* FRACTPARAMS_H_ */
diff --git a/util/next/minetest.log b/util/next/minetest.log
deleted file mode 100644
index 244279e..0000000
--- a/util/next/minetest.log
+++ /dev/null
@@ -1,780 +0,0 @@
-
-
-
-
-!!!!!!!!!!!!!!!!!
- Merge sapier/avoid_facedir_if_not_moving to next failed:
-
-# On branch next
-# You have unmerged paths.
-#   (fix conflicts and run "git commit")
-#
-# Unmerged paths:
-#   (use "git add <file>..." to mark resolution)
-#
-#	both modified:      src/content_cao.cpp
-#	both modified:      src/content_sao.cpp
-#
-no changes added to commit (use "git add" and/or "git commit -a")
-diff --cc src/content_cao.cpp
-index e97e3a1,fb4bc95..0000000
---- a/src/content_cao.cpp
-+++ b/src/content_cao.cpp
-@@@ -1211,9 -1211,9 +1211,15 @@@ public
-  			updateNodePos();
-  		}
-  
-++<<<<<<< HEAD
- +		if (getParent() == NULL && m_prop.automatic_face_movement_dir &&
- +				(fabs(m_velocity.Z) > 0.001 || fabs(m_velocity.X) > 0.001)){
- +			m_yaw = atan2(m_velocity.Z,m_velocity.X) * 180 / M_PI + m_prop.automatic_face_movement_dir_offset;
-++=======
-+ 		if ((getParent() == NULL && m_prop.automatic_face_movement_dir) &&
-+ 			((m_velocity.Z != 0) || (m_velocity.X != 0))){
-+ 			m_yaw = atan2(m_velocity.Z,m_velocity.X) * 180 / M_PI;
-++>>>>>>> sapier/avoid_facedir_if_not_moving
-  			updateNodePos();
-  		}
-  	}
-diff --cc src/content_sao.cpp
-index 85ab8d3,92cabfb..0000000
---- a/src/content_sao.cpp
-+++ b/src/content_sao.cpp
-@@@ -527,9 -527,9 +527,14 @@@ void LuaEntitySAO::step(float dtime, bo
-  			m_velocity += dtime * m_acceleration;
-  		}
-  
- -		if( (m_prop.automatic_face_movement_dir) &&
- +		if((m_prop.automatic_face_movement_dir) &&
-++<<<<<<< HEAD
- +				(fabs(m_velocity.Z) > 0.001 || fabs(m_velocity.X) > 0.001)){
- +			m_yaw = atan2(m_velocity.Z,m_velocity.X) * 180 / M_PI + m_prop.automatic_face_movement_dir_offset;
-++=======
-+ 			((m_velocity.Z != 0) || (m_velocity.X != 0))){
-+ 			m_yaw = atan2(m_velocity.Z,m_velocity.X) * 180 / M_PI;
-++>>>>>>> sapier/avoid_facedir_if_not_moving
-  		}
-  	}
-  
-
-
-
-
-!!!!!!!!!!!!!!!!!
- Merge sapier/modmgr_fixes to next failed:
-
-# On branch next
-# You have unmerged paths.
-#   (fix conflicts and run "git commit")
-#
-# Unmerged paths:
-#   (use "git add <file>..." to mark resolution)
-#
-#	both modified:      builtin/misc_helpers.lua
-#
-no changes added to commit (use "git add" and/or "git commit -a")
-diff --cc builtin/misc_helpers.lua
-index 66b5432,0110062..0000000
---- a/builtin/misc_helpers.lua
-+++ b/builtin/misc_helpers.lua
-@@@ -261,192 -261,6 +261,195 @@@ function tbl.splittext(text,charlimit
-  	return retval
-  end
-  
-++<<<<<<< HEAD
- +--------------------------------------------------------------------------------
- +
- +if minetest then
- +	local dirs1 = { 9, 18, 7, 12 }
- +	local dirs2 = { 20, 23, 22, 21 }
- +
- +	function minetest.rotate_and_place(itemstack, placer, pointed_thing, infinitestacks, orient_flags)
- +		orient_flags = orient_flags or {}
- +
- +		local node = minetest.get_node(pointed_thing.under)
- +		if not minetest.registered_nodes[node.name]
- +		   or not minetest.registered_nodes[node.name].on_rightclick then
- +
- +			local above = pointed_thing.above
- +			local under = pointed_thing.under
- +			local pitch = placer:get_look_pitch()
- +			local pname = minetest.get_node(under).name
- +			local node = minetest.get_node(above)
- +			local fdir = minetest.dir_to_facedir(placer:get_look_dir())
- +			local wield_name = itemstack:get_name()
- +			local reg_node = minetest.registered_nodes[pname]
- +
- +			if not reg_node or not reg_node.on_rightclick then
- +
- +				local iswall = (above.x ~= under.x) or (above.z ~= under.z)
- +				local isceiling = (above.x == under.x) and (above.z == under.z)
- +								  and (pitch > 0)
- +				local pos1 = above
- +
- +				if reg_node and reg_node.buildable_to then
- +					pos1 = under
- +					iswall = false
- +				end
- +
- +				reg_node = minetest.registered_nodes[minetest.get_node(pos1).name]
- +				if not reg_node or not reg_node.buildable_to then
- +					return
- +				end
- +
- +				if orient_flags.force_floor then
- +					iswall = false
- +					isceiling = false
- +				elseif orient_flags.force_ceiling then 
- +					iswall = false
- +					isceiling = true
- +				elseif orient_flags.force_wall then					
- +					iswall = true
- +					isceiling = false
- +				elseif orient_flags.invert_wall then
- +					iswall = not iswall
- +				end
- +
- +				if iswall then
- +					minetest.add_node(pos1, {name = wield_name, param2 = dirs1[fdir+1] })
- +				elseif isceiling then
- +					if orient_flags.force_facedir then
- +						minetest.add_node(pos1, {name = wield_name, param2 = 20 })
- +					else
- +						minetest.add_node(pos1, {name = wield_name, param2 = dirs2[fdir+1] })
- +					end
- +				else -- place right side up
- +					if orient_flags.force_facedir then
- +						minetest.add_node(pos1, {name = wield_name, param2 = 0 })
- +					else
- +						minetest.add_node(pos1, {name = wield_name, param2 = fdir })
- +					end
- +				end
- +
- +				if not infinitestacks then
- +					itemstack:take_item()
- +					return itemstack
- +				end
- +			end
- +		else
- +			minetest.registered_nodes[node.name].on_rightclick(pointed_thing.under, node, placer, itemstack)
- +		end
- +	end
- +
- +
- +--------------------------------------------------------------------------------
- +--Wrapper for rotate_and_place() to check for sneak and assume Creative mode
- +--implies infinite stacks when performing a 6d rotation.
- +--------------------------------------------------------------------------------
- +
- +
- +	minetest.rotate_node = function(itemstack, placer, pointed_thing)
- +		minetest.rotate_and_place(itemstack, placer, pointed_thing,
- +		minetest.setting_getbool("creative_mode"), 
- +		{invert_wall = placer:get_player_control().sneak})
- +		return itemstack
- +	end
- +end
- +
- +--------------------------------------------------------------------------------
- +
- +if minetest then
- +	local dirs1 = { 9, 18, 7, 12 }
- +	local dirs2 = { 20, 23, 22, 21 }
- +
- +	function minetest.rotate_and_place(itemstack, placer, pointed_thing, infinitestacks, orient_flags)
- +		orient_flags = orient_flags or {}
- +
- +		local node = minetest.get_node(pointed_thing.under)
- +		if not minetest.registered_nodes[node.name]
- +		   or not minetest.registered_nodes[node.name].on_rightclick then
- +
- +			local above = pointed_thing.above
- +			local under = pointed_thing.under
- +			local pitch = placer:get_look_pitch()
- +			local pname = minetest.get_node(under).name
- +			local node = minetest.get_node(above)
- +			local fdir = minetest.dir_to_facedir(placer:get_look_dir())
- +			local wield_name = itemstack:get_name()
- +			local reg_node = minetest.registered_nodes[pname]
- +
- +			if not reg_node or not reg_node.on_rightclick then
- +
- +				local iswall = (above.x ~= under.x) or (above.z ~= under.z)
- +				local isceiling = (above.x == under.x) and (above.z == under.z)
- +								  and (pitch > 0)
- +				local pos1 = above
- +
- +				if reg_node and reg_node.buildable_to then
- +					pos1 = under
- +					iswall = false
- +				end
- +
- +				reg_node = minetest.registered_nodes[minetest.get_node(pos1).name]
- +				if not reg_node or not reg_node.buildable_to then
- +					return
- +				end
- +
- +				if orient_flags.force_floor then
- +					iswall = false
- +					isceiling = false
- +				elseif orient_flags.force_ceiling then 
- +					iswall = false
- +					isceiling = true
- +				elseif orient_flags.force_wall then					
- +					iswall = true
- +					isceiling = false
- +				elseif orient_flags.invert_wall then
- +					iswall = not iswall
- +				end
- +
- +				if iswall then
- +					minetest.add_node(pos1, {name = wield_name, param2 = dirs1[fdir+1] })
- +				elseif isceiling then
- +					if orient_flags.force_facedir then
- +						minetest.add_node(pos1, {name = wield_name, param2 = 20 })
- +					else
- +						minetest.add_node(pos1, {name = wield_name, param2 = dirs2[fdir+1] })
- +					end
- +				else -- place right side up
- +					if orient_flags.force_facedir then
- +						minetest.add_node(pos1, {name = wield_name, param2 = 0 })
- +					else
- +						minetest.add_node(pos1, {name = wield_name, param2 = fdir })
- +					end
- +				end
- +
- +				if not infinitestacks then
- +					itemstack:take_item()
- +					return itemstack
- +				end
- +			end
- +		else
- +			minetest.registered_nodes[node.name].on_rightclick(pointed_thing.under, node, placer, itemstack)
- +		end
- +	end
- +
- +
- +--------------------------------------------------------------------------------
- +--Wrapper for rotate_and_place() to check for sneak and assume Creative mode
- +--implies infinite stacks when performing a 6d rotation.
- +--------------------------------------------------------------------------------
- +
- +
- +	minetest.rotate_node = function(itemstack, placer, pointed_thing)
- +		minetest.rotate_and_place(itemstack, placer, pointed_thing,
- +		minetest.setting_getbool("creative_mode"), 
- +		{invert_wall = placer:get_player_control().sneak})
- +		return itemstack
- +	end
- +end
- +
-++=======
-++>>>>>>> sapier/modmgr_fixes
-  --------------------------------------------------------------------------------
-  -- mainmenu only functions
-  --------------------------------------------------------------------------------
-
-
-
-
-!!!!!!!!!!!!!!!!!
- Merge Novatux/forceload to next failed:
-
-# On branch next
-# You have unmerged paths.
-#   (fix conflicts and run "git commit")
-#
-# Changes to be committed:
-#
-#	modified:   doc/lua_api.txt
-#	modified:   minetest.conf.example
-#	modified:   src/defaultsettings.cpp
-#	modified:   src/environment.cpp
-#
-# Unmerged paths:
-#   (use "git add <file>..." to mark resolution)
-#
-#	both modified:      src/object_properties.cpp
-#	both modified:      src/object_properties.h
-#
-diff --cc src/object_properties.cpp
-index f560f59,162cc67..0000000
---- a/src/object_properties.cpp
-+++ b/src/object_properties.cpp
-@@@ -42,7 -42,7 +42,11 @@@ ObjectProperties::ObjectProperties()
-  	automatic_rotate(0),
-  	stepheight(0),
-  	automatic_face_movement_dir(false),
-++<<<<<<< HEAD
- +	automatic_face_movement_dir_offset(0.0)
-++=======
-+ 	force_load(false)
-++>>>>>>> Novatux/forceload
-  {
-  	textures.push_back("unknown_object.png");
-  	colors.push_back(video::SColor(255,255,255,255));
-@@@ -105,7 -106,7 +110,11 @@@ void ObjectProperties::serialize(std::o
-  	writeU8(os, collideWithObjects);
-  	writeF1000(os,stepheight);
-  	writeU8(os, automatic_face_movement_dir);
-++<<<<<<< HEAD
- +	writeF1000(os, automatic_face_movement_dir_offset);
-++=======
-+ 	writeU8(os, force_load);
-++>>>>>>> Novatux/forceload
-  	// Add stuff only at the bottom.
-  	// Never remove anything, because we don't want new versions of this
-  }
-@@@ -141,7 -142,7 +150,11 @@@ void ObjectProperties::deSerialize(std:
-  			collideWithObjects = readU8(is);
-  			stepheight = readF1000(is);
-  			automatic_face_movement_dir = readU8(is);
-++<<<<<<< HEAD
- +			automatic_face_movement_dir_offset = readF1000(is);
-++=======
-+ 			force_load = readU8(is);
-++>>>>>>> Novatux/forceload
-  		}catch(SerializationError &e){}
-  	}
-  	else
-diff --cc src/object_properties.h
-index 4b7f9a5,dbcbba5..0000000
---- a/src/object_properties.h
-+++ b/src/object_properties.h
-@@@ -46,7 -46,7 +46,11 @@@ struct ObjectPropertie
-  	float automatic_rotate;
-  	f32 stepheight;
-  	bool automatic_face_movement_dir;
-++<<<<<<< HEAD
- +	f32 automatic_face_movement_dir_offset;
-++=======
-+ 	bool force_load;
-++>>>>>>> Novatux/forceload
-  
-  
-  	ObjectProperties();
-
-
-
-
-!!!!!!!!!!!!!!!!!
- Merge sapier/fix_crash_on_lua_exception to next failed:
-
-# On branch next
-# You have unmerged paths.
-#   (fix conflicts and run "git commit")
-#
-# Unmerged paths:
-#   (use "git add <file>..." to mark resolution)
-#
-#	both modified:      src/guiFormSpecMenu.cpp
-#
-no changes added to commit (use "git add" and/or "git commit -a")
-diff --cc src/guiFormSpecMenu.cpp
-index 2416e4c,01630e0..0000000
---- a/src/guiFormSpecMenu.cpp
-+++ b/src/guiFormSpecMenu.cpp
-@@@ -1657,7 -1597,21 +1657,25 @@@ void GUIFormSpecMenu::regenerateGui(v2u
-  			Environment->addButton(mydata.rect, this, 257, text);
-  			delete[] text;
-  		}
-++<<<<<<< HEAD
- +
-++=======
-+ 		changeCtype("C");
-+ 	}
-+ 	// Add tooltip
-+ 	{
-+ 		// Note: parent != this so that the tooltip isn't clipped by the menu rectangle
-+ 		m_tooltip_element = Environment->addStaticText(L"",core::rect<s32>(0,0,110,18));
-+ 		m_tooltip_element->enableOverrideColor(true);
-+ 		m_tooltip_element->setBackgroundColor(video::SColor(255,110,130,60));
-+ 		m_tooltip_element->setDrawBackground(true);
-+ 		m_tooltip_element->setDrawBorder(true);
-+ 		m_tooltip_element->setOverrideColor(video::SColor(255,255,255,255));
-+ 		m_tooltip_element->setTextAlignment(gui::EGUIA_CENTER, gui::EGUIA_CENTER);
-+ 		m_tooltip_element->setWordWrap(false);
-+ 		//we're not parent so no autograb for this one!
-+ 		m_tooltip_element->grab();
-++>>>>>>> sapier/fix_crash_on_lua_exception
-  	}
-  
-  	//set initial focus if parser didn't set it
-
-
-
-
-!!!!!!!!!!!!!!!!!
- Merge ShadowNinja/protection_support to next failed:
-
-# On branch next
-# You have unmerged paths.
-#   (fix conflicts and run "git commit")
-#
-# Unmerged paths:
-#   (use "git add <file>..." to mark resolution)
-#
-#	both modified:      builtin/misc_register.lua
-#	both modified:      doc/lua_api.txt
-#
-no changes added to commit (use "git add" and/or "git commit -a")
-diff --cc builtin/misc_register.lua
-index 479a339,3002d5e..0000000
---- a/builtin/misc_register.lua
-+++ b/builtin/misc_register.lua
-@@@ -342,22 -327,5 +342,25 @@@ minetest.registered_on_joinplayers, min
-  minetest.registered_on_leaveplayers, minetest.register_on_leaveplayer = make_registration()
-  minetest.registered_on_player_receive_fields, minetest.register_on_player_receive_fields = make_registration_reverse()
-  minetest.registered_on_cheats, minetest.register_on_cheat = make_registration()
-++<<<<<<< HEAD
- +minetest.registered_on_crafts, minetest.register_on_craft = make_registration()
- +minetest.registered_craft_predicts, minetest.register_craft_predict = make_registration()
-++=======
-++>>>>>>> ShadowNinja/protection_support
-  minetest.registered_on_protection_violation, minetest.register_on_protection_violation = make_registration()
-  
- +minetest.register_on_joinplayer(function(player)
- +	if minetest.is_singleplayer() then
- +		return
- +	end
- +	local player_name =  player:get_player_name()
- +	minetest.chat_send_all("*** " .. player_name .. " joined the game.")
- +end)
- +
- +minetest.register_on_dieplayer(function(player)
- +	local player_name =  player:get_player_name()
- +	if minetest.is_singleplayer() then
- +		player_name = "You"
- +	end
- +	minetest.chat_send_all(player_name .. " died.")
- +end)
-diff --cc doc/lua_api.txt
-index 5e9adff,7b53c19..0000000
---- a/doc/lua_api.txt
-+++ b/doc/lua_api.txt
-@@@ -1203,15 -1151,6 +1203,18 @@@ minetest.register_on_player_receive_fie
-  minetest.register_on_mapgen_init(func(MapgenParams))
-  ^ Called just before the map generator is initialized but before the environment is initialized
-  ^ MapgenParams consists of a table with the fields mgname, seed, water_level, and flags
-++<<<<<<< HEAD
- +minetest.register_on_craft(func(itemstack, player, old_craft_grid, craft_inv))
- +^ Called when player crafts something
- +^ itemstack is the output
- +^ old_craft_grid contains the recipe (Note: the one in the inventory is cleared)
- +^ craft_inv is the inventory with the crafting grid
- +^ Return either an ItemStack, to replace the output, or nil, to not modify it
- +minetest.register_craft_predict(func(itemstack, player, old_craft_grid, craft_inv))
- +^ The same as before, except that it is called before the player crafts, to make
- +^ craft prediction, and it should not change anything.
-++=======
-++>>>>>>> ShadowNinja/protection_support
-  minetest.register_on_protection_violation(func(pos, name))
-  ^ Called by builtin and mods when a player violates protection at a position
-    (eg, digs a node or punches a protected entity).
-@@@ -1564,28 -1498,6 +1567,31 @@@ minetest.is_protected(pos, name) -> boo
-  minetest.record_protection_violation(pos, name)
-  ^ This function calls functions registered with
-    minetest.register_on_protection_violation.
-++<<<<<<< HEAD
- +minetest.rotate_and_place(itemstack, placer, pointed_thing, infinitestacks, orient_flags)
- +^ Attempt to predict the desired orientation of the facedir-capable node
- +  defined by itemstack, and place it accordingly (on-wall, on the floor, or
- +  hanging from the ceiling). Stacks are handled normally if the infinitestacks
- +  field is false or omitted (else, the itemstack is not changed). orient_flags
- +  is an optional table containing extra tweaks to the placement code:
- +  invert_wall:		if true, place wall-orientation on the ground and ground-
- +					orientation on the wall.
- +  force_wall:		if true, always place the node in wall orientation.
- +  force_ceiling:	if true, always place on the ceiling.
- +  force_floor:		if true, always place the node on the floor.
- +
- +  The above four options are mutually-exclusive; the last in the list takes
- +  precedence over the first.
- +
- +  force_facedir:	if true, forcably reset the facedir to north when placing on
- +					the floor or ceiling
- +
- +minetest.rotate_node(itemstack, placer, pointed_thing)
- +^ calls rotate_and_place() with infinitestacks set according to the state of
- +  the creative mode setting, and checks for "sneak" to set the invert_wall
- +  parameter.
-++=======
-++>>>>>>> ShadowNinja/protection_support
-  
-  Global objects:
-  minetest.env - EnvRef of the server environment and world.
-
-
-
-
-!!!!!!!!!!!!!!!!!
- Merge Jeija/rotateto to next failed:
-
-# On branch next
-# You have unmerged paths.
-#   (fix conflicts and run "git commit")
-#
-# Changes to be committed:
-#
-#	modified:   doc/lua_api.txt
-#	modified:   src/content_sao.h
-#	modified:   src/genericobject.cpp
-#	modified:   src/genericobject.h
-#	modified:   src/script/lua_api/l_object.cpp
-#	modified:   src/script/lua_api/l_object.h
-#
-# Unmerged paths:
-#   (use "git add <file>..." to mark resolution)
-#
-#	both modified:      src/content_cao.cpp
-#	both modified:      src/content_sao.cpp
-#
-diff --cc src/content_cao.cpp
-index eda0d54,89b8dc5..0000000
---- a/src/content_cao.cpp
-+++ b/src/content_cao.cpp
-@@@ -1213,35 -1215,28 +1222,60 @@@ public
-  			m_yaw += dtime * m_prop.automatic_rotate * 180 / M_PI;
-  			updateNodePos();
-  		}
-++<<<<<<< HEAD
- +
- +		if (getParent() == NULL && m_prop.automatic_face_movement_dir &&
- +				(fabs(m_velocity.Z) > 0.001 || fabs(m_velocity.X) > 0.001)){
- +			m_yaw = atan2(m_velocity.Z,m_velocity.X) * 180 / M_PI + m_prop.automatic_face_movement_dir_offset;
- +			updateNodePos();
- +		}
- +		updateAnimationSpeed();
- +	}
- +
- +	void updateAnimationSpeed()
- +	{
- +		if(m_animated_meshnode == NULL)
- +			return;
- +
- +		if (m_anim_base_velocity > 0)
- +		{
- +			//calculate current velocity
- +			float current_velocity = XZScalar(m_velocity.X,m_velocity.Z);
- +
- +			if (fabs(m_anim_last_updated_velocity-current_velocity) > 0.05)
- +			{
- +				//calculate new animation speed
- +				float new_speed = current_velocity/m_anim_base_velocity * 15;
- +
- +				m_animated_meshnode->setAnimationSpeed(new_speed);
- +
- +				m_anim_last_updated_velocity = current_velocity;
- +			}
- +		}
-++=======
-+ 		// Automatic rotation overrides continues rotation
-+ 		if(getParent() == NULL && m_rotate_yaw_speed != 0 && fabs(m_prop.automatic_rotate) < 0.001){
-+ 			float target_yaw = m_yaw + dtime * m_rotate_yaw_speed;
-+ 			if ((m_rotate_yaw_speed > 0 && m_yaw < m_dest_yaw
-+ 				&& target_yaw > m_dest_yaw) || (m_rotate_yaw_speed < 0 
-+ 				&& m_yaw > m_dest_yaw && target_yaw < m_dest_yaw)
-+ 				|| (m_rotate_yaw_speed > 0 && m_yaw < m_dest_yaw + 360
-+ 				&& target_yaw > m_dest_yaw + 360))
-+ 			{
-+ 				// destination yaw is reached
-+ 				m_yaw = m_dest_yaw;
-+ 				m_rotate_yaw_speed = 0;
-+ 			}
-+ 			else
-+ 			{
-+ 				m_yaw = target_yaw;
-+ 			}
-+ 			updateNodePos();
-+ 		}
-+ 
-+ 		if (m_yaw > 360) m_yaw -= 360;
-+ 		if (m_yaw < 0  ) m_yaw += 360;
-++>>>>>>> Jeija/rotateto
-  	}
-  
-  	void updateTexturePos()
-diff --cc src/content_sao.cpp
-index d38894b,4bd6a23..0000000
---- a/src/content_sao.cpp
-+++ b/src/content_sao.cpp
-@@@ -528,14 -515,33 +530,39 @@@ void LuaEntitySAO::step(float dtime, bo
-  			m_velocity += dtime * m_acceleration;
-  		}
-  
-++<<<<<<< HEAD
- +		if((m_prop.automatic_face_movement_dir) &&
- +				(fabs(m_velocity.Z) > 0.001 || fabs(m_velocity.X) > 0.001)){
- +			m_yaw = atan2(m_velocity.Z,m_velocity.X) * 180 / M_PI + m_prop.automatic_face_movement_dir_offset;
- +		}
-++=======
-+ 		// Automatic rotation overrides continues rotation
-+ 		// Perform this also on the server to make getyaw() work
-+ 		if(fabs(m_prop.automatic_rotate) < 0.001){
-+ 			float target_yaw = m_yaw + dtime * m_rotate_yaw_speed;
-+ 			if ((m_rotate_yaw_speed > 0 && m_yaw < m_dest_yaw
-+ 				&& target_yaw > m_dest_yaw) || (m_rotate_yaw_speed < 0 
-+ 				&& m_yaw > m_dest_yaw && target_yaw < m_dest_yaw)
-+ 				|| (m_rotate_yaw_speed > 0 && m_yaw < m_dest_yaw + 360
-+ 				&& target_yaw > m_dest_yaw + 360))
-+ 			{
-+ 				// destination yaw is reached
-+ 				m_yaw = m_dest_yaw;
-+ 				m_rotate_yaw_speed = 0;
- -			}
-++>>>>>>> Jeija/rotateto
-++	}
-+ 			else
-+ 			{
-+ 				m_yaw = target_yaw;
-+ 			}
-+ 		}
-  	}
-  
-+ 	if (m_yaw > 360) m_yaw -= 360;
-+ 	if (m_yaw < 0  ) m_yaw += 360;
-+ 
-  	if(m_registered){
- -		lua_State *L = m_env->getLua();
- -		scriptapi_luaentity_step(L, m_id, dtime);
- +		m_env->getScriptIface()->luaentity_Step(m_id, dtime);
-  	}
-  
-  	if(send_recommended == false)
-
-
-
-
-!!!!!!!!!!!!!!!!!
- Merge Sokomine/master to next failed:
-
-# On branch next
-# You have unmerged paths.
-#   (fix conflicts and run "git commit")
-#
-# Unmerged paths:
-#   (use "git add <file>..." to mark resolution)
-#
-#	both modified:      doc/lua_api.txt
-#
-no changes added to commit (use "git add" and/or "git commit -a")
-diff --cc doc/lua_api.txt
-index 303a514,5c52606..0000000
---- a/doc/lua_api.txt
-+++ b/doc/lua_api.txt
-@@@ -2121,11 -1998,9 +2121,17 @@@ Node definition (register_node
-      <all fields allowed in item definitions>,
-  
-      drawtype = "normal", -- See "Node drawtypes"
-++<<<<<<< HEAD
- +    visual_scale = 1.0,
- +    ^ Supported for drawtypes "plantlike", "signlike", "torchlike".
- +    ^ For plantlike, the image will start at the bottom of the node; for the
- +    ^ other drawtypes, the image will be centered on the node.
- +    ^ Note that positioning for "torchlike" may still change.
-++=======
-+     visual_scale = 1.0, -- supported for drawtypes "plantlike", "signlike", "torchlike"
-+                         -- for plantlike, the image will start at the bottom of the node; for the other drawtypes, the image
-+                         -- will be centered on the node
-++>>>>>>> Sokomine/master
-      tiles = {tile definition 1, def2, def3, def4, def5, def6},
-      ^ Textures of node; +Y, -Y, +X, -X, +Z, -Z (old field name: tile_images)
-      ^ List can be shortened to needed length
-
-
-
-
-!!!!!!!!!!!!!!!!!
- Merge RealBadAngel/master to next failed:
-
-# On branch next
-# You have unmerged paths.
-#   (fix conflicts and run "git commit")
-#
-# Changes to be committed:
-#
-#	modified:   src/sky.cpp
-#	new file:   textures/base/pack/moon.png
-#	new file:   textures/base/pack/moon_tonemap.png
-#	new file:   textures/base/pack/sun.png
-#	new file:   textures/base/pack/sun_tonemap.png
-#
-# Unmerged paths:
-#   (use "git add <file>..." to mark resolution)
-#
-#	both modified:      src/sky.h
-#
-diff --cc src/sky.h
-index 35c86db,6b5ae8b..0000000
---- a/src/sky.h
-+++ b/src/sky.h
-@@@ -114,7 -78,8 +114,12 @@@ private
-  	v3f m_stars[SKY_STAR_COUNT];
-  	u16 m_star_indices[SKY_STAR_COUNT*4];
-  	video::S3DVertex m_star_vertices[SKY_STAR_COUNT*4];
-++<<<<<<< HEAD
- +	LocalPlayer* m_player;
-++=======
-+ 	video::ITexture* m_sun_tonemap;
-+ 	video::ITexture* m_moon_tonemap;
-++>>>>>>> RealBadAngel/master
-  };
-  
-  #endif
-
-
-
-
-!!!!!!!!!!!!!!!!!
- Merge ShadowNinja/pcall_errfunc to next failed:
-
-# On branch next
-# You have unmerged paths.
-#   (fix conflicts and run "git commit")
-#
-# Changes to be committed:
-#
-#	modified:   src/script/common/c_content.cpp
-#	modified:   src/script/common/c_internal.cpp
-#	modified:   src/script/common/c_internal.h
-#	modified:   src/script/common/c_types.cpp
-#	modified:   src/script/cpp_api/s_base.cpp
-#	modified:   src/script/cpp_api/s_base.h
-#	modified:   src/script/cpp_api/s_entity.cpp
-#	modified:   src/script/cpp_api/s_inventory.cpp
-#	modified:   src/script/cpp_api/s_item.cpp
-#	modified:   src/script/cpp_api/s_mainmenu.cpp
-#	modified:   src/script/cpp_api/s_node.cpp
-#	modified:   src/script/cpp_api/s_nodemeta.cpp
-#	modified:   src/script/cpp_api/s_server.cpp
-#	modified:   src/script/lua_api/l_base.h
-#	modified:   src/script/lua_api/l_craft.cpp
-#	modified:   src/script/lua_api/l_noise.cpp
-#	modified:   src/script/lua_api/l_rollback.cpp
-#	modified:   src/script/lua_api/l_server.cpp
-#
-# Unmerged paths:
-#   (use "git add <file>..." to mark resolution)
-#
-#	both modified:      src/script/lua_api/l_env.cpp
-#
-diff --cc src/script/lua_api/l_env.cpp
-index bd8e500,9bed23d..0000000
---- a/src/script/lua_api/l_env.cpp
-+++ b/src/script/lua_api/l_env.cpp
-@@@ -73,9 -78,9 +78,15 @@@ void LuaABM::trigger(ServerEnvironment 
-  	pushnode(L, n, env->getGameDef()->ndef());
-  	lua_pushnumber(L, active_object_count);
-  	lua_pushnumber(L, active_object_count_wider);
-++<<<<<<< HEAD
- +	pushnode(L, neighbor, env->getGameDef()->ndef());
- +	if(lua_pcall(L, 5, 0, 0))
- +		script_error(L, "error: %s", lua_tostring(L, -1));
-++=======
-+ 	if(lua_pcall(L, 4, 0, errorhandler))
-+ 		script_error(L);
-+ 	lua_pop(L, 1); // Pop error handler
-++>>>>>>> ShadowNinja/pcall_errfunc
-  }
-  
-  // Exported functions
diff --git a/util/next/next.pl b/util/next/next.pl
deleted file mode 100755
index cecbdef..0000000
--- a/util/next/next.pl
+++ /dev/null
@@ -1,199 +0,0 @@
-#!/usr/bin/perl
-use 5.16.0;
-#use strict;
-no strict qw(refs);
-use warnings "NONFATAL" => "all";
-no warnings qw(uninitialized);
-no if $] >= 5.017011, warnings => 'experimental::smartmatch';
-use utf8;
-use lib::abs;
-
-my $what = {
-    minetest => {
-        test      => 1,
-        submodule => qq{
-games	proller	minetest_game	next
-},
-
-        merge => qq{
-proller:next_tools
-
-proller:liquid63			882
-proller:math				645
-proller:json
-proller:weather				892
-proller:liquid_send			895
-proller:liquid_default
-proller:huge_cave
-proller:weather_fog			899
-proller:wingsuit			897
-proller:collision
-proller:light_ok			931
-proller:net				
-#proller:masterserver
-proller:null
-#proller:clouds				855
-sapier:avoid_facedir_if_not_moving	879
-sapier:modmgr_fixes			884
-#ShadowNinja:bind_address		862 #crash on connect
-Zeg9:slippery				817
-#Zeg9:wieldlight				816 #no light range BUG
-MirceaKitsune:sun_moon_coloring		799
-khonkhortisan:diagonal_rail		528
-Novatux:forceload			606
-PilzAdam:vbo
-sweetbomber:spawn			744
-MirceaKitsune:brighter_sun_faces	772
-sapier:fix_crash_on_lua_exception	890
-sapier:lua_show_backtrace_on_error	891
-sapier:fix_anaglyph_mode_selectionbox_not_beeing_honored	893
-#WilliamBundy:jump_fix			866
-ShadowNinja:protection_support		856
-sapier:fix_multiplayer_server_not_saved	846
-sapier:autoupdate_anim_speed		774
-sapier:add_surface_detection_function	640
-#khonkhortisan:vertical_particles	675 #need protocol versioning
-#sfan5:minemovie			
-Jeija:rotateto				651
-ShadowNinja:more_break_particles	943
-ShadowNinja:fall_on_unknown		942
-Sokomine:master				951
-RealBadAngel:master			967
-},
-    },
-
-    minetest_game => {
-        push_no_diff => 1,
-        submodule    => qq{
-mods	proller	minetest-mod-weather-dynamic	master
-},
-        merge => qq{
-proller:sponge			185
-proller:weather
-proller:liquid63
-#proller:mod-weather
-#Zeg9:wieldlight		188
-MirceaKitsune:moonflower	175
-khonkhortisan:diagonal_rail	135
-Novatux:furnace			200 #can make 100% cpu load
-cyisfor:master			207
-},
-    },
-
-};
-
-sub file_append(;$@) {
-    my $n = shift;
-    return unless open my $fh, '>>', $n;
-    print $fh @_ ? @_ : $_;
-    @_           ? @_ : $_;
-}
-
-sub sy (@) {
-    warn @_;
-    system @_;
-    if ($? == -1) {
-        #print "failed to execute: $!\n";
-        return $?;
-    } elsif ($? & 127) {
-        #printf "child died with signal %d, %s coredump\n",($? & 127),  ($? & 128) ? 'with' : 'without';
-        return $?;
-    } else {
-        printf "child [@_] exited with value %d\n", $? >> 8 if $?;
-        return $? >> 8;
-    }
-}
-my $target = 'next';
-my $report = [];
-my $root   = lib::abs::path('.') . '/';
-REPO: for my $repo (qw(minetest_game minetest)) {
-    my $log = "$root$repo.log";
-    unlink $log;
-    my $pullroot = "https://github.com/minetest/$repo/pull/";
-    my $dir      = $root . $repo . '_' . $target;
-    sy "git clone https://github.com/proller/$repo.git $dir";
-    chdir $dir;
-    sy $_
-      for "git reset --hard",
-      "git remote add upstream https://github.com/minetest/$repo.git",
-      "git fetch upstream",
-      "git checkout upstream/master",
-      "git clean -ffd",
-      "git branch -D $target",
-      "git checkout -b $target",
-      ;
-    my $error;
-
-    for my $from (split /\n+/, $what->{$repo}{merge}) {
-        next if $from =~ /^(?:\s*#|$)/;
-        $from =~ m{^\s*(?<user>\S+)[:/](?<branch>\S+)(\s+(?<pull>\S+))?(\s+(?<comment>.+))?};
-        my $i = {%+, repo => $repo, pullfull => "$pullroot$+{pull}"};
-        #$i->{branch} = $i->{user}, $i->{user} = undef if !$i->{branch};
-        my $path = join '/', grep {$_} $i->{user}, $i->{branch};
-
-        if ($i->{repo}) {
-            sy "git remote add $i->{user} https://github.com/$i->{user}/$repo.git";
-            sy "git fetch $i->{user}";
-        }
-
-        say "merging $path to $target";
-        if (local $_ = sy "git merge --no-edit -s recursive -X patience -X ignore-all-space $path") {
-            push @$report, {%$i, status => 'fail', code => $_};
-            file_append $log, "\n\n\n\n!!!!!!!!!!!!!!!!!\n Merge $path to $target failed:\n\n";
-            sy "git status >> $log";
-            sy "git diff >> $log";
-            ++$error, last REPO if 'fail' ~~ @ARGV;
-            sy "git reset --hard";
-        } else {
-            push @$report, {%$i, status => 'ok'};
-        }
-
-    }
-
-    for my $from (split /\n+/, $what->{$repo}{submodule}) {
-        next if $from =~ /^(?:\s*#|$)/;
-        $from =~ m{^\s*(?<dir>\S+)\s+(?<user>\S+)\s+(?<repo>\S+)\s+(?<branch>\S+)(\s+(?<comment>.+))?};
-        my $i = {%+,};
-        $i->{branch} ||= 'master';
-        $i->{clone} = "https://github.com/$i->{user}/$i->{repo}.git";
-#dmp $i;
-        sy qq{
-cd $i->{dir}
-git submodule add -f $i->{clone} $i->{repo}
-cd $i->{repo}
-git reset --hard
-git fetch --all
-git checkout origin/$i->{branch}
-cd ..
-git status
-git ci -a -m "submodule add $i->{user}/$i->{repo}/$i->{branch} to $i->{dir}";
-cd ..
-}
-
-    }
-    my $diff = qx{git diff --stat origin/next};
-    unless ($what->{$repo}{push_no_diff}) {
-        unless ($diff) {
-            say "no changes";
-            goto UP;
-        }
-    }
-
-    say "changed $diff";
-    my $test = sy "cmake . -DRUN_IN_PLACE=1 && make -j4" if $what->{$repo}{test} and !$error and !('notest' ~~ @ARGV);
-    say "test = [$test]";
-    #sy "git submodule update --init --recursive";
-    sy "git push -f" if !$test and !('nopush' ~~ @ARGV);
-  UP:
-    chdir '..';
-    sy qq{git commit -m "merge log" $log};
-}
-
-unlink $root . 'report.log';
-for my $r (@$report) {
-    local $_ = join "\t", $r->{status}, "$r->{repo} $r->{user}:$r->{branch}", $r->{code}, ($r->{pull} ? $r->{pullfull} : ()), "\n";
-    print;
-    file_append $root . 'report.log', $_;
-}
-sy qq{git commit -m "report log" ${root}report.log};
-sy "git push" if !('nopush' ~~ @ARGV);
diff --git a/util/next/report.log b/util/next/report.log
deleted file mode 100644
index 5cec830..0000000
--- a/util/next/report.log
+++ /dev/null
@@ -1,43 +0,0 @@
-ok	minetest_game proller:weather		
-ok	minetest_game proller:liquid63		
-ok	minetest_game MirceaKitsune:moonflower		https://github.com/minetest/minetest_game/pull/175	
-ok	minetest_game khonkhortisan:diagonal_rail		https://github.com/minetest/minetest_game/pull/135	
-ok	minetest_game Novatux:furnace		https://github.com/minetest/minetest_game/pull/200	
-fail	minetest_game cyisfor:master	1	https://github.com/minetest/minetest_game/pull/207	
-ok	minetest proller:next_tools		
-ok	minetest proller:liquid63		https://github.com/minetest/minetest/pull/882	
-ok	minetest proller:math		https://github.com/minetest/minetest/pull/645	
-ok	minetest proller:json		
-ok	minetest proller:weather		https://github.com/minetest/minetest/pull/892	
-ok	minetest proller:liquid_send		https://github.com/minetest/minetest/pull/895	
-ok	minetest proller:huge_cave		
-ok	minetest proller:wingsuit		https://github.com/minetest/minetest/pull/897	
-ok	minetest proller:collision		
-ok	minetest proller:light_ok		https://github.com/minetest/minetest/pull/931	
-ok	minetest proller:null		
-ok	minetest proller:die		https://github.com/minetest/minetest/pull/999	
-ok	minetest proller:range		
-ok	minetest proller:make		
-fail	minetest sapier:avoid_facedir_if_not_moving	1	https://github.com/minetest/minetest/pull/879	
-fail	minetest sapier:modmgr_fixes	1	https://github.com/minetest/minetest/pull/884	
-ok	minetest Zeg9:slippery		https://github.com/minetest/minetest/pull/817	
-ok	minetest MirceaKitsune:sun_moon_coloring		https://github.com/minetest/minetest/pull/799	
-ok	minetest khonkhortisan:diagonal_rail		https://github.com/minetest/minetest/pull/528	
-fail	minetest Novatux:forceload	1	https://github.com/minetest/minetest/pull/606	
-ok	minetest PilzAdam:vbo		
-ok	minetest sweetbomber:spawn		https://github.com/minetest/minetest/pull/744	
-ok	minetest MirceaKitsune:brighter_sun_faces		https://github.com/minetest/minetest/pull/772	
-fail	minetest sapier:fix_crash_on_lua_exception	1	https://github.com/minetest/minetest/pull/890	
-ok	minetest sapier:lua_show_backtrace_on_error		https://github.com/minetest/minetest/pull/891	
-ok	minetest sapier:fix_anaglyph_mode_selectionbox_not_beeing_honored		https://github.com/minetest/minetest/pull/893	
-fail	minetest ShadowNinja:protection_support	1	https://github.com/minetest/minetest/pull/856	
-ok	minetest sapier:fix_multiplayer_server_not_saved		https://github.com/minetest/minetest/pull/846	
-ok	minetest sapier:autoupdate_anim_speed		https://github.com/minetest/minetest/pull/774	
-ok	minetest sapier:add_surface_detection_function		https://github.com/minetest/minetest/pull/640	
-fail	minetest Jeija:rotateto	1	https://github.com/minetest/minetest/pull/651	
-ok	minetest ShadowNinja:more_break_particles		https://github.com/minetest/minetest/pull/943	
-ok	minetest ShadowNinja:fall_on_unknown		https://github.com/minetest/minetest/pull/942	
-fail	minetest Sokomine:master	1	https://github.com/minetest/minetest/pull/951	
-fail	minetest RealBadAngel:master	1	https://github.com/minetest/minetest/pull/967	
-ok	minetest celeron55:duplifix		https://github.com/minetest/minetest/pull/1000	
-fail	minetest ShadowNinja:pcall_errfunc	1	https://github.com/minetest/minetest/pull/995	




!!!!!!!!!!!!!!!!!
 Merge khonkhortisan/diagonal_rail to next failed:





!!!!!!!!!!!!!!!!!
 Merge Novatux/forceload to next failed:

# On branch next
nothing to commit, working directory clean




!!!!!!!!!!!!!!!!!
 Merge sweetbomber/spawn to next failed:

# On branch next
nothing to commit, working directory clean




!!!!!!!!!!!!!!!!!
 Merge MirceaKitsune/brighter_sun_faces to next failed:

# On branch next
nothing to commit, working directory clean




!!!!!!!!!!!!!!!!!
 Merge sapier/fix_crash_on_lua_exception to next failed:





!!!!!!!!!!!!!!!!!
 Merge sapier/fix_anaglyph_mode_selectionbox_not_beeing_honored to next failed:

# On branch next
nothing to commit, working directory clean




!!!!!!!!!!!!!!!!!
 Merge ShadowNinja/protection_support to next failed:

# On branch next
nothing to commit, working directory clean




!!!!!!!!!!!!!!!!!
 Merge Jeija/rotateto to next failed:

# On branch next
nothing to commit, working directory clean




!!!!!!!!!!!!!!!!!
 Merge Sokomine/master to next failed:

# On branch next
nothing to commit, working directory clean




!!!!!!!!!!!!!!!!!
 Merge RealBadAngel/master to next failed:

# On branch next
nothing to commit, working directory clean




!!!!!!!!!!!!!!!!!
 Merge ShadowNinja/pcall_errfunc to next failed:

# On branch next
# Changes not staged for commit:
#   (use "git add <file>..." to update what will be committed)
#   (use "git checkout -- <file>..." to discard changes in working directory)
#
#	modified:   src/script/common/c_internal.cpp
#	modified:   src/script/common/c_internal.h
#	modified:   src/script/common/c_types.cpp
#	modified:   src/script/cpp_api/s_base.cpp
#	modified:   src/script/cpp_api/s_base.h
#	modified:   src/script/cpp_api/s_entity.cpp
#	modified:   src/script/cpp_api/s_inventory.cpp
#	modified:   src/script/cpp_api/s_item.cpp
#	modified:   src/script/cpp_api/s_mainmenu.cpp
#	modified:   src/script/cpp_api/s_node.cpp
#	modified:   src/script/cpp_api/s_nodemeta.cpp
#	modified:   src/script/cpp_api/s_server.cpp
#	modified:   src/script/lua_api/l_base.h
#	modified:   src/script/lua_api/l_craft.cpp
#	modified:   src/script/lua_api/l_noise.cpp
#	modified:   src/script/lua_api/l_rollback.cpp
#	modified:   src/script/lua_api/l_server.cpp
#
no changes added to commit (use "git add" and/or "git commit -a")





!!!!!!!!!!!!!!!!!
 Merge Novatux/forceload to next failed:

# On branch next
# You have unmerged paths.
#   (fix conflicts and run "git commit")
#
# Changes to be committed:
#
#	modified:   doc/lua_api.txt
#	modified:   minetest.conf.example
#	modified:   src/defaultsettings.cpp
#	modified:   src/environment.cpp
#
# Unmerged paths:
#   (use "git add <file>..." to mark resolution)
#
#	both modified:      src/object_properties.cpp
#	both modified:      src/object_properties.h
#
diff --cc src/object_properties.cpp
index f560f59,162cc67..0000000
--- a/src/object_properties.cpp
+++ b/src/object_properties.cpp
@@@ -42,7 -42,7 +42,11 @@@ ObjectProperties::ObjectProperties()
  	automatic_rotate(0),
  	stepheight(0),
  	automatic_face_movement_dir(false),
++<<<<<<< HEAD
 +	automatic_face_movement_dir_offset(0.0)
++=======
+ 	force_load(false)
++>>>>>>> Novatux/forceload
  {
  	textures.push_back("unknown_object.png");
  	colors.push_back(video::SColor(255,255,255,255));
@@@ -105,7 -106,7 +110,11 @@@ void ObjectProperties::serialize(std::o
  	writeU8(os, collideWithObjects);
  	writeF1000(os,stepheight);
  	writeU8(os, automatic_face_movement_dir);
++<<<<<<< HEAD
 +	writeF1000(os, automatic_face_movement_dir_offset);
++=======
+ 	writeU8(os, force_load);
++>>>>>>> Novatux/forceload
  	// Add stuff only at the bottom.
  	// Never remove anything, because we don't want new versions of this
  }
@@@ -141,7 -142,7 +150,11 @@@ void ObjectProperties::deSerialize(std:
  			collideWithObjects = readU8(is);
  			stepheight = readF1000(is);
  			automatic_face_movement_dir = readU8(is);
++<<<<<<< HEAD
 +			automatic_face_movement_dir_offset = readF1000(is);
++=======
+ 			force_load = readU8(is);
++>>>>>>> Novatux/forceload
  		}catch(SerializationError &e){}
  	}
  	else
diff --cc src/object_properties.h
index 4b7f9a5,dbcbba5..0000000
--- a/src/object_properties.h
+++ b/src/object_properties.h
@@@ -46,7 -46,7 +46,11 @@@ struct ObjectPropertie
  	float automatic_rotate;
  	f32 stepheight;
  	bool automatic_face_movement_dir;
++<<<<<<< HEAD
 +	f32 automatic_face_movement_dir_offset;
++=======
+ 	bool force_load;
++>>>>>>> Novatux/forceload
  
  
  	ObjectProperties();




!!!!!!!!!!!!!!!!!
 Merge sweetbomber/spawn to next failed:

# On branch next
# You have unmerged paths.
#   (fix conflicts and run "git commit")
#
# Changes to be committed:
#
#	modified:   minetest.conf.example
#	modified:   src/defaultsettings.cpp
#	modified:   src/map.h
#	modified:   src/server.cpp
#
# Unmerged paths:
#   (use "git add <file>..." to mark resolution)
#
#	both modified:      src/map.cpp
#
diff --cc src/map.cpp
index 7aa46f6,42e9ce9..0000000
--- a/src/map.cpp
+++ b/src/map.cpp
@@@ -3243,63 -3073,123 +3243,78 @@@ MapBlock * ServerMap::emergeBlock(v3s1
  	return NULL;
  }
  
++<<<<<<< HEAD
 +void ServerMap::prepareBlock(MapBlock *block) {
 +	ServerEnvironment *senv = &((Server *)m_gamedef)->getEnv();
 +
 +	// Calculate weather conditions
 +	//block->heat_last_update     = 0;
 +	//block->humidity_last_update = 0;
 +	v3s16 p = block->getPos() *  MAP_BLOCKSIZE;
 +	updateBlockHeat(senv, p, block);
 +	updateBlockHumidity(senv, p, block);
 +}
 +
 +s16 ServerMap::findGroundLevel(v2s16 p2d)
 +{
 +#if 0
 +	/*
 +		Uh, just do something random...
++=======
+ /**
+ 		Get the ground level by searching for a non CONTENT_AIR node in a column from top to bottom
 -*/
++>>>>>>> sweetbomber/spawn
 +	*/
- 	// Find existing map from top to down
- 	s16 max=63;
- 	s16 min=-64;
- 	v3s16 p(p2d.X, max, p2d.Y);
- 	for(; p.Y>min; p.Y--)
- 	{
- 		MapNode n = getNodeNoEx(p);
- 		if(n.getContent() != CONTENT_IGNORE)
- 			break;
- 	}
- 	if(p.Y == min)
- 		goto plan_b;
- 	// If this node is not air, go to plan b
- 	if(getNodeNoEx(p).getContent() != CONTENT_AIR)
- 		goto plan_b;
- 	// Search existing walkable and return it
- 	for(; p.Y>min; p.Y--)
+ s16 ServerMap::findGroundLevel(v2s16 p2d, bool cacheBlocks)
 -{
 +	{
- 		MapNode n = getNodeNoEx(p);
- 		if(content_walkable(n.d) && n.getContent() != CONTENT_IGNORE)
- 			return p.Y;
+ 	
+ 	s16 level;
+ 
+ 	// The reference height is the original mapgen height
+ 	s16 referenceHeight = m_emerge->getGroundLevelAtPoint(p2d);
+ 	s16 maxSearchHeight =  63 + referenceHeight;
+ 	s16 minSearchHeight = -63 + referenceHeight;
+ 	v3s16 probePosition(p2d.X, maxSearchHeight, p2d.Y);
+ 	v3s16 blockPosition = getNodeBlockPos(probePosition);
+ 	v3s16 prevBlockPosition = blockPosition;
+ 
+ 	// Cache the block to be inspected.
+ 	if(cacheBlocks) {
+ 		emergeBlock(blockPosition, true);
  	}
  
- 	// Move to plan b
- plan_b:
- #endif
+ 	// Probes the nodes in the given column
+ 	for(; probePosition.Y > minSearchHeight; probePosition.Y--)
+ 	{
+ 		if(cacheBlocks) {
+ 			// Calculate the block position of the given node
+ 			blockPosition = getNodeBlockPos(probePosition); 
  
- 	/*
- 		Determine from map generator noise functions
- 	*/
+ 			// If the node is in an different block, cache it
+ 			if(blockPosition != prevBlockPosition) {
+ 				emergeBlock(blockPosition, true);
+ 				prevBlockPosition = blockPosition;
+ 			}
+ 		}
  
- 	s16 level = m_emerge->getGroundLevelAtPoint(p2d);
- 	return level;
+ 		MapNode node = getNodeNoEx(probePosition);
+ 		if(node.getContent() != CONTENT_IGNORE && node.getContent() != CONTENT_AIR)
+ 			break;
+ 	}
  
- 	//double level = base_rock_level_2d(m_seed, p2d) + AVERAGE_MUD_AMOUNT;
- 	//return (s16)level;
+ 	// Could not determine the ground. Use map generator noise functions.
+ 	if(probePosition.Y == minSearchHeight) {
+ 		level = referenceHeight; 
+ 	}
+ 	else {
+ 		level = probePosition.Y;
+ 	}
+ 
+ 	return level;
  }
  
 -void ServerMap::createDatabase() {
 -	int e;
 -	assert(m_database);
 -	e = sqlite3_exec(m_database,
 -		"CREATE TABLE IF NOT EXISTS `blocks` ("
 -			"`pos` INT NOT NULL PRIMARY KEY,"
 -			"`data` BLOB"
 -		");"
 -	, NULL, NULL, NULL);
 -	if(e == SQLITE_ABORT)
 -		throw FileNotGoodException("Could not create database structure");
 -	else
 -		infostream<<"ServerMap: Database structure was created";
 -}
 -
 -void ServerMap::verifyDatabase() {
 -	if(m_database)
 -		return;
 -
 -	{
 -		std::string dbp = m_savedir + DIR_DELIM + "map.sqlite";
 -		bool needs_create = false;
 -		int d;
 -
 -		/*
 -			Open the database connection
 -		*/
 -
 -		createDirs(m_savedir);
 -
 -		if(!fs::PathExists(dbp))
 -			needs_create = true;
 -
 -		d = sqlite3_open_v2(dbp.c_str(), &m_database, SQLITE_OPEN_READWRITE | SQLITE_OPEN_CREATE, NULL);
 -		if(d != SQLITE_OK) {
 -			infostream<<"WARNING: Database failed to open: "<<sqlite3_errmsg(m_database)<<std::endl;
 -			throw FileNotGoodException("Cannot open database file");
 -		}
 -
 -		if(needs_create)
 -			createDatabase();
 -
 -		d = sqlite3_prepare(m_database, "SELECT `data` FROM `blocks` WHERE `pos`=? LIMIT 1", -1, &m_database_read, NULL);
 -		if(d != SQLITE_OK) {
 -			infostream<<"WARNING: Database read statment failed to prepare: "<<sqlite3_errmsg(m_database)<<std::endl;
 -			throw FileNotGoodException("Cannot prepare read statement");
 -		}
 -
 -		d = sqlite3_prepare(m_database, "REPLACE INTO `blocks` VALUES(?, ?)", -1, &m_database_write, NULL);
 -		if(d != SQLITE_OK) {
 -			infostream<<"WARNING: Database write statment failed to prepare: "<<sqlite3_errmsg(m_database)<<std::endl;
 -			throw FileNotGoodException("Cannot prepare write statement");
 -		}
 -
 -		d = sqlite3_prepare(m_database, "SELECT `pos` FROM `blocks`", -1, &m_database_list, NULL);
 -		if(d != SQLITE_OK) {
 -			infostream<<"WARNING: Database list statment failed to prepare: "<<sqlite3_errmsg(m_database)<<std::endl;
 -			throw FileNotGoodException("Cannot prepare read statement");
 -		}
 -
 -		infostream<<"ServerMap: Database opened"<<std::endl;
 -	}
 -}
 -
  bool ServerMap::loadFromFolders() {
 -	if(!m_database && !fs::PathExists(m_savedir + DIR_DELIM + "map.sqlite"))
 +	if(!dbase->Initialized() && !fs::PathExists(m_savedir + DIR_DELIM + "map.sqlite")) // ?
  		return true;
  	return false;
  }




!!!!!!!!!!!!!!!!!
 Merge Jeija/rotateto to next failed:

# On branch next
# You have unmerged paths.
#   (fix conflicts and run "git commit")
#
# Changes to be committed:
#
#	modified:   doc/lua_api.txt
#	modified:   src/content_sao.h
#	modified:   src/genericobject.cpp
#	modified:   src/genericobject.h
#	modified:   src/script/lua_api/l_object.cpp
#	modified:   src/script/lua_api/l_object.h
#
# Unmerged paths:
#   (use "git add <file>..." to mark resolution)
#
#	both modified:      src/content_cao.cpp
#	both modified:      src/content_sao.cpp
#
diff --cc src/content_cao.cpp
index eda0d54,89b8dc5..0000000
--- a/src/content_cao.cpp
+++ b/src/content_cao.cpp
@@@ -1213,35 -1215,28 +1222,60 @@@ public
  			m_yaw += dtime * m_prop.automatic_rotate * 180 / M_PI;
  			updateNodePos();
  		}
++<<<<<<< HEAD
 +
 +		if (getParent() == NULL && m_prop.automatic_face_movement_dir &&
 +				(fabs(m_velocity.Z) > 0.001 || fabs(m_velocity.X) > 0.001)){
 +			m_yaw = atan2(m_velocity.Z,m_velocity.X) * 180 / M_PI + m_prop.automatic_face_movement_dir_offset;
 +			updateNodePos();
 +		}
 +		updateAnimationSpeed();
 +	}
 +
 +	void updateAnimationSpeed()
 +	{
 +		if(m_animated_meshnode == NULL)
 +			return;
 +
 +		if (m_anim_base_velocity > 0)
 +		{
 +			//calculate current velocity
 +			float current_velocity = XZScalar(m_velocity.X,m_velocity.Z);
 +
 +			if (fabs(m_anim_last_updated_velocity-current_velocity) > 0.05)
 +			{
 +				//calculate new animation speed
 +				float new_speed = current_velocity/m_anim_base_velocity * 15;
 +
 +				m_animated_meshnode->setAnimationSpeed(new_speed);
 +
 +				m_anim_last_updated_velocity = current_velocity;
 +			}
 +		}
++=======
+ 		// Automatic rotation overrides continues rotation
+ 		if(getParent() == NULL && m_rotate_yaw_speed != 0 && fabs(m_prop.automatic_rotate) < 0.001){
+ 			float target_yaw = m_yaw + dtime * m_rotate_yaw_speed;
+ 			if ((m_rotate_yaw_speed > 0 && m_yaw < m_dest_yaw
+ 				&& target_yaw > m_dest_yaw) || (m_rotate_yaw_speed < 0 
+ 				&& m_yaw > m_dest_yaw && target_yaw < m_dest_yaw)
+ 				|| (m_rotate_yaw_speed > 0 && m_yaw < m_dest_yaw + 360
+ 				&& target_yaw > m_dest_yaw + 360))
+ 			{
+ 				// destination yaw is reached
+ 				m_yaw = m_dest_yaw;
+ 				m_rotate_yaw_speed = 0;
+ 			}
+ 			else
+ 			{
+ 				m_yaw = target_yaw;
+ 			}
+ 			updateNodePos();
+ 		}
+ 
+ 		if (m_yaw > 360) m_yaw -= 360;
+ 		if (m_yaw < 0  ) m_yaw += 360;
++>>>>>>> Jeija/rotateto
  	}
  
  	void updateTexturePos()
diff --cc src/content_sao.cpp
index d38894b,4bd6a23..0000000
--- a/src/content_sao.cpp
+++ b/src/content_sao.cpp
@@@ -528,14 -515,33 +530,39 @@@ void LuaEntitySAO::step(float dtime, bo
  			m_velocity += dtime * m_acceleration;
  		}
  
++<<<<<<< HEAD
 +		if((m_prop.automatic_face_movement_dir) &&
 +				(fabs(m_velocity.Z) > 0.001 || fabs(m_velocity.X) > 0.001)){
 +			m_yaw = atan2(m_velocity.Z,m_velocity.X) * 180 / M_PI + m_prop.automatic_face_movement_dir_offset;
 +		}
++=======
+ 		// Automatic rotation overrides continues rotation
+ 		// Perform this also on the server to make getyaw() work
+ 		if(fabs(m_prop.automatic_rotate) < 0.001){
+ 			float target_yaw = m_yaw + dtime * m_rotate_yaw_speed;
+ 			if ((m_rotate_yaw_speed > 0 && m_yaw < m_dest_yaw
+ 				&& target_yaw > m_dest_yaw) || (m_rotate_yaw_speed < 0 
+ 				&& m_yaw > m_dest_yaw && target_yaw < m_dest_yaw)
+ 				|| (m_rotate_yaw_speed > 0 && m_yaw < m_dest_yaw + 360
+ 				&& target_yaw > m_dest_yaw + 360))
+ 			{
+ 				// destination yaw is reached
+ 				m_yaw = m_dest_yaw;
+ 				m_rotate_yaw_speed = 0;
 -			}
++>>>>>>> Jeija/rotateto
++	}
+ 			else
+ 			{
+ 				m_yaw = target_yaw;
+ 			}
+ 		}
  	}
  
+ 	if (m_yaw > 360) m_yaw -= 360;
+ 	if (m_yaw < 0  ) m_yaw += 360;
+ 
  	if(m_registered){
 -		lua_State *L = m_env->getLua();
 -		scriptapi_luaentity_step(L, m_id, dtime);
 +		m_env->getScriptIface()->luaentity_Step(m_id, dtime);
  	}
  
  	if(send_recommended == false)

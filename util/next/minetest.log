



!!!!!!!!!!!!!!!!!
 Merge proller/sqlite to next failed:

# On branch next
# You have unmerged paths.
#   (fix conflicts and run "git commit")
#
# Changes to be committed:
#
#	modified:   minetest.conf.example
#	modified:   src/defaultsettings.cpp
#
# Unmerged paths:
#   (use "git add <file>..." to mark resolution)
#
#	both modified:      src/map.cpp
#
diff --cc src/map.cpp
index 89f5879,16d0cc3..0000000
--- a/src/map.cpp
+++ b/src/map.cpp
@@@ -3216,8 -3167,78 +3216,81 @@@ plan_b
  	//return (s16)level;
  }
  
++<<<<<<< HEAD
++=======
+ void ServerMap::createDatabase() {
+ 	int e;
+ 	assert(m_database);
+ 	e = sqlite3_exec(m_database,
+ 		"CREATE TABLE IF NOT EXISTS `blocks` ("
+ 			"`pos` INT NOT NULL PRIMARY KEY,"
+ 			"`data` BLOB"
+ 		");"
+ 	, NULL, NULL, NULL);
+ 	if(e == SQLITE_ABORT)
+ 		throw FileNotGoodException("Could not create database structure");
+ 	else
+ 		infostream<<"ServerMap: Database structure was created";
+ }
+ 
+ void ServerMap::verifyDatabase() {
+ 	if(m_database)
+ 		return;
+ 
+ 	{
+ 		std::string dbp = m_savedir + DIR_DELIM + "map.sqlite";
+ 		bool needs_create = false;
+ 		int d;
+ 
+ 		/*
+ 			Open the database connection
+ 		*/
+ 
+ 		createDirs(m_savedir);
+ 
+ 		if(!fs::PathExists(dbp))
+ 			needs_create = true;
+ 
+ 		d = sqlite3_open_v2(dbp.c_str(), &m_database, SQLITE_OPEN_READWRITE | SQLITE_OPEN_CREATE, NULL);
+ 		if(d != SQLITE_OK) {
+ 			infostream<<"WARNING: Database failed to open: "<<sqlite3_errmsg(m_database)<<std::endl;
+ 			throw FileNotGoodException("Cannot open database file");
+ 		}
+ 
+ 		if(needs_create)
+ 			createDatabase();
+ 
+ 		d = sqlite3_exec(m_database, (std::string("PRAGMA synchronous = ") + g_settings->get("sqlite_synchronous")).c_str(), NULL, NULL, NULL);
+ 		if(d != SQLITE_OK) {
+ 			infostream<<"WARNING: Database pragma set failed: "<<sqlite3_errmsg(m_database)<<std::endl;
+ 			throw FileNotGoodException("Cannot set pragma");
+ 		}
+ 
+ 		d = sqlite3_prepare(m_database, "SELECT `data` FROM `blocks` WHERE `pos`=? LIMIT 1", -1, &m_database_read, NULL);
+ 		if(d != SQLITE_OK) {
+ 			infostream<<"WARNING: Database read statment failed to prepare: "<<sqlite3_errmsg(m_database)<<std::endl;
+ 			throw FileNotGoodException("Cannot prepare read statement");
+ 		}
+ 
+ 		d = sqlite3_prepare(m_database, "REPLACE INTO `blocks` VALUES(?, ?)", -1, &m_database_write, NULL);
+ 		if(d != SQLITE_OK) {
+ 			infostream<<"WARNING: Database write statment failed to prepare: "<<sqlite3_errmsg(m_database)<<std::endl;
+ 			throw FileNotGoodException("Cannot prepare write statement");
+ 		}
+ 
+ 		d = sqlite3_prepare(m_database, "SELECT `pos` FROM `blocks`", -1, &m_database_list, NULL);
+ 		if(d != SQLITE_OK) {
+ 			infostream<<"WARNING: Database list statment failed to prepare: "<<sqlite3_errmsg(m_database)<<std::endl;
+ 			throw FileNotGoodException("Cannot prepare read statement");
+ 		}
+ 
+ 		infostream<<"ServerMap: Database opened"<<std::endl;
+ 	}
+ }
+ 
++>>>>>>> proller/sqlite
  bool ServerMap::loadFromFolders() {
 -	if(!m_database && !fs::PathExists(m_savedir + DIR_DELIM + "map.sqlite"))
 +	if(!dbase->Initialized() && !fs::PathExists(m_savedir + DIR_DELIM + "map.sqlite")) // ?
  		return true;
  	return false;
  }




!!!!!!!!!!!!!!!!!
 Merge ShadowNinja/protection_support to next failed:

# On branch next
# You have unmerged paths.
#   (fix conflicts and run "git commit")
#
# Changes to be committed:
#
#	modified:   builtin/item.lua
#	modified:   doc/lua_api.txt
#
# Unmerged paths:
#   (use "git add <file>..." to mark resolution)
#
#	both modified:      builtin/misc.lua
#
diff --cc builtin/misc.lua
index 82a0ba2,46426ac..0000000
--- a/builtin/misc.lua
+++ b/builtin/misc.lua
@@@ -99,3 -99,15 +99,18 @@@ function minetest.setting_get_pos(name
  	return minetest.string_to_pos(value)
  end
  
++<<<<<<< HEAD
++=======
+ -- To be overriden by protection mods
+ function minetest.can_interact(pos, name)
+ 	return true
+ end
+ 
+ function minetest.formspec_escape(str)
+ 	str = string.gsub(str, "\\", "\\\\")
+ 	str = string.gsub(str, "%[", "\\[")
+ 	str = string.gsub(str, "%]", "\\]")
+ 	return str
+ end
+ 
++>>>>>>> ShadowNinja/protection_support




!!!!!!!!!!!!!!!!!
 Merge sapier/add_surface_detection_function to next failed:

# On branch next
# You have unmerged paths.
#   (fix conflicts and run "git commit")
#
# Changes to be committed:
#
#	modified:   doc/lua_api.txt
#	modified:   src/environment.h
#	modified:   src/map.cpp
#	modified:   src/map.h
#
# Unmerged paths:
#   (use "git add <file>..." to mark resolution)
#
#	both modified:      src/script/lua_api/l_env.cpp
#	both modified:      src/script/lua_api/l_env.h
#
diff --cc src/script/lua_api/l_env.cpp
index 0f2a409,47e9963..0000000
--- a/src/script/lua_api/l_env.cpp
+++ b/src/script/lua_api/l_env.cpp
@@@ -771,39 -937,49 +795,83 @@@ int ModApiEnvMod::l_get_humidity(lua_St
  }
  
  
 -bool ModApiEnvMod::Initialize(lua_State *L,int top)
 -{
 +void ModApiEnvMod::Initialize(lua_State *L, int top)
 +{
++<<<<<<< HEAD
 +	API_FCT(set_node);
 +	API_FCT(add_node);
 +	API_FCT(add_item);
 +	API_FCT(remove_node);
 +	API_FCT(get_node);
 +	API_FCT(get_node_or_nil);
 +	API_FCT(get_node_light);
 +	API_FCT(place_node);
 +	API_FCT(dig_node);
 +	API_FCT(punch_node);
 +	API_FCT(get_node_max_level);
 +	API_FCT(get_node_level);
 +	API_FCT(set_node_level);
 +	API_FCT(add_node_level);
 +	API_FCT(add_entity);
 +	API_FCT(get_meta);
 +	API_FCT(get_node_timer);
 +	API_FCT(get_player_by_name);
 +	API_FCT(get_objects_inside_radius);
 +	API_FCT(set_timeofday);
 +	API_FCT(get_timeofday);
 +	API_FCT(find_node_near);
 +	API_FCT(find_nodes_in_area);
 +	API_FCT(get_perlin);
 +	API_FCT(get_perlin_map);
 +	API_FCT(get_voxel_manip);
 +	API_FCT(clear_objects);
 +	API_FCT(spawn_tree);
 +	API_FCT(find_path);
 +	API_FCT(line_of_sight);
 +	API_FCT(transforming_liquid_add);
 +	API_FCT(get_heat);
 +	API_FCT(get_humidity);
++=======
+ 
+ 	bool retval = true;
+ 
+ 	retval &= API_FCT(set_node);
+ 	retval &= API_FCT(add_node);
+ 	retval &= API_FCT(add_item);
+ 	retval &= API_FCT(remove_node);
+ 	retval &= API_FCT(get_node);
+ 	retval &= API_FCT(get_node_or_nil);
+ 	retval &= API_FCT(get_node_light);
+ 	retval &= API_FCT(place_node);
+ 	retval &= API_FCT(dig_node);
+ 	retval &= API_FCT(punch_node);
+ 	retval &= API_FCT(get_node_max_level);
+ 	retval &= API_FCT(get_node_level);
+ 	retval &= API_FCT(set_node_level);
+ 	retval &= API_FCT(add_node_level);
+ 	retval &= API_FCT(add_entity);
+ 	retval &= API_FCT(get_meta);
+ 	retval &= API_FCT(get_node_timer);
+ 	retval &= API_FCT(get_player_by_name);
+ 	retval &= API_FCT(get_objects_inside_radius);
+ 	retval &= API_FCT(set_timeofday);
+ 	retval &= API_FCT(get_timeofday);
+ 	retval &= API_FCT(find_node_near);
+ 	retval &= API_FCT(find_nodes_in_area);
+ 	retval &= API_FCT(get_perlin);
+ 	retval &= API_FCT(get_perlin_map);
+ 	retval &= API_FCT(get_voxel_manip);
+ 	retval &= API_FCT(get_mapgen_object);
+ 	retval &= API_FCT(set_mapgen_params);
+ 	retval &= API_FCT(clear_objects);
+ 	retval &= API_FCT(get_surface);
+ 	retval &= API_FCT(spawn_tree);
+ 	retval &= API_FCT(find_path);
+ 	retval &= API_FCT(line_of_sight);
+ 	retval &= API_FCT(transforming_liquid_add);
+ 	retval &= API_FCT(get_heat);
+ 	retval &= API_FCT(get_humidity);
+ 
+ 	return retval;
++>>>>>>> sapier/add_surface_detection_function
  }
 -
 -ModApiEnvMod modapienv_prototype;
diff --cc src/script/lua_api/l_env.h
index fe2883b,b01fe5a..0000000
--- a/src/script/lua_api/l_env.h
+++ b/src/script/lua_api/l_env.h
@@@ -144,8 -159,13 +144,16 @@@ private
  	static int l_get_heat(lua_State *L);
  	static int l_get_humidity(lua_State *L);
  	
++<<<<<<< HEAD
++=======
+ 	// minetest.get_surface(basepos,yoffset,walkable_only=false)
+ 	static int l_get_surface(lua_State *L);
+ 
+ 	static struct EnumString es_MapgenObject[];
+ 	
++>>>>>>> sapier/add_surface_detection_function
  public:
 -	bool Initialize(lua_State *L, int top);
 +	static void Initialize(lua_State *L, int top);
  };
  
  class LuaABM : public ActiveBlockModifier




!!!!!!!!!!!!!!!!!
 Merge khonkhortisan/vertical_particles to next failed:

# On branch next
# You have unmerged paths.
#   (fix conflicts and run "git commit")
#
# Changes to be committed:
#
#	modified:   doc/lua_api.txt
#	modified:   src/client.cpp
#	modified:   src/client.h
#	modified:   src/clientserver.h
#	modified:   src/server.cpp
#	modified:   src/server.h
#
# Unmerged paths:
#   (use "git add <file>..." to mark resolution)
#
#	both modified:      src/game.cpp
#	both modified:      src/particles.cpp
#	both modified:      src/particles.h
#	both modified:      src/script/lua_api/l_particles.cpp
#
diff --cc src/game.cpp
index f082383,f32a73a..0000000
--- a/src/game.cpp
+++ b/src/game.cpp
@@@ -2291,9 -2069,7 +2291,13 @@@ void the_game
  						 event.spawn_particle.expirationtime,
  						 event.spawn_particle.size,
  						 event.spawn_particle.collisiondetection,
++<<<<<<< HEAD
 +						 texture,
 +						 v2f(0.0, 0.0),
 +						 v2f(1.0, 1.0));
++=======
+ 						 event.spawn_particle.vertical, ap);
++>>>>>>> khonkhortisan/vertical_particles
  				}
  				else if(event.type == CE_ADD_PARTICLESPAWNER)
  				{
@@@ -2315,7 -2091,8 +2319,12 @@@
  						 event.add_particlespawner.minsize,
  						 event.add_particlespawner.maxsize,
  						 event.add_particlespawner.collisiondetection,
++<<<<<<< HEAD
 +						 texture,
++=======
+ 						 event.add_particlespawner.vertical,
+ 						 ap,
++>>>>>>> khonkhortisan/vertical_particles
  						 event.add_particlespawner.id);
  				}
  				else if(event.type == CE_DELETE_PARTICLESPAWNER)
diff --cc src/particles.cpp
index 88905d4,e050df4..0000000
--- a/src/particles.cpp
+++ b/src/particles.cpp
@@@ -57,9 -57,8 +57,14 @@@ Particle::Particle
  	float expirationtime,
  	float size,
  	bool collisiondetection,
++<<<<<<< HEAD
 +	video::ITexture *texture,
 +	v2f texpos,
 +	v2f texsize
++=======
+ 	bool vertical,
+ 	AtlasPointer ap
++>>>>>>> khonkhortisan/vertical_particles
  ):
  	scene::ISceneNode(smgr->getRootSceneNode(), smgr)
  {
@@@ -199,8 -193,13 +205,13 @@@ void Particle::updateVertices(
  
  	for(u16 i=0; i<4; i++)
  	{
+ 		if (m_vertical) {
+ 			v3f ppos = m_player->getPosition()/BS;
+ 			m_vertices[i].Pos.rotateXZBy(atan2(ppos.Z-m_pos.Z, ppos.X-m_pos.X)/core::DEGTORAD+90);
+ 		} else {
 -			m_vertices[i].Pos.rotateYZBy(m_player->getPitch());
 -			m_vertices[i].Pos.rotateXZBy(m_player->getYaw());
 +		m_vertices[i].Pos.rotateYZBy(m_player->getPitch());
 +		m_vertices[i].Pos.rotateXZBy(m_player->getYaw());
+ 		}
  		m_box.addInternalPoint(m_vertices[i].Pos);
  		m_vertices[i].Pos += m_pos*BS;
  	}
@@@ -293,9 -292,8 +304,14 @@@ void addNodeParticle(IGameDef* gamedef
  		rand()%100/100., // expiration time
  		visual_size,
  		true,
++<<<<<<< HEAD
 +		texture,
 +		texpos,
 +		texsize);
++=======
+ 		false,
+ 		ap);
++>>>>>>> khonkhortisan/vertical_particles
  }
  
  /*
@@@ -306,7 -304,7 +322,11 @@@ ParticleSpawner::ParticleSpawner(IGameD
  	u16 amount, float time,
  	v3f minpos, v3f maxpos, v3f minvel, v3f maxvel, v3f minacc, v3f maxacc,
  	float minexptime, float maxexptime, float minsize, float maxsize,
++<<<<<<< HEAD
 +	bool collisiondetection, video::ITexture *texture, u32 id)
++=======
+ 	bool collisiondetection, bool vertical, AtlasPointer ap, u32 id)
++>>>>>>> khonkhortisan/vertical_particles
  {
  	m_gamedef = gamedef;
  	m_smgr = smgr;
@@@ -324,7 -322,8 +344,12 @@@
  	m_minsize = minsize;
  	m_maxsize = maxsize;
  	m_collisiondetection = collisiondetection;
++<<<<<<< HEAD
 +	m_texture = texture;
++=======
+ 	m_vertical = vertical;
+ 	m_ap = ap;
++>>>>>>> khonkhortisan/vertical_particles
  	m_time = 0;
  
  	for (u16 i = 0; i<=m_amount; i++)
@@@ -372,9 -371,8 +397,14 @@@ void ParticleSpawner::step(float dtime
  					exptime,
  					size,
  					m_collisiondetection,
++<<<<<<< HEAD
 +					m_texture,
 +					v2f(0.0, 0.0),
 +					v2f(1.0, 1.0));
++=======
+ 					m_vertical,
+ 					m_ap);
++>>>>>>> khonkhortisan/vertical_particles
  				m_spawntimes.erase(i);
  			}
  			else
@@@ -410,9 -408,8 +440,14 @@@
  					exptime,
  					size,
  					m_collisiondetection,
++<<<<<<< HEAD
 +					m_texture,
 +					v2f(0.0, 0.0),
 +					v2f(1.0, 1.0));
++=======
+ 					m_vertical,
+ 					m_ap);
++>>>>>>> khonkhortisan/vertical_particles
  			}
  		}
  	}
diff --cc src/particles.h
index 327dcbc,1b53e37..0000000
--- a/src/particles.h
+++ b/src/particles.h
@@@ -42,9 -42,8 +42,14 @@@ class Particle : public scene::ISceneNo
  		float expirationtime,
  		float size,
  		bool collisiondetection,
++<<<<<<< HEAD
 +		video::ITexture *texture,
 +		v2f texpos,
 +		v2f texsize
++=======
+ 		bool vertical,
+ 		AtlasPointer texture
++>>>>>>> khonkhortisan/vertical_particles
  	);
  	~Particle();
  
@@@ -88,7 -85,10 +93,14 @@@ private
  	v3f m_pos;
  	v3f m_velocity;
  	v3f m_acceleration;
++<<<<<<< HEAD
 +	LocalPlayer *m_player;
++=======
+ 	float tex_x0;
+ 	float tex_x1;
+ 	float tex_y0;
+ 	float tex_y1;
++>>>>>>> khonkhortisan/vertical_particles
  	float m_size;
  	u8 m_light;
  	bool m_collisiondetection;
@@@ -108,7 -111,8 +123,12 @@@ class ParticleSpawne
  		float minexptime, float maxexptime,
  		float minsize, float maxsize,
  		bool collisiondetection,
++<<<<<<< HEAD
 +		video::ITexture *texture,
++=======
+ 		bool vertical,
+ 		AtlasPointer ap,
++>>>>>>> khonkhortisan/vertical_particles
  		u32 id);
  
  	~ParticleSpawner();
@@@ -135,9 -139,10 +155,14 @@@
  	float m_maxexptime;
  	float m_minsize;
  	float m_maxsize;
++<<<<<<< HEAD
 +	video::ITexture *m_texture;
- 	std::vector<float> m_spawntimes;
++=======
  	bool m_collisiondetection;
+ 	bool m_vertical;
+ 	AtlasPointer m_ap;
++>>>>>>> khonkhortisan/vertical_particles
+ 	std::vector<float> m_spawntimes;
  };
  
  void allparticles_step (float dtime, ClientEnvironment &env);
diff --cc src/script/lua_api/l_particles.cpp
index 6b00914,bcb8286..0000000
--- a/src/script/lua_api/l_particles.cpp
+++ b/src/script/lua_api/l_particles.cpp
@@@ -17,39 -17,86 +17,94 @@@ with this program; if not, write to th
  51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
  */
  
 -#include "scriptapi.h"
 -#include "scriptapi_particles.h"
 +#include "lua_api/l_particles.h"
 +#include "lua_api/l_internal.h"
 +#include "common/c_converter.h"
  #include "server.h"
 -#include "script.h"
 -#include "scriptapi_types.h"
 -#include "scriptapi_common.h"
  
- // add_particle(pos, velocity, acceleration, expirationtime,
- // 		size, collisiondetection, texture, player)
+ // add_particle({pos=, velocity=, acceleration=, expirationtime=,
+ // 		size=, collisiondetection=, vertical=, texture=, player=})
  // pos/velocity/acceleration = {x=num, y=num, z=num}
  // expirationtime = num (seconds)
  // size = num
+ // collisiondetection = bool
+ // vertical = bool
  // texture = e.g."default_wood.png"
 -int l_add_particle(lua_State *L)
 +int ModApiParticles::l_add_particle(lua_State *L)
  {
 -	// Get server from registry
 -	Server *server = get_server(L);
  	// Get parameters
- 	v3f pos = check_v3f(L, 1);
- 	v3f vel = check_v3f(L, 2);
- 	v3f acc = check_v3f(L, 3);
- 	float expirationtime = luaL_checknumber(L, 4);
- 	float size = luaL_checknumber(L, 5);
- 	bool collisiondetection = lua_toboolean(L, 6);
- 	std::string texture = luaL_checkstring(L, 7);
+ 	v3f pos, vel, acc;
+ 	    pos= vel= acc= v3f(0, 0, 0);
+ 	float expirationtime, size;
+ 	      expirationtime= size= 1;
+ 	bool collisiondetection, vertical;
+ 	     collisiondetection= vertical= false;
+ 	std::string texture = "";
+ 	const char *playername = "";
  
+ 	if (lua_gettop(L) > 1) // deprecated
+ 	{
+ 		pos = check_v3f(L, 1);
+ 		vel = check_v3f(L, 2);
+ 		acc = check_v3f(L, 3);
+ 		expirationtime = luaL_checknumber(L, 4);
+ 		size = luaL_checknumber(L, 5);
+ 		collisiondetection = lua_toboolean(L, 6);
+ 		texture = luaL_checkstring(L, 7);
 -		if (lua_gettop(L) == 8) // only spawn for a single player
 +	if (lua_gettop(L) == 8) // only spawn for a single player
+ 			playername = luaL_checkstring(L, 8);
+ 	}
+ 	else if (lua_istable(L, 1))
  	{
+ 		int table = lua_gettop(L);
+ 		lua_pushnil(L);
+ 		while (lua_next(L, table) != 0)
+ 		{
+ 			const char *key = lua_tostring(L, -2);
+ 				  if(strcmp(key,"pos")==0){
+ 					pos=check_v3f(L, -1);
+ 			}else if(strcmp(key,"vel")==0){
+ 					vel=check_v3f(L, -1);
+ 			}else if(strcmp(key,"acc")==0){
+ 					acc=check_v3f(L, -1);
+ 			}else if(strcmp(key,"expirationtime")==0){
+ 					expirationtime=luaL_checknumber(L, -1);
+ 			}else if(strcmp(key,"size")==0){
+ 					size=luaL_checknumber(L, -1);
+ 			}else if(strcmp(key,"collisiondetection")==0){
+ 					collisiondetection=lua_toboolean(L, -1);
+ 			}else if(strcmp(key,"vertical")==0){
+ 					vertical=lua_toboolean(L, -1);
+ 			}else if(strcmp(key,"texture")==0){
+ 					texture=luaL_checkstring(L, -1);
+ 			}else if(strcmp(key,"playername")==0){
+ 					playername=luaL_checkstring(L, -1);
+ 			}
+ 			lua_pop(L, 1);
+ 		}
+ 	}
+ 	if (strcmp(playername, "")==0) // spawn for all players
+ 	{
+ 		server->spawnParticleAll(pos, vel, acc,
+ 			expirationtime, size, collisiondetection, vertical, texture);
+ 	}
+ 	else
+ 	{
++<<<<<<< HEAD:src/script/lua_api/l_particles.cpp
 +		const char *playername = luaL_checkstring(L, 8);
 +		getServer(L)->spawnParticle(playername,
 +			pos, vel, acc, expirationtime,
 +			size, collisiondetection, texture);
 +	}
 +	else // spawn for all players
 +	{
 +		getServer(L)->spawnParticleAll(pos, vel, acc,
 +			expirationtime, size, collisiondetection, texture);
++=======
+ 		server->spawnParticle(playername,
+ 			pos, vel, acc, expirationtime,
+ 			size, collisiondetection, vertical, texture);
++>>>>>>> khonkhortisan/vertical_particles:src/scriptapi_particles.cpp
  	}
  	return 1;
  }
@@@ -67,29 -115,101 +123,104 @@@
  // minexptime/maxexptime = num (seconds)
  // minsize/maxsize = num
  // collisiondetection = bool
+ // vertical = bool
  // texture = e.g."default_wood.png"
 -int l_add_particlespawner(lua_State *L)
 +int ModApiParticles::l_add_particlespawner(lua_State *L)
  {
 -	// Get server from registry
 -	Server *server = get_server(L);
  	// Get parameters
- 	u16 amount = luaL_checknumber(L, 1);
- 	float time = luaL_checknumber(L, 2);
- 	v3f minpos = check_v3f(L, 3);
- 	v3f maxpos = check_v3f(L, 4);
- 	v3f minvel = check_v3f(L, 5);
- 	v3f maxvel = check_v3f(L, 6);
- 	v3f minacc = check_v3f(L, 7);
- 	v3f maxacc = check_v3f(L, 8);
- 	float minexptime = luaL_checknumber(L, 9);
- 	float maxexptime = luaL_checknumber(L, 10);
- 	float minsize = luaL_checknumber(L, 11);
- 	float maxsize = luaL_checknumber(L, 12);
- 	bool collisiondetection = lua_toboolean(L, 13);
- 	std::string texture = luaL_checkstring(L, 14);
+ 	u16 amount = 1;
+ 	v3f minpos, maxpos, minvel, maxvel, minacc, maxacc;
+ 	    minpos= maxpos= minvel= maxvel= minacc= maxacc= v3f(0, 0, 0);
+ 	float time, minexptime, maxexptime, minsize, maxsize;
+ 	      time= minexptime= maxexptime= minsize= maxsize= 1;
+ 	bool collisiondetection, vertical;
+ 	     collisiondetection= vertical= false;
+ 	std::string texture = "";
+ 	const char *playername = "";
  
+ 	if (lua_gettop(L) > 1) //deprecated
+ 	{
+ 		amount = luaL_checknumber(L, 1);
+ 		time = luaL_checknumber(L, 2);
+ 		minpos = check_v3f(L, 3);
+ 		maxpos = check_v3f(L, 4);
+ 		minvel = check_v3f(L, 5);
+ 		maxvel = check_v3f(L, 6);
+ 		minacc = check_v3f(L, 7);
+ 		maxacc = check_v3f(L, 8);
+ 		minexptime = luaL_checknumber(L, 9);
+ 		maxexptime = luaL_checknumber(L, 10);
+ 		minsize = luaL_checknumber(L, 11);
+ 		maxsize = luaL_checknumber(L, 12);
+ 		collisiondetection = lua_toboolean(L, 13);
+ 		texture = luaL_checkstring(L, 14);
 -		if (lua_gettop(L) == 15) // only spawn for a single player
 +	if (lua_gettop(L) == 15) // only spawn for a single player
+ 			playername = luaL_checkstring(L, 15);
+ 	}
+ 	else if (lua_istable(L, 1))
+ 	{
+ 		int table = lua_gettop(L);
+ 		lua_pushnil(L);
+ 		while (lua_next(L, table) != 0)
+ 		{
+ 			const char *key = lua_tostring(L, -2);
+ 			      if(strcmp(key,"amount")==0){
+ 					amount=luaL_checknumber(L, -1);
+ 			}else if(strcmp(key,"time")==0){
+ 					time=luaL_checknumber(L, -1);
+ 			}else if(strcmp(key,"minpos")==0){
+ 					minpos=check_v3f(L, -1);
+ 			}else if(strcmp(key,"maxpos")==0){
+ 					maxpos=check_v3f(L, -1);
+ 			}else if(strcmp(key,"minvel")==0){
+ 					minvel=check_v3f(L, -1);
+ 			}else if(strcmp(key,"maxvel")==0){
+ 					maxvel=check_v3f(L, -1);
+ 			}else if(strcmp(key,"minacc")==0){
+ 					minacc=check_v3f(L, -1);
+ 			}else if(strcmp(key,"maxacc")==0){
+ 					maxacc=check_v3f(L, -1);
+ 			}else if(strcmp(key,"minexptime")==0){
+ 					minexptime=luaL_checknumber(L, -1);
+ 			}else if(strcmp(key,"maxexptime")==0){
+ 					maxexptime=luaL_checknumber(L, -1);
+ 			}else if(strcmp(key,"minsize")==0){
+ 					minsize=luaL_checknumber(L, -1);
+ 			}else if(strcmp(key,"maxsize")==0){
+ 					maxsize=luaL_checknumber(L, -1);
+ 			}else if(strcmp(key,"collisiondetection")==0){
+ 					collisiondetection=lua_toboolean(L, -1);
+ 			}else if(strcmp(key,"vertical")==0){
+ 					vertical=lua_toboolean(L, -1);
+ 			}else if(strcmp(key,"texture")==0){
+ 					texture=luaL_checkstring(L, -1);
+ 			}else if(strcmp(key,"playername")==0){
+ 					playername=luaL_checkstring(L, -1);
+ 			}
+ 			lua_pop(L, 1);
+ 		}
+ 	}
+ 	if (strcmp(playername, "")==0) //spawn for all players
+ 	{
+ 		u32 id = server->addParticleSpawnerAll(	amount, time,
+ 							minpos, maxpos,
+ 							minvel, maxvel,
+ 							minacc, maxacc,
+ 							minexptime, maxexptime,
+ 							minsize, maxsize,
+ 							collisiondetection,
+ 							vertical,
+ 							texture);
+ 		lua_pushnumber(L, id);
+ 	}
+ 	else
  	{
++<<<<<<< HEAD:src/script/lua_api/l_particles.cpp
 +		const char *playername = luaL_checkstring(L, 15);
 +		u32 id = getServer(L)->addParticleSpawner(playername,
++=======
+ 		u32 id = server->addParticleSpawner(playername,
++>>>>>>> khonkhortisan/vertical_particles:src/scriptapi_particles.cpp
  							amount, time,
  							minpos, maxpos,
  							minvel, maxvel,
@@@ -97,18 -217,7 +228,22 @@@
  							minexptime, maxexptime,
  							minsize, maxsize,
  							collisiondetection,
++<<<<<<< HEAD:src/script/lua_api/l_particles.cpp
 +							texture);
 +		lua_pushnumber(L, id);
 +	}
 +	else // spawn for all players
 +	{
 +		u32 id = getServer(L)->addParticleSpawnerAll(	amount, time,
 +							minpos, maxpos,
 +							minvel, maxvel,
 +							minacc, maxacc,
 +							minexptime, maxexptime,
 +							minsize, maxsize,
 +							collisiondetection,
++=======
+ 							vertical,
++>>>>>>> khonkhortisan/vertical_particles:src/scriptapi_particles.cpp
  							texture);
  		lua_pushnumber(L, id);
  	}

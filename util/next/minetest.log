



!!!!!!!!!!!!!!!!!
 Merge proller/liquid_default to next failed:# On branch next
# You have unmerged paths.
#   (fix conflicts and run "git commit")
#
# Changes to be committed:
#
#	modified:   minetest.conf.example
#
# Unmerged paths:
#   (use "git add <file>..." to mark resolution)
#
#	both modified:      src/defaultsettings.cpp
#
diff --cc src/defaultsettings.cpp
index 4eadb26,852fb9f..0000000
--- a/src/defaultsettings.cpp
+++ b/src/defaultsettings.cpp
@@@ -218,10 -217,9 +218,16 @@@ void set_default_settings(Settings *set
  	settings->setDefault("movement_gravity", "9.81");
  
  	//liquid stuff
++<<<<<<< HEAD
 +	settings->setDefault("liquid_finite", "false");
 +	settings->setDefault("liquid_loop_max", "500");
 +	settings->setDefault("liquid_update", "0.4");
 +	settings->setDefault("liquid_send", "1.0");
++=======
+ 	settings->setDefault("liquid_finite", "true");
+ 	settings->setDefault("liquid_loop_max", "1000");
+ 	settings->setDefault("liquid_update", "1.0");
++>>>>>>> proller/liquid_default
  	settings->setDefault("liquid_relax", "2");
  	settings->setDefault("liquid_fast_flood", "1");
  	settings->setDefault("underground_springs", "1");




!!!!!!!!!!!!!!!!!
 Merge khonkhortisan/diagonal_rail to next failed:# On branch next
# You have unmerged paths.
#   (fix conflicts and run "git commit")
#
# Unmerged paths:
#   (use "git add <file>..." to mark resolution)
#
#	both modified:      src/content_mapblock.cpp
#
no changes added to commit (use "git add" and/or "git commit -a")
diff --cc src/content_mapblock.cpp
index 632cb4a,16c832e..0000000
--- a/src/content_mapblock.cpp
+++ b/src/content_mapblock.cpp
@@@ -1147,205 -1174,7 +1462,209 @@@ void mapblock_mesh_generate_special(Mes
  		break;}
  		case NDT_RAILLIKE:
  		{
++<<<<<<< HEAD
 +			bool is_rail_x [] = { false, false };  /* x-1, x+1 */
 +			bool is_rail_z [] = { false, false };  /* z-1, z+1 */
 +
 +			bool is_rail_z_minus_y [] = { false, false };  /* z-1, z+1; y-1 */
 +			bool is_rail_x_minus_y [] = { false, false };  /* x-1, z+1; y-1 */
 +			bool is_rail_z_plus_y [] = { false, false };  /* z-1, z+1; y+1 */
 +			bool is_rail_x_plus_y [] = { false, false };  /* x-1, x+1; y+1 */
 +
 +			MapNode n_minus_x = data->m_vmanip.getNodeNoEx(blockpos_nodes + v3s16(x-1,y,z));
 +			MapNode n_plus_x = data->m_vmanip.getNodeNoEx(blockpos_nodes + v3s16(x+1,y,z));
 +			MapNode n_minus_z = data->m_vmanip.getNodeNoEx(blockpos_nodes + v3s16(x,y,z-1));
 +			MapNode n_plus_z = data->m_vmanip.getNodeNoEx(blockpos_nodes + v3s16(x,y,z+1));
 +			MapNode n_plus_x_plus_y = data->m_vmanip.getNodeNoEx(blockpos_nodes + v3s16(x+1, y+1, z));
 +			MapNode n_plus_x_minus_y = data->m_vmanip.getNodeNoEx(blockpos_nodes + v3s16(x+1, y-1, z));
 +			MapNode n_minus_x_plus_y = data->m_vmanip.getNodeNoEx(blockpos_nodes + v3s16(x-1, y+1, z));
 +			MapNode n_minus_x_minus_y = data->m_vmanip.getNodeNoEx(blockpos_nodes + v3s16(x-1, y-1, z));
 +			MapNode n_plus_z_plus_y = data->m_vmanip.getNodeNoEx(blockpos_nodes + v3s16(x, y+1, z+1));
 +			MapNode n_minus_z_plus_y = data->m_vmanip.getNodeNoEx(blockpos_nodes + v3s16(x, y+1, z-1));
 +			MapNode n_plus_z_minus_y = data->m_vmanip.getNodeNoEx(blockpos_nodes + v3s16(x, y-1, z+1));
 +			MapNode n_minus_z_minus_y = data->m_vmanip.getNodeNoEx(blockpos_nodes + v3s16(x, y-1, z-1));
 +
 +			content_t thiscontent = n.getContent();
 +			std::string groupname = "connect_to_raillike"; // name of the group that enables connecting to raillike nodes of different kind
 +			bool self_connect_to_raillike = ((ItemGroupList) nodedef->get(n).groups)[groupname] != 0;
 +
 +			if ((nodedef->get(n_minus_x).drawtype == NDT_RAILLIKE
 +					&& ((ItemGroupList) nodedef->get(n_minus_x).groups)[groupname] != 0
 +					&& self_connect_to_raillike)
 +					|| n_minus_x.getContent() == thiscontent)
 +				is_rail_x[0] = true;
 +
 +			if ((nodedef->get(n_minus_x_minus_y).drawtype == NDT_RAILLIKE
 +					&& ((ItemGroupList) nodedef->get(n_minus_x_minus_y).groups)[groupname] != 0
 +					&& self_connect_to_raillike)
 +					|| n_minus_x_minus_y.getContent() == thiscontent)
 +				is_rail_x_minus_y[0] = true;
 +
 +			if ((nodedef->get(n_minus_x_plus_y).drawtype == NDT_RAILLIKE
 +					&& ((ItemGroupList) nodedef->get(n_minus_x_plus_y).groups)[groupname] != 0
 +					&& self_connect_to_raillike)
 +					|| n_minus_x_plus_y.getContent() == thiscontent)
 +				is_rail_x_plus_y[0] = true;
 +
 +			if ((nodedef->get(n_plus_x).drawtype == NDT_RAILLIKE
 +					&& ((ItemGroupList) nodedef->get(n_plus_x).groups)[groupname] != 0
 +					&& self_connect_to_raillike)
 +					|| n_plus_x.getContent() == thiscontent)
 +				is_rail_x[1] = true;
 +
 +			if ((nodedef->get(n_plus_x_minus_y).drawtype == NDT_RAILLIKE
 +					&& ((ItemGroupList) nodedef->get(n_plus_x_minus_y).groups)[groupname] != 0
 +					&& self_connect_to_raillike)
 +					|| n_plus_x_minus_y.getContent() == thiscontent)
 +				is_rail_x_minus_y[1] = true;
 +
 +			if ((nodedef->get(n_plus_x_plus_y).drawtype == NDT_RAILLIKE
 +					&& ((ItemGroupList) nodedef->get(n_plus_x_plus_y).groups)[groupname] != 0
 +					&& self_connect_to_raillike)
 +					|| n_plus_x_plus_y.getContent() == thiscontent)
 +				is_rail_x_plus_y[1] = true;
 +
 +			if ((nodedef->get(n_minus_z).drawtype == NDT_RAILLIKE
 +					&& ((ItemGroupList) nodedef->get(n_minus_z).groups)[groupname] != 0
 +					&& self_connect_to_raillike)
 +					|| n_minus_z.getContent() == thiscontent)
 +				is_rail_z[0] = true;
 +
 +			if ((nodedef->get(n_minus_z_minus_y).drawtype == NDT_RAILLIKE
 +					&& ((ItemGroupList) nodedef->get(n_minus_z_minus_y).groups)[groupname] != 0
 +					&& self_connect_to_raillike)
 +					|| n_minus_z_minus_y.getContent() == thiscontent)
 +				is_rail_z_minus_y[0] = true;
 +
 +			if ((nodedef->get(n_minus_z_plus_y).drawtype == NDT_RAILLIKE
 +					&& ((ItemGroupList) nodedef->get(n_minus_z_plus_y).groups)[groupname] != 0
 +					&& self_connect_to_raillike)
 +					|| n_minus_z_plus_y.getContent() == thiscontent)
 +				is_rail_z_plus_y[0] = true;
 +
 +			if ((nodedef->get(n_plus_z).drawtype == NDT_RAILLIKE
 +					&& ((ItemGroupList) nodedef->get(n_plus_z).groups)[groupname] != 0
 +					&& self_connect_to_raillike)
 +					|| n_plus_z.getContent() == thiscontent)
 +				is_rail_z[1] = true;
 +
 +			if ((nodedef->get(n_plus_z_minus_y).drawtype == NDT_RAILLIKE
 +					&& ((ItemGroupList) nodedef->get(n_plus_z_minus_y).groups)[groupname] != 0
 +					&& self_connect_to_raillike)
 +					|| n_plus_z_minus_y.getContent() == thiscontent)
 +				is_rail_z_minus_y[1] = true;
 +
 +			if ((nodedef->get(n_plus_z_plus_y).drawtype == NDT_RAILLIKE
 +					&& ((ItemGroupList) nodedef->get(n_plus_z_plus_y).groups)[groupname] != 0
 +					&& self_connect_to_raillike)
 +					|| n_plus_z_plus_y.getContent() == thiscontent)
 +				is_rail_z_plus_y[1] = true;
 +
 +			bool is_rail_x_all[] = {false, false};
 +			bool is_rail_z_all[] = {false, false};
 +			is_rail_x_all[0]=is_rail_x[0] || is_rail_x_minus_y[0] || is_rail_x_plus_y[0];
 +			is_rail_x_all[1]=is_rail_x[1] || is_rail_x_minus_y[1] || is_rail_x_plus_y[1];
 +			is_rail_z_all[0]=is_rail_z[0] || is_rail_z_minus_y[0] || is_rail_z_plus_y[0];
 +			is_rail_z_all[1]=is_rail_z[1] || is_rail_z_minus_y[1] || is_rail_z_plus_y[1];
 +
 +			// reasonable default, flat straight unrotated rail
 +			bool is_straight = true;
 +			int adjacencies = 0;
 +			int angle = 0;
 +			u8 tileindex = 0;
 +
 +			// check for sloped rail
 +			if (is_rail_x_plus_y[0] || is_rail_x_plus_y[1] || is_rail_z_plus_y[0] || is_rail_z_plus_y[1])
 +			{
 +				adjacencies = 5; //5 means sloped
 +				is_straight = true; // sloped is always straight
 +			}
 +			else
 +			{
 +				// is really straight, rails on both sides
 +				is_straight = (is_rail_x_all[0] && is_rail_x_all[1]) || (is_rail_z_all[0] && is_rail_z_all[1]);
 +				adjacencies = is_rail_x_all[0] + is_rail_x_all[1] + is_rail_z_all[0] + is_rail_z_all[1];
 +			}
 +
 +			switch (adjacencies) {
 +			case 1:
 +				if(is_rail_x_all[0] || is_rail_x_all[1])
 +					angle = 90;
 +				break;
 +			case 2:
 +				if(!is_straight)
 +					tileindex = 1; // curved
 +				if(is_rail_x_all[0] && is_rail_x_all[1])
 +					angle = 90;
 +				if(is_rail_z_all[0] && is_rail_z_all[1]){
 +					if (is_rail_z_plus_y[0])
 +						angle = 180;
 +				}
 +				else if(is_rail_x_all[0] && is_rail_z_all[0])
 +					angle = 270;
 +				else if(is_rail_x_all[0] && is_rail_z_all[1])
 +					angle = 180;
 +				else if(is_rail_x_all[1] && is_rail_z_all[1])
 +					angle = 90;
 +				break;
 +			case 3:
 +				// here is where the potential to 'switch' a junction is, but not implemented at present
 +				tileindex = 2; // t-junction
 +				if(!is_rail_x_all[1])
 +					angle=180;
 +				if(!is_rail_z_all[0])
 +					angle=90;
 +				if(!is_rail_z_all[1])
 +					angle=270;
 +				break;
 +			case 4:
 +				tileindex = 3; // crossing
 +				break;
 +			case 5: //sloped
 +				if(is_rail_z_plus_y[0])
 +					angle = 180;
 +				if(is_rail_x_plus_y[0])
 +					angle = 90;
 +				if(is_rail_x_plus_y[1])
 +					angle = -90;
 +				break;
 +			default:
 +				break;
 +			}
 +
 +			TileSpec tile = getNodeTileN(n, p, tileindex, data);
 +			tile.material_flags &= ~MATERIAL_FLAG_BACKFACE_CULLING;
 +			tile.material_flags |= MATERIAL_FLAG_CRACK_OVERLAY;
 +
 +			u16 l = getInteriorLight(n, 0, data);
 +			video::SColor c = MapBlock_LightColor(255, l, decode_light(f.light_source));
 +
 +			float d = (float)BS/64;
 +			
 +			char g=-1;
 +			if (is_rail_x_plus_y[0] || is_rail_x_plus_y[1] || is_rail_z_plus_y[0] || is_rail_z_plus_y[1])
 +				g=1; //Object is at a slope
 +
 +			video::S3DVertex vertices[4] =
 +			{
 +					video::S3DVertex(-BS/2,-BS/2+d,-BS/2, 0,0,0, c, 0,1),
 +					video::S3DVertex(BS/2,-BS/2+d,-BS/2, 0,0,0, c, 1,1),
 +					video::S3DVertex(BS/2,g*BS/2+d,BS/2, 0,0,0, c, 1,0),
 +					video::S3DVertex(-BS/2,g*BS/2+d,BS/2, 0,0,0, c, 0,0),
 +			};
 +
 +			for(s32 i=0; i<4; i++)
 +			{
 +				if(angle != 0)
 +					vertices[i].Pos.rotateXZBy(angle);
 +				vertices[i].Pos += intToFloat(p, BS);
 +			}
 +
 +			u16 indices[] = {0,1,2,2,3,0};
 +			collector.append(tile, vertices, 4, indices, 6);
++=======
+ 			recurseRail(p, data, collector);
++>>>>>>> khonkhortisan/diagonal_rail
  		break;}
  		case NDT_NODEBOX:
  		{




!!!!!!!!!!!!!!!!!
 Merge ShadowNinja/protection_support to next failed:# On branch next
# You have unmerged paths.
#   (fix conflicts and run "git commit")
#
# Changes to be committed:
#
#	modified:   builtin/item.lua
#	modified:   doc/lua_api.txt
#
# Unmerged paths:
#   (use "git add <file>..." to mark resolution)
#
#	both modified:      builtin/misc.lua
#
diff --cc builtin/misc.lua
index 82a0ba2,46426ac..0000000
--- a/builtin/misc.lua
+++ b/builtin/misc.lua
@@@ -99,3 -99,15 +99,18 @@@ function minetest.setting_get_pos(name
  	return minetest.string_to_pos(value)
  end
  
++<<<<<<< HEAD
++=======
+ -- To be overriden by protection mods
+ function minetest.can_interact(pos, name)
+ 	return true
+ end
+ 
+ function minetest.formspec_escape(str)
+ 	str = string.gsub(str, "\\", "\\\\")
+ 	str = string.gsub(str, "%[", "\\[")
+ 	str = string.gsub(str, "%]", "\\]")
+ 	return str
+ end
+ 
++>>>>>>> ShadowNinja/protection_support

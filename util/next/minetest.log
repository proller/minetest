



!!!!!!!!!!!!!!!!!
 Merge proller/liquid63 to next failed:

# On branch next
# You have unmerged paths.
#   (fix conflicts and run "git commit")
#
# Changes to be committed:
#
#	modified:   builtin/misc_register.lua
#	modified:   doc/lua_api.txt
#	modified:   games/minimal/mods/default/init.lua
#	modified:   src/clientserver.h
#	modified:   src/mapnode.cpp
#	modified:   src/mapnode.h
#	modified:   src/nodedef.cpp
#	modified:   src/nodedef.h
#	modified:   src/script/common/c_content.cpp
#
# Unmerged paths:
#   (use "git add <file>..." to mark resolution)
#
#	both modified:      src/content_abm.cpp
#	both modified:      src/content_mapblock.cpp
#	both modified:      src/map.cpp
#
diff --cc src/content_abm.cpp
index 9289035,2bc401e..0000000
--- a/src/content_abm.cpp
+++ b/src/content_abm.cpp
@@@ -32,6 -33,177 +32,180 @@@ with this program; if not, write to th
  
  #define PP(x) "("<<(x).X<<","<<(x).Y<<","<<(x).Z<<")"
  
++<<<<<<< HEAD
++=======
+ class GrowGrassABM : public ActiveBlockModifier
+ {
+ private:
+ public:
+ 	virtual std::set<std::string> getTriggerContents()
+ 	{
+ 		std::set<std::string> s;
+ 		s.insert("mapgen_dirt");
+ 		return s;
+ 	}
+ 	virtual float getTriggerInterval()
+ 	{ return 2.0; }
+ 	virtual u32 getTriggerChance()
+ 	{ return 200; }
+ 	virtual void trigger(ServerEnvironment *env, v3s16 p, MapNode n)
+ 	{
+ 		INodeDefManager *ndef = env->getGameDef()->ndef();
+ 		ServerMap *map = &env->getServerMap();
+ 		
+ 		MapNode n_top = map->getNodeNoEx(p+v3s16(0,1,0));
+ 		content_t c_snow = ndef->getId("snow");
+ 		if(ndef->get(n_top).light_propagates &&
+ 				!ndef->get(n_top).isLiquid() &&
+ 				n_top.getLightBlend(env->getDayNightRatio(), ndef) >= 13)
+ 		{
+ 			if(c_snow != CONTENT_IGNORE && n_top.getContent() == c_snow)
+ 				n.setContent(ndef->getId("dirt_with_snow"));
+ 			else if (!env->m_use_weather || map->updateBlockHeat(env, p) > 0)
+ 				n.setContent(ndef->getId("mapgen_dirt_with_grass"));
+ 			else if (env->m_use_weather && map->updateBlockHeat(env, p) < -20)
+ 				n.setContent(ndef->getId("dirt_with_snow"));
+ 			else
+ 				return;
+ 			map->addNodeWithEvent(p, n);
+ 		}
+ 	}
+ };
+ 
+ class RemoveGrassABM : public ActiveBlockModifier
+ {
+ private:
+ public:
+ 	virtual std::set<std::string> getTriggerContents()
+ 	{
+ 		std::set<std::string> s;
+ 		s.insert("mapgen_dirt_with_grass");
+ 		return s;
+ 	}
+ 	virtual float getTriggerInterval()
+ 	{ return 2.0; }
+ 	virtual u32 getTriggerChance()
+ 	{ return 20; }
+ 	virtual void trigger(ServerEnvironment *env, v3s16 p, MapNode n)
+ 	{
+ 		INodeDefManager *ndef = env->getGameDef()->ndef();
+ 		ServerMap *map = &env->getServerMap();
+ 		
+ 		MapNode n_top = map->getNodeNoEx(p+v3s16(0,1,0));
+ 		if((!ndef->get(n_top).light_propagates &&
+ 				n_top.getContent() != CONTENT_IGNORE) ||
+ 				ndef->get(n_top).isLiquid() || 
+ 				(env->m_use_weather && map->updateBlockHeat(env, p) < -10))
+ 		{
+ 			n.setContent(ndef->getId("mapgen_dirt"));
+ 			map->addNodeWithEvent(p, n);
+ 		}
+ 	}
+ };
+ 
+ class RemoveDirtWithSnowABM : public ActiveBlockModifier
+ {
+ private:
+ public:
+ 	virtual std::set<std::string> getTriggerContents()
+ 	{
+ 		std::set<std::string> s;
+ 		s.insert("dirt_with_snow");
+ 		return s;
+ 	}
+ 	virtual float getTriggerInterval()
+ 	{ return 10.0; }
+ 	virtual u32 getTriggerChance()
+ 	{ return 100; }
+ 	virtual void trigger(ServerEnvironment *env, v3s16 p, MapNode n,
+ 				u32 active_object_count, u32 active_object_count_wider, MapNode neighbor)
+ 	{
+ 		INodeDefManager *ndef = env->getGameDef()->ndef();
+ 		ServerMap *map = &env->getServerMap();
+ 		MapNode n_top = map->getNodeNoEx(p+v3s16(0,1,0));
+ 		content_t c_snow = ndef->getId("snow");
+ 		if(ndef->get(n_top).isLiquid() ||
+ 			(env->m_use_weather && map->updateBlockHeat(env, p) > 3 && n_top.getContent() != c_snow))
+ 		{
+ 			n.setContent(ndef->getId("mapgen_dirt"));
+ 			map->addNodeWithEvent(p, n);
+ 		}
+ 	}
+ };
+ 
+ 
+ class MakeTreesFromSaplingsABM : public ActiveBlockModifier
+ {
+ private:
+ 	content_t c_junglesapling;
+ 	
+ public:
+ 	MakeTreesFromSaplingsABM(ServerEnvironment *env, INodeDefManager *nodemgr) {
+ 		c_junglesapling = nodemgr->getId("junglesapling");
+ 	}
+ 
+ 	virtual std::set<std::string> getTriggerContents()
+ 	{
+ 		std::set<std::string> s;
+ 		s.insert("sapling");
+ 		s.insert("junglesapling");
+ 		return s;
+ 	}
+ 	virtual float getTriggerInterval()
+ 	{ return 10.0; }
+ 	virtual u32 getTriggerChance()
+ 	{ return 50; }
+ 	virtual void trigger(ServerEnvironment *env, v3s16 p, MapNode n,
+ 			u32 active_object_count, u32 active_object_count_wider)
+ 	{
+ 		INodeDefManager *ndef = env->getGameDef()->ndef();
+ 		ServerMap *map = &env->getServerMap();
+ 		
+ 		MapNode n_below = map->getNodeNoEx(p - v3s16(0, 1, 0));
+ 		if (!((ItemGroupList) ndef->get(n_below).groups)["soil"])
+ 			return;
+ 			
+ 		bool is_jungle_tree = n.getContent() == c_junglesapling;
+ 		
+ 		actionstream <<"A " << (is_jungle_tree ? "jungle " : "")
+ 				<< "sapling grows into a tree at "
+ 				<< PP(p) << std::endl;
+ 
+ 		std::map<v3s16, MapBlock*> modified_blocks;
+ 		v3s16 tree_p = p;
+ 		ManualMapVoxelManipulator vmanip(map);
+ 		v3s16 tree_blockp = getNodeBlockPos(tree_p);
+ 		vmanip.initialEmerge(tree_blockp - v3s16(1,1,1), tree_blockp + v3s16(1,1,1));
+ 		
+ 		if (is_jungle_tree) {
+ 			treegen::make_jungletree(vmanip, tree_p, ndef, myrand());
+ 		} else {
+ 			bool is_apple_tree = myrand() % 4 == 0;
+ 			treegen::make_tree(vmanip, tree_p, is_apple_tree, ndef, myrand());
+ 		}
+ 		
+ 		vmanip.blitBackAll(&modified_blocks);
+ 
+ 		// update lighting
+ 		std::map<v3s16, MapBlock*> lighting_modified_blocks;
+ 		lighting_modified_blocks.insert(modified_blocks.begin(), modified_blocks.end());
+ 		map->updateLighting(lighting_modified_blocks, modified_blocks);
+ 
+ 		// Send a MEET_OTHER event
+ 		MapEditEvent event;
+ 		event.type = MEET_OTHER;
+ //		event.modified_blocks.insert(modified_blocks.begin(), modified_blocks.end());
+ 		for(std::map<v3s16, MapBlock*>::iterator
+ 			i = modified_blocks.begin();
+ 			i != modified_blocks.end(); ++i)
+ 		{
+ 			event.modified_blocks.insert(i->first);
+ 		}
+ 		map->dispatchEvent(&event);
+ 	}
+ };
+ 
++>>>>>>> proller/liquid63
  class LiquidFlowABM : public ActiveBlockModifier {
  	private:
  		std::set<std::string> contents;
@@@ -234,6 -408,10 +410,13 @@@ class LiquidMeltAround : public LiquidM
  */
  
  void add_legacy_abms(ServerEnvironment *env, INodeDefManager *nodedef) {
++<<<<<<< HEAD
++=======
+ 	env->addActiveBlockModifier(new GrowGrassABM());
+ 	env->addActiveBlockModifier(new RemoveGrassABM());
+ 	env->addActiveBlockModifier(new RemoveDirtWithSnowABM());
+ 	env->addActiveBlockModifier(new MakeTreesFromSaplingsABM(env, nodedef));
++>>>>>>> proller/liquid63
  	if (g_settings->getBool("liquid_finite")) {
  		env->addActiveBlockModifier(new LiquidFlowABM(env, nodedef));
  		env->addActiveBlockModifier(new LiquidDropABM(env, nodedef));
diff --cc src/content_mapblock.cpp
index cda1846,6a3f625..0000000
--- a/src/content_mapblock.cpp
+++ b/src/content_mapblock.cpp
@@@ -394,9 -396,7 +396,12 @@@ void mapblock_mesh_generate_special(Mes
  			else
  				l = getInteriorLight(n, 0, data);
  			video::SColor c = MapBlock_LightColor(f.alpha, l, decode_light(f.light_source));
 +			
++<<<<<<< HEAD
 +			u8 range = rangelim(nodedef->get(c_flowing).liquid_range, 1, 8);
  
++=======
++>>>>>>> proller/liquid63
  			// Neighbor liquid levels (key = relative position)
  			// Includes current node
  			std::map<v3s16, f32> neighbor_levels;
@@@ -429,12 -429,8 +434,17 @@@
  					if(n2.getContent() == c_source)
  						level = (-0.5+node_liquid_level) * BS;
  					else if(n2.getContent() == c_flowing){
++<<<<<<< HEAD
 +						u8 liquid_level = (n2.param2&LIQUID_LEVEL_MASK);
 +						if (liquid_level <= LIQUID_LEVEL_MAX+1-range)
 +							liquid_level = 0;
 +						else
 +							liquid_level -= (LIQUID_LEVEL_MAX+1-range);
 +						level = (-0.5 + ((float)liquid_level+ 0.5) / (float)range * node_liquid_level) * BS;
++=======
+ 						level = (-0.5 + ((float)n2.getLevel(nodedef)
+ 							 + 0.5) / n2.getMaxLevel(nodedef) * node_liquid_level) * BS;
++>>>>>>> proller/liquid63
  					}
  
  					// Check node above neighbor.
@@@ -689,8 -689,32 +703,32 @@@
  
  				u16 indices[] = {0,1,2,2,3,0};
  				// Add to mesh collector
+ 				collector.append(*current_tile, vertices, 4, indices, 6);
+ 			}
+ 
+ 			/*
+ 				Generate bottom side, if appropriate
+ 			*/
+ 			MapNode n_bottom = data->m_vmanip.getNodeNoEx(blockpos_nodes + v3s16(x,y-1,z));
+ 			const ContentFeatures &f_bottom = nodedef->get(n_bottom);
+ 			if (!f_bottom.walkable && n_bottom.getContent() != c_flowing &&
+ 				n_bottom.getContent() != c_source) {
+ 				video::S3DVertex vertices[4] = {
+ 					video::S3DVertex(-BS/2,0,BS/2, 0,0,0, c, 0,1),
+ 					video::S3DVertex(BS/2,0,BS/2, 0,0,0, c, 1,1),
+ 					video::S3DVertex(BS/2,0,-BS/2, 0,0,0, c, 1,0),
+ 					video::S3DVertex(-BS/2,0,-BS/2, 0,0,0, c, 0,0),
+ 				};
+ 
+ 				v3f offset(p.X*BS, p.Y*BS + -0.5*BS, p.Z*BS);
+ 				for(s32 i=0; i<4; i++) {
+ 					vertices[i].Pos += offset;
+ 				}
+ 
+ 				u16 indices[] = {0,1,2,2,3,0};
+ 				// Add to mesh collector
  				collector.append(tile_liquid, vertices, 4, indices, 6);
 -                        }
 +			}
  		break;}
  		case NDT_GLASSLIKE:
  		{
diff --cc src/map.cpp
index 968897c,499a117..0000000
--- a/src/map.cpp
+++ b/src/map.cpp
@@@ -1776,12 -1833,14 +1833,14 @@@ void Map::transformLiquidsFinite(std::m
  		}
  
  		//relax up
- 		if (relax && ((p0.Y == water_level) || (fast_flood && p0.Y <= water_level)) && liquid_levels[D_TOP] == 0 &&
- 			liquid_levels[D_BOTTOM] == LIQUID_LEVEL_SOURCE &&
- 			total_level >= LIQUID_LEVEL_SOURCE * can_liquid_same_level-
+ 		if (relax && ((p0.Y == water_level) || (fast_flood && p0.Y <= water_level)) &&
+ 			level_max > 1 &&
+ 			liquid_levels[D_TOP] == 0 &&
+ 			liquid_levels[D_BOTTOM] == level_max &&
+ 			total_level >= level_max * can_liquid_same_level -
  			(can_liquid_same_level - relax) &&
 -			can_liquid_same_level >= relax + 1) {
 +			can_liquid_same_level >= relax + 1) { 
- 			total_level = LIQUID_LEVEL_SOURCE * can_liquid_same_level; 
+ 			total_level = level_max * can_liquid_same_level;
  		}
  
  		// prevent lakes in air above unloaded blocks
@@@ -1838,20 -1905,23 +1905,23 @@@
  		}
  
  		for (u16 ii = 0; ii < 7; ii++) // infinity and cave flood optimization
 -			if (    neighbors[ii].i			||
 -				(liquid_levels_want[ii] >= 0	&&
 +			if (    neighbors[ii].i ||
 +				(liquid_levels_want[ii] >= 0 &&
- 				 (fast_flood && p0.Y < water_level &&
- 				  (initial_size >= 1000
- 				   && ii != D_TOP
- 				   && want_level >= LIQUID_LEVEL_SOURCE/4
- 				   && can_liquid_same_level >= 5
- 				   && liquid_levels[D_TOP] >= LIQUID_LEVEL_SOURCE))))
- 				liquid_levels_want[ii] = LIQUID_LEVEL_SOURCE;
+ 				 level_max > 1			&&
+ 				 fast_flood			&&
+ 				 p0.Y < water_level		&&
+ 				 initial_size >= loop_max	&&
+ 				 ii != D_TOP			&&
+ 				 want_level >= level_max/4	&&
+ 				 can_liquid_same_level >= 5	&&
+ 				 liquid_levels[D_TOP] >= level_max))
+ 					liquid_levels_want[ii] = level_max;
  
  		/*
  		if (total_level > 0) //|| flowed != volume)
 -			infostream <<" AFTER level=" << (int)total_level
 +			infostream <<" AFTER level=" << (int)total_level 
  			//<< " flowed="<<flowed<< " volume=" << volume
+ 			<< " max="<<(int)level_max
  			<< " wantsame="<<(int)want_level<< " top="
  			<< (int)liquid_levels_want[D_TOP]<< " topwas="
  			<< (int)liquid_levels[D_TOP]<< " bot="
@@@ -1881,23 -1952,18 +1952,18 @@@
  				else if (level_inc > 0)
  					new_node_level = liquid_levels[i] + 1;
  			} else {
+ 			*/
 -			new_node_level = liquid_levels_want[i];
 +				new_node_level = liquid_levels_want[i];
- 			}
- 			
- 			if (new_node_level >= LIQUID_LEVEL_SOURCE)
- 				new_node_content = liquid_kind;
- 			else if (new_node_level > 0)
- 				new_node_content = liquid_kind_flowing;
- 			else
- 				new_node_content = CONTENT_AIR;
+ 			/* } */
 -
 +			
  			// last level must flow down on stairs
  			if (liquid_levels_want[i] != liquid_levels[i] &&
- 				liquid_levels[D_TOP] <= 0 && !neighbors[D_BOTTOM].l &&
+ 				liquid_levels[D_TOP] <= 0 && (!neighbors[D_BOTTOM].l || level_max == 1) &&
  				new_node_level >= 1 && new_node_level <= 2) {
- 				for (u16 ii = D_SELF + 1; ii < D_TOP; ++ii) { // only same level
+ 				for (u16 ir = D_SELF + 1; ir < D_TOP; ++ir) { // only same level
+ 					u16 ii = liquid_random_map[(loopcount+loop_rand+4)%4][ir];
  					if (neighbors[ii].l)
- 						must_reflow_second.push_back(p0 + dirs[ii]);
+ 						must_reflow_second.push_back(p0 + liquid_flow_dirs[ii]);
  				}
  			}
  
@@@ -1923,29 -1975,10 +1975,10 @@@
  			{
  				continue;
  			}
 -
 +			
- 			//++changed;
- 
- 			/*
- 				update the current node
- 			 */
- 			/*
- 			if (nodemgr->get(new_node_content).liquid_type == LIQUID_FLOWING) {
- 				// set level to last 3 bits, flowing down bit to 4th bit
- 				n0.param2 = (new_node_level & LIQUID_LEVEL_MASK);
- 			} else if (nodemgr->get(new_node_content).liquid_type == LIQUID_SOURCE) {
- 				//n0.param2 = ~(LIQUID_LEVEL_MASK | LIQUID_FLOW_DOWN_MASK);
- 				n0.param2 = (neighbors[i].i ? LIQUID_INFINITY_MASK : 0x00);
- 			}
- 			*/
- 			/*
- 			infostream << "set node i=" <<(int)i<<" "<< PP(p0)<< " nc="
- 			<<new_node_content<< " p2="<<(int)n0.param2<< " nl="
- 			<<(int)new_node_level<<std::endl;
- 			*/
- 			
  			n0.setContent(liquid_kind_flowing);
  			n0.setLevel(nodemgr, new_node_level);
+ 			/* rollback will stop your server if enabled with liquid_finite
  			// Find out whether there is a suspect for this action
  			std::string suspect;
  			if(m_gamedef->rollback()){
@@@ -1965,18 -1998,22 +1998,22 @@@
  				action.setSetNode(p0, rollback_oldnode, rollback_newnode);
  				m_gamedef->rollback()->reportAction(action);
  			} else {
+ 			*/
  				// Set node
 -			setNode(p0, n0);
 +				setNode(p0, n0);
- 			}
+ 			//}
  
- 			v3s16 blockpos = getNodeBlockPos(p0);
- 			MapBlock *block = getBlockNoCreateNoEx(blockpos);
- 			if(block != NULL) {
- 				modified_blocks[blockpos] = block;
 -			// If node emits light, MapBlock requires lighting update
 +				// If node emits light, MapBlock requires lighting update
- 				if(nodemgr->get(n0).light_source != 0)
+ 			// or if node removed
+ 			if (new_node_level <= 0 || nodemgr->get(n0).light_source) { 
+ 				v3s16 blockpos = getNodeBlockPos(p0);
+ 				MapBlock *block = getBlockNoCreateNoEx(blockpos);
+ 				if(block != NULL) {
+ 					modified_blocks[blockpos] = block;
+ 					//if(nodemgr->get(n0).light_source != 0) // better ro update always
  					lighting_modified_blocks[block->getPos()] = block;
 -				}
 +			}
+ 			}
  			must_reflow.push_back(neighbors[i].p);
  		}
  		/* //for better relax  only same level
@@@ -2141,13 -2180,14 +2181,21 @@@ void Map::transformLiquids(std::map<v3s
  			// liquid_kind will be set to either the flowing alternative of the node (if it's a liquid)
  			// or the flowing alternative of the first of the surrounding sources (if it's air), so
  			// it's perfectly safe to use liquid_kind here to determine the new node content.
- 			new_node_content = nodemgr->getId(nodemgr->get(liquid_kind).liquid_alternative_source);
+ 			//new_node_content = nodemgr->getId(nodemgr->get(liquid_kind).liquid_alternative_source);
+ 			//new_node_content = liquid_kind;
+ 			//max_node_level = level_max + 1;
+ 			new_node_level = level_max + 1;
  		} else if (num_sources >= 1 && sources[0].t != NEIGHBOR_LOWER) {
  			// liquid_kind is set properly, see above
++<<<<<<< HEAD
 +			new_node_content = liquid_kind;
 +			max_node_level = new_node_level = LIQUID_LEVEL_MAX;
 +			if (new_node_level < (LIQUID_LEVEL_MAX+1-range))
 +				new_node_content = CONTENT_AIR;
++=======
+ 			//new_node_content = liquid_kind;
+ 			new_node_level = level_max;
++>>>>>>> proller/liquid63
  		} else {
  			// no surrounding sources, so get the maximum level that can flow into this node
  			for (u16 i = 0; i < num_flows; i++) {
@@@ -2188,7 -2229,12 +2237,16 @@@
  			} else
  				new_node_level = max_node_level;
  
++<<<<<<< HEAD
 +			if (max_node_level >= (LIQUID_LEVEL_MAX+1-range))
++=======
+ /*
+ 			u8 range = rangelim(nodemgr->get(liquid_kind).liquid_range, 0, level_max+1);
+ 			if (new_node_level >= (level_max+1-range))
+ */
+ /*
+ 			if (new_node_level >= 1)
++>>>>>>> proller/liquid63
  				new_node_content = liquid_kind;
  			else
  				new_node_content = CONTENT_AIR;




!!!!!!!!!!!!!!!!!
 Merge proller/liquid_send to next failed:

# On branch next
# You have unmerged paths.
#   (fix conflicts and run "git commit")
#
# Changes to be committed:
#
#	modified:   minetest.conf.example
#	modified:   src/defaultsettings.cpp
#	modified:   src/environment.cpp
#	modified:   src/map.cpp
#	modified:   src/map.h
#	modified:   src/script/cpp_api/s_mainmenu.h
#	modified:   src/server.cpp
#	modified:   src/server.h
#	modified:   src/util/numeric.h
#
# Unmerged paths:
#   (use "git add <file>..." to mark resolution)
#
#	both modified:      games/minimal/mods/default/init.lua
#
diff --cc games/minimal/mods/default/init.lua
index eae1fab,bc61106..0000000
--- a/games/minimal/mods/default/init.lua
+++ b/games/minimal/mods/default/init.lua
@@@ -1620,7 -1620,7 +1620,11 @@@ minetest.register_abm(
  		local nodedef = minetest.registered_nodes[name]
  		if nodedef and (nodedef.sunlight_propagates or nodedef.paramtype == "light")
  				and nodedef.liquidtype == "none"
++<<<<<<< HEAD
 +				and (minetest.get_node_light(above) or 0) >= 13 then
++=======
+ 				and (minetest.get_node_light(above) >= 13 or 0) then
++>>>>>>> proller/liquid_send
  			if name == "default:snow" or name == "default:snowblock" then
  				minetest.set_node(pos, {name = "default:dirt_with_snow"})
  			else




!!!!!!!!!!!!!!!!!
 Merge sapier/avoid_facedir_if_not_moving to next failed:

# On branch next
# You have unmerged paths.
#   (fix conflicts and run "git commit")
#
# Unmerged paths:
#   (use "git add <file>..." to mark resolution)
#
#	both modified:      src/content_cao.cpp
#	both modified:      src/content_sao.cpp
#
no changes added to commit (use "git add" and/or "git commit -a")
diff --cc src/content_cao.cpp
index e97e3a1,fb4bc95..0000000
--- a/src/content_cao.cpp
+++ b/src/content_cao.cpp
@@@ -1211,9 -1211,9 +1211,15 @@@ public
  			updateNodePos();
  		}
  
++<<<<<<< HEAD
 +		if (getParent() == NULL && m_prop.automatic_face_movement_dir &&
 +				(fabs(m_velocity.Z) > 0.001 || fabs(m_velocity.X) > 0.001)){
 +			m_yaw = atan2(m_velocity.Z,m_velocity.X) * 180 / M_PI + m_prop.automatic_face_movement_dir_offset;
++=======
+ 		if ((getParent() == NULL && m_prop.automatic_face_movement_dir) &&
+ 			((m_velocity.Z != 0) || (m_velocity.X != 0))){
+ 			m_yaw = atan2(m_velocity.Z,m_velocity.X) * 180 / M_PI;
++>>>>>>> sapier/avoid_facedir_if_not_moving
  			updateNodePos();
  		}
  	}
diff --cc src/content_sao.cpp
index 85ab8d3,92cabfb..0000000
--- a/src/content_sao.cpp
+++ b/src/content_sao.cpp
@@@ -527,9 -527,9 +527,14 @@@ void LuaEntitySAO::step(float dtime, bo
  			m_velocity += dtime * m_acceleration;
  		}
  
 -		if( (m_prop.automatic_face_movement_dir) &&
 +		if((m_prop.automatic_face_movement_dir) &&
++<<<<<<< HEAD
 +				(fabs(m_velocity.Z) > 0.001 || fabs(m_velocity.X) > 0.001)){
 +			m_yaw = atan2(m_velocity.Z,m_velocity.X) * 180 / M_PI + m_prop.automatic_face_movement_dir_offset;
++=======
+ 			((m_velocity.Z != 0) || (m_velocity.X != 0))){
+ 			m_yaw = atan2(m_velocity.Z,m_velocity.X) * 180 / M_PI;
++>>>>>>> sapier/avoid_facedir_if_not_moving
  		}
  	}
  




!!!!!!!!!!!!!!!!!
 Merge Novatux/forceload to next failed:

# On branch next
# You have unmerged paths.
#   (fix conflicts and run "git commit")
#
# Changes to be committed:
#
#	modified:   doc/lua_api.txt
#	modified:   minetest.conf.example
#	modified:   src/defaultsettings.cpp
#	modified:   src/environment.cpp
#
# Unmerged paths:
#   (use "git add <file>..." to mark resolution)
#
#	both modified:      src/object_properties.cpp
#	both modified:      src/object_properties.h
#
diff --cc src/object_properties.cpp
index f560f59,162cc67..0000000
--- a/src/object_properties.cpp
+++ b/src/object_properties.cpp
@@@ -42,7 -42,7 +42,11 @@@ ObjectProperties::ObjectProperties()
  	automatic_rotate(0),
  	stepheight(0),
  	automatic_face_movement_dir(false),
++<<<<<<< HEAD
 +	automatic_face_movement_dir_offset(0.0)
++=======
+ 	force_load(false)
++>>>>>>> Novatux/forceload
  {
  	textures.push_back("unknown_object.png");
  	colors.push_back(video::SColor(255,255,255,255));
@@@ -105,7 -106,7 +110,11 @@@ void ObjectProperties::serialize(std::o
  	writeU8(os, collideWithObjects);
  	writeF1000(os,stepheight);
  	writeU8(os, automatic_face_movement_dir);
++<<<<<<< HEAD
 +	writeF1000(os, automatic_face_movement_dir_offset);
++=======
+ 	writeU8(os, force_load);
++>>>>>>> Novatux/forceload
  	// Add stuff only at the bottom.
  	// Never remove anything, because we don't want new versions of this
  }
@@@ -141,7 -142,7 +150,11 @@@ void ObjectProperties::deSerialize(std:
  			collideWithObjects = readU8(is);
  			stepheight = readF1000(is);
  			automatic_face_movement_dir = readU8(is);
++<<<<<<< HEAD
 +			automatic_face_movement_dir_offset = readF1000(is);
++=======
+ 			force_load = readU8(is);
++>>>>>>> Novatux/forceload
  		}catch(SerializationError &e){}
  	}
  	else
diff --cc src/object_properties.h
index 4b7f9a5,dbcbba5..0000000
--- a/src/object_properties.h
+++ b/src/object_properties.h
@@@ -46,7 -46,7 +46,11 @@@ struct ObjectPropertie
  	float automatic_rotate;
  	f32 stepheight;
  	bool automatic_face_movement_dir;
++<<<<<<< HEAD
 +	f32 automatic_face_movement_dir_offset;
++=======
+ 	bool force_load;
++>>>>>>> Novatux/forceload
  
  
  	ObjectProperties();




!!!!!!!!!!!!!!!!!
 Merge ShadowNinja/protection_support to next failed:

# On branch next
# You have unmerged paths.
#   (fix conflicts and run "git commit")
#
# Unmerged paths:
#   (use "git add <file>..." to mark resolution)
#
#	both modified:      builtin/misc_register.lua
#	both modified:      doc/lua_api.txt
#
no changes added to commit (use "git add" and/or "git commit -a")
diff --cc builtin/misc_register.lua
index bb2c62a,3002d5e..0000000
--- a/builtin/misc_register.lua
+++ b/builtin/misc_register.lua
@@@ -342,7 -327,5 +342,10 @@@ minetest.registered_on_joinplayers, min
  minetest.registered_on_leaveplayers, minetest.register_on_leaveplayer = make_registration()
  minetest.registered_on_player_receive_fields, minetest.register_on_player_receive_fields = make_registration_reverse()
  minetest.registered_on_cheats, minetest.register_on_cheat = make_registration()
++<<<<<<< HEAD
 +minetest.registered_on_crafts, minetest.register_on_craft = make_registration()
 +minetest.registered_craft_predicts, minetest.register_craft_predict = make_registration()
++=======
++>>>>>>> ShadowNinja/protection_support
  minetest.registered_on_protection_violation, minetest.register_on_protection_violation = make_registration()
  
diff --cc doc/lua_api.txt
index 7e8025a,7b53c19..0000000
--- a/doc/lua_api.txt
+++ b/doc/lua_api.txt
@@@ -1158,15 -1151,6 +1158,18 @@@ minetest.register_on_player_receive_fie
  minetest.register_on_mapgen_init(func(MapgenParams))
  ^ Called just before the map generator is initialized but before the environment is initialized
  ^ MapgenParams consists of a table with the fields mgname, seed, water_level, and flags
++<<<<<<< HEAD
 +minetest.register_on_craft(func(itemstack, player, old_craft_grid, craft_inv))
 +^ Called when player crafts something
 +^ itemstack is the output
 +^ old_craft_grid contains the recipe (Note: the one in the inventory is cleared)
 +^ craft_inv is the inventory with the crafting grid
 +^ Return either an ItemStack, to replace the output, or nil, to not modify it
 +minetest.register_craft_predict(func(itemstack, player, old_craft_grid, craft_inv))
 +^ The same as before, except that it is called before the player crafts, to make
 +^ craft prediction, and it should not change anything.
++=======
++>>>>>>> ShadowNinja/protection_support
  minetest.register_on_protection_violation(func(pos, name))
  ^ Called by builtin and mods when a player violates protection at a position
    (eg, digs a node or punches a protected entity).




!!!!!!!!!!!!!!!!!
 Merge Jeija/rotateto to next failed:

# On branch next
# You have unmerged paths.
#   (fix conflicts and run "git commit")
#
# Changes to be committed:
#
#	modified:   doc/lua_api.txt
#	modified:   src/content_sao.h
#	modified:   src/genericobject.cpp
#	modified:   src/genericobject.h
#	modified:   src/script/lua_api/l_object.cpp
#	modified:   src/script/lua_api/l_object.h
#
# Unmerged paths:
#   (use "git add <file>..." to mark resolution)
#
#	both modified:      src/content_cao.cpp
#	both modified:      src/content_sao.cpp
#
diff --cc src/content_cao.cpp
index eda0d54,89b8dc5..0000000
--- a/src/content_cao.cpp
+++ b/src/content_cao.cpp
@@@ -1213,35 -1215,28 +1222,60 @@@ public
  			m_yaw += dtime * m_prop.automatic_rotate * 180 / M_PI;
  			updateNodePos();
  		}
++<<<<<<< HEAD
 +
 +		if (getParent() == NULL && m_prop.automatic_face_movement_dir &&
 +				(fabs(m_velocity.Z) > 0.001 || fabs(m_velocity.X) > 0.001)){
 +			m_yaw = atan2(m_velocity.Z,m_velocity.X) * 180 / M_PI + m_prop.automatic_face_movement_dir_offset;
 +			updateNodePos();
 +		}
 +		updateAnimationSpeed();
 +	}
 +
 +	void updateAnimationSpeed()
 +	{
 +		if(m_animated_meshnode == NULL)
 +			return;
 +
 +		if (m_anim_base_velocity > 0)
 +		{
 +			//calculate current velocity
 +			float current_velocity = XZScalar(m_velocity.X,m_velocity.Z);
 +
 +			if (fabs(m_anim_last_updated_velocity-current_velocity) > 0.05)
 +			{
 +				//calculate new animation speed
 +				float new_speed = current_velocity/m_anim_base_velocity * 15;
 +
 +				m_animated_meshnode->setAnimationSpeed(new_speed);
 +
 +				m_anim_last_updated_velocity = current_velocity;
 +			}
 +		}
++=======
+ 		// Automatic rotation overrides continues rotation
+ 		if(getParent() == NULL && m_rotate_yaw_speed != 0 && fabs(m_prop.automatic_rotate) < 0.001){
+ 			float target_yaw = m_yaw + dtime * m_rotate_yaw_speed;
+ 			if ((m_rotate_yaw_speed > 0 && m_yaw < m_dest_yaw
+ 				&& target_yaw > m_dest_yaw) || (m_rotate_yaw_speed < 0 
+ 				&& m_yaw > m_dest_yaw && target_yaw < m_dest_yaw)
+ 				|| (m_rotate_yaw_speed > 0 && m_yaw < m_dest_yaw + 360
+ 				&& target_yaw > m_dest_yaw + 360))
+ 			{
+ 				// destination yaw is reached
+ 				m_yaw = m_dest_yaw;
+ 				m_rotate_yaw_speed = 0;
+ 			}
+ 			else
+ 			{
+ 				m_yaw = target_yaw;
+ 			}
+ 			updateNodePos();
+ 		}
+ 
+ 		if (m_yaw > 360) m_yaw -= 360;
+ 		if (m_yaw < 0  ) m_yaw += 360;
++>>>>>>> Jeija/rotateto
  	}
  
  	void updateTexturePos()
diff --cc src/content_sao.cpp
index d38894b,4bd6a23..0000000
--- a/src/content_sao.cpp
+++ b/src/content_sao.cpp
@@@ -528,14 -515,33 +530,39 @@@ void LuaEntitySAO::step(float dtime, bo
  			m_velocity += dtime * m_acceleration;
  		}
  
++<<<<<<< HEAD
 +		if((m_prop.automatic_face_movement_dir) &&
 +				(fabs(m_velocity.Z) > 0.001 || fabs(m_velocity.X) > 0.001)){
 +			m_yaw = atan2(m_velocity.Z,m_velocity.X) * 180 / M_PI + m_prop.automatic_face_movement_dir_offset;
 +		}
++=======
+ 		// Automatic rotation overrides continues rotation
+ 		// Perform this also on the server to make getyaw() work
+ 		if(fabs(m_prop.automatic_rotate) < 0.001){
+ 			float target_yaw = m_yaw + dtime * m_rotate_yaw_speed;
+ 			if ((m_rotate_yaw_speed > 0 && m_yaw < m_dest_yaw
+ 				&& target_yaw > m_dest_yaw) || (m_rotate_yaw_speed < 0 
+ 				&& m_yaw > m_dest_yaw && target_yaw < m_dest_yaw)
+ 				|| (m_rotate_yaw_speed > 0 && m_yaw < m_dest_yaw + 360
+ 				&& target_yaw > m_dest_yaw + 360))
+ 			{
+ 				// destination yaw is reached
+ 				m_yaw = m_dest_yaw;
+ 				m_rotate_yaw_speed = 0;
 -			}
++>>>>>>> Jeija/rotateto
++	}
+ 			else
+ 			{
+ 				m_yaw = target_yaw;
+ 			}
+ 		}
  	}
  
+ 	if (m_yaw > 360) m_yaw -= 360;
+ 	if (m_yaw < 0  ) m_yaw += 360;
+ 
  	if(m_registered){
 -		lua_State *L = m_env->getLua();
 -		scriptapi_luaentity_step(L, m_id, dtime);
 +		m_env->getScriptIface()->luaentity_Step(m_id, dtime);
  	}
  
  	if(send_recommended == false)




!!!!!!!!!!!!!!!!!
 Merge Sokomine/master to next failed:

# On branch next
# You have unmerged paths.
#   (fix conflicts and run "git commit")
#
# Unmerged paths:
#   (use "git add <file>..." to mark resolution)
#
#	both modified:      doc/lua_api.txt
#
no changes added to commit (use "git add" and/or "git commit -a")
diff --cc doc/lua_api.txt
index 396a3d1,5c52606..0000000
--- a/doc/lua_api.txt
+++ b/doc/lua_api.txt
@@@ -2054,11 -1998,9 +2054,17 @@@ Node definition (register_node
      <all fields allowed in item definitions>,
  
      drawtype = "normal", -- See "Node drawtypes"
++<<<<<<< HEAD
 +    visual_scale = 1.0,
 +    ^ Supported for drawtypes "plantlike", "signlike", "torchlike".
 +    ^ For plantlike, the image will start at the bottom of the node; for the
 +    ^ other drawtypes, the image will be centered on the node.
 +    ^ Note that positioning for "torchlike" may still change.
++=======
+     visual_scale = 1.0, -- supported for drawtypes "plantlike", "signlike", "torchlike"
+                         -- for plantlike, the image will start at the bottom of the node; for the other drawtypes, the image
+                         -- will be centered on the node
++>>>>>>> Sokomine/master
      tiles = {tile definition 1, def2, def3, def4, def5, def6},
      ^ Textures of node; +Y, -Y, +X, -X, +Z, -Z (old field name: tile_images)
      ^ List can be shortened to needed length




!!!!!!!!!!!!!!!!!
 Merge RealBadAngel/master to next failed:

# On branch next
# You have unmerged paths.
#   (fix conflicts and run "git commit")
#
# Changes to be committed:
#
#	modified:   src/sky.cpp
#	new file:   textures/base/pack/moon.png
#	new file:   textures/base/pack/moon_tonemap.png
#	new file:   textures/base/pack/sun.png
#	new file:   textures/base/pack/sun_tonemap.png
#
# Unmerged paths:
#   (use "git add <file>..." to mark resolution)
#
#	both modified:      src/sky.h
#
diff --cc src/sky.h
index 35c86db,6b5ae8b..0000000
--- a/src/sky.h
+++ b/src/sky.h
@@@ -114,7 -78,8 +114,12 @@@ private
  	v3f m_stars[SKY_STAR_COUNT];
  	u16 m_star_indices[SKY_STAR_COUNT*4];
  	video::S3DVertex m_star_vertices[SKY_STAR_COUNT*4];
++<<<<<<< HEAD
 +	LocalPlayer* m_player;
++=======
+ 	video::ITexture* m_sun_tonemap;
+ 	video::ITexture* m_moon_tonemap;
++>>>>>>> RealBadAngel/master
  };
  
  #endif
